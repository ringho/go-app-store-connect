// Package apple provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apple

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// AgeRatingDeclaration defines model for AgeRatingDeclaration.
type AgeRatingDeclaration struct {
	Attributes *struct {
		AlcoholTobaccoOrDrugUseOrReferences         *string      `json:"alcoholTobaccoOrDrugUseOrReferences,omitempty"`
		GamblingAndContests                         *bool        `json:"gamblingAndContests,omitempty"`
		GamblingSimulated                           *string      `json:"gamblingSimulated,omitempty"`
		HorrorOrFearThemes                          *string      `json:"horrorOrFearThemes,omitempty"`
		KidsAgeBand                                 *KidsAgeBand `json:"kidsAgeBand,omitempty"`
		MatureOrSuggestiveThemes                    *string      `json:"matureOrSuggestiveThemes,omitempty"`
		MedicalOrTreatmentInformation               *string      `json:"medicalOrTreatmentInformation,omitempty"`
		ProfanityOrCrudeHumor                       *string      `json:"profanityOrCrudeHumor,omitempty"`
		SexualContentGraphicAndNudity               *string      `json:"sexualContentGraphicAndNudity,omitempty"`
		SexualContentOrNudity                       *string      `json:"sexualContentOrNudity,omitempty"`
		UnrestrictedWebAccess                       *bool        `json:"unrestrictedWebAccess,omitempty"`
		ViolenceCartoonOrFantasy                    *string      `json:"violenceCartoonOrFantasy,omitempty"`
		ViolenceRealistic                           *string      `json:"violenceRealistic,omitempty"`
		ViolenceRealisticProlongedGraphicOrSadistic *string      `json:"violenceRealisticProlongedGraphicOrSadistic,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// AgeRatingDeclarationResponse defines model for AgeRatingDeclarationResponse.
type AgeRatingDeclarationResponse struct {
	Data  AgeRatingDeclaration `json:"data"`
	Links DocumentLinks        `json:"links"`
}

// AgeRatingDeclarationUpdateRequest defines model for AgeRatingDeclarationUpdateRequest.
type AgeRatingDeclarationUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AlcoholTobaccoOrDrugUseOrReferences         *string      `json:"alcoholTobaccoOrDrugUseOrReferences,omitempty"`
			GamblingAndContests                         *bool        `json:"gamblingAndContests,omitempty"`
			GamblingSimulated                           *string      `json:"gamblingSimulated,omitempty"`
			HorrorOrFearThemes                          *string      `json:"horrorOrFearThemes,omitempty"`
			KidsAgeBand                                 *KidsAgeBand `json:"kidsAgeBand,omitempty"`
			MatureOrSuggestiveThemes                    *string      `json:"matureOrSuggestiveThemes,omitempty"`
			MedicalOrTreatmentInformation               *string      `json:"medicalOrTreatmentInformation,omitempty"`
			ProfanityOrCrudeHumor                       *string      `json:"profanityOrCrudeHumor,omitempty"`
			SexualContentGraphicAndNudity               *string      `json:"sexualContentGraphicAndNudity,omitempty"`
			SexualContentOrNudity                       *string      `json:"sexualContentOrNudity,omitempty"`
			UnrestrictedWebAccess                       *bool        `json:"unrestrictedWebAccess,omitempty"`
			ViolenceCartoonOrFantasy                    *string      `json:"violenceCartoonOrFantasy,omitempty"`
			ViolenceRealistic                           *string      `json:"violenceRealistic,omitempty"`
			ViolenceRealisticProlongedGraphicOrSadistic *string      `json:"violenceRealisticProlongedGraphicOrSadistic,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// App defines model for App.
type App struct {
	Attributes *struct {
		AvailableInNewTerritories *bool   `json:"availableInNewTerritories,omitempty"`
		BundleId                  *string `json:"bundleId,omitempty"`
		ContentRightsDeclaration  *string `json:"contentRightsDeclaration,omitempty"`
		IsOrEverWasMadeForKids    *bool   `json:"isOrEverWasMadeForKids,omitempty"`
		Name                      *string `json:"name,omitempty"`
		PrimaryLocale             *string `json:"primaryLocale,omitempty"`
		Sku                       *string `json:"sku,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppInfos *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appInfos,omitempty"`
		AppStoreVersions *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appStoreVersions,omitempty"`
		AvailableTerritories *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"availableTerritories,omitempty"`
		BetaAppLocalizations *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"betaAppLocalizations,omitempty"`
		BetaAppReviewDetail *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"betaAppReviewDetail,omitempty"`
		BetaGroups *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"betaGroups,omitempty"`
		BetaLicenseAgreement *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"betaLicenseAgreement,omitempty"`
		Builds *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"builds,omitempty"`
		EndUserLicenseAgreement *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"endUserLicenseAgreement,omitempty"`
		GameCenterEnabledVersions *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"gameCenterEnabledVersions,omitempty"`
		InAppPurchases *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"inAppPurchases,omitempty"`
		PreOrder *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"preOrder,omitempty"`
		PreReleaseVersions *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"preReleaseVersions,omitempty"`
		Prices *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"prices,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppBetaTestersLinkagesRequest defines model for AppBetaTestersLinkagesRequest.
type AppBetaTestersLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppCategoriesResponse defines model for AppCategoriesResponse.
type AppCategoriesResponse struct {
	Data     []AppCategory      `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppCategory defines model for AppCategory.
type AppCategory struct {
	Attributes *struct {
		Platforms *[]Platform `json:"platforms,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		Parent *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"parent,omitempty"`
		Subcategories *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"subcategories,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppCategoryResponse defines model for AppCategoryResponse.
type AppCategoryResponse struct {
	Data     AppCategory    `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// AppEncryptionDeclaration defines model for AppEncryptionDeclaration.
type AppEncryptionDeclaration struct {
	Attributes *struct {
		AppEncryptionDeclarationState   *AppEncryptionDeclarationState `json:"appEncryptionDeclarationState,omitempty"`
		AvailableOnFrenchStore          *bool                          `json:"availableOnFrenchStore,omitempty"`
		CodeValue                       *string                        `json:"codeValue,omitempty"`
		ContainsProprietaryCryptography *bool                          `json:"containsProprietaryCryptography,omitempty"`
		ContainsThirdPartyCryptography  *bool                          `json:"containsThirdPartyCryptography,omitempty"`
		DocumentName                    *string                        `json:"documentName,omitempty"`
		DocumentType                    *string                        `json:"documentType,omitempty"`
		DocumentUrl                     *string                        `json:"documentUrl,omitempty"`
		Exempt                          *bool                          `json:"exempt,omitempty"`
		Platform                        *Platform                      `json:"platform,omitempty"`
		UploadedDate                    *time.Time                     `json:"uploadedDate,omitempty"`
		UsesEncryption                  *bool                          `json:"usesEncryption,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppEncryptionDeclarationBuildsLinkagesRequest defines model for AppEncryptionDeclarationBuildsLinkagesRequest.
type AppEncryptionDeclarationBuildsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppEncryptionDeclarationResponse defines model for AppEncryptionDeclarationResponse.
type AppEncryptionDeclarationResponse struct {
	Data     AppEncryptionDeclaration `json:"data"`
	Included *[]App                   `json:"included,omitempty"`
	Links    DocumentLinks            `json:"links"`
}

// AppEncryptionDeclarationState defines model for AppEncryptionDeclarationState.
type AppEncryptionDeclarationState string

// List of AppEncryptionDeclarationState
const (
	AppEncryptionDeclarationState_APPROVED  AppEncryptionDeclarationState = "APPROVED"
	AppEncryptionDeclarationState_EXPIRED   AppEncryptionDeclarationState = "EXPIRED"
	AppEncryptionDeclarationState_INVALID   AppEncryptionDeclarationState = "INVALID"
	AppEncryptionDeclarationState_IN_REVIEW AppEncryptionDeclarationState = "IN_REVIEW"
	AppEncryptionDeclarationState_REJECTED  AppEncryptionDeclarationState = "REJECTED"
)

// AppEncryptionDeclarationsResponse defines model for AppEncryptionDeclarationsResponse.
type AppEncryptionDeclarationsResponse struct {
	Data     []AppEncryptionDeclaration `json:"data"`
	Included *[]App                     `json:"included,omitempty"`
	Links    PagedDocumentLinks         `json:"links"`
	Meta     *PagingInformation         `json:"meta,omitempty"`
}

// AppInfo defines model for AppInfo.
type AppInfo struct {
	Attributes *struct {
		AppStoreAgeRating *AppStoreAgeRating    `json:"appStoreAgeRating,omitempty"`
		AppStoreState     *AppStoreVersionState `json:"appStoreState,omitempty"`
		BrazilAgeRating   *BrazilAgeRating      `json:"brazilAgeRating,omitempty"`
		KidsAgeBand       *KidsAgeBand          `json:"kidsAgeBand,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		AppInfoLocalizations *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appInfoLocalizations,omitempty"`
		PrimaryCategory *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"primaryCategory,omitempty"`
		PrimarySubcategoryOne *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"primarySubcategoryOne,omitempty"`
		PrimarySubcategoryTwo *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"primarySubcategoryTwo,omitempty"`
		SecondaryCategory *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"secondaryCategory,omitempty"`
		SecondarySubcategoryOne *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"secondarySubcategoryOne,omitempty"`
		SecondarySubcategoryTwo *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"secondarySubcategoryTwo,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppInfoLocalization defines model for AppInfoLocalization.
type AppInfoLocalization struct {
	Attributes *struct {
		Locale            *string `json:"locale,omitempty"`
		Name              *string `json:"name,omitempty"`
		PrivacyPolicyText *string `json:"privacyPolicyText,omitempty"`
		PrivacyPolicyUrl  *string `json:"privacyPolicyUrl,omitempty"`
		Subtitle          *string `json:"subtitle,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppInfo *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appInfo,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppInfoLocalizationCreateRequest defines model for AppInfoLocalizationCreateRequest.
type AppInfoLocalizationCreateRequest struct {
	Data struct {
		Attributes struct {
			Locale            string  `json:"locale"`
			Name              *string `json:"name,omitempty"`
			PrivacyPolicyText *string `json:"privacyPolicyText,omitempty"`
			PrivacyPolicyUrl  *string `json:"privacyPolicyUrl,omitempty"`
			Subtitle          *string `json:"subtitle,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			AppInfo struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appInfo"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppInfoLocalizationResponse defines model for AppInfoLocalizationResponse.
type AppInfoLocalizationResponse struct {
	Data  AppInfoLocalization `json:"data"`
	Links DocumentLinks       `json:"links"`
}

// AppInfoLocalizationUpdateRequest defines model for AppInfoLocalizationUpdateRequest.
type AppInfoLocalizationUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Name              *string `json:"name,omitempty"`
			PrivacyPolicyText *string `json:"privacyPolicyText,omitempty"`
			PrivacyPolicyUrl  *string `json:"privacyPolicyUrl,omitempty"`
			Subtitle          *string `json:"subtitle,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppInfoLocalizationsResponse defines model for AppInfoLocalizationsResponse.
type AppInfoLocalizationsResponse struct {
	Data  []AppInfoLocalization `json:"data"`
	Links PagedDocumentLinks    `json:"links"`
	Meta  *PagingInformation    `json:"meta,omitempty"`
}

// AppInfoResponse defines model for AppInfoResponse.
type AppInfoResponse struct {
	Data     AppInfo        `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// AppInfoUpdateRequest defines model for AppInfoUpdateRequest.
type AppInfoUpdateRequest struct {
	Data struct {
		Id            string `json:"id"`
		Relationships *struct {
			PrimaryCategory *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"primaryCategory,omitempty"`
			PrimarySubcategoryOne *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"primarySubcategoryOne,omitempty"`
			PrimarySubcategoryTwo *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"primarySubcategoryTwo,omitempty"`
			SecondaryCategory *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"secondaryCategory,omitempty"`
			SecondarySubcategoryOne *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"secondarySubcategoryOne,omitempty"`
			SecondarySubcategoryTwo *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"secondarySubcategoryTwo,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppInfosResponse defines model for AppInfosResponse.
type AppInfosResponse struct {
	Data     []AppInfo          `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppMediaAssetState defines model for AppMediaAssetState.
type AppMediaAssetState struct {
	Errors   *[]AppMediaStateError `json:"errors,omitempty"`
	State    *string               `json:"state,omitempty"`
	Warnings *[]AppMediaStateError `json:"warnings,omitempty"`
}

// AppMediaStateError defines model for AppMediaStateError.
type AppMediaStateError struct {
	Code        *string `json:"code,omitempty"`
	Description *string `json:"description,omitempty"`
}

// AppPreOrder defines model for AppPreOrder.
type AppPreOrder struct {
	Attributes *struct {
		AppReleaseDate        *openapi_types.Date `json:"appReleaseDate,omitempty"`
		PreOrderAvailableDate *openapi_types.Date `json:"preOrderAvailableDate,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppPreOrderCreateRequest defines model for AppPreOrderCreateRequest.
type AppPreOrderCreateRequest struct {
	Data struct {
		Attributes *struct {
			AppReleaseDate *openapi_types.Date `json:"appReleaseDate,omitempty"`
		} `json:"attributes,omitempty"`
		Relationships struct {
			App struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"app"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppPreOrderResponse defines model for AppPreOrderResponse.
type AppPreOrderResponse struct {
	Data  AppPreOrder   `json:"data"`
	Links DocumentLinks `json:"links"`
}

// AppPreOrderUpdateRequest defines model for AppPreOrderUpdateRequest.
type AppPreOrderUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AppReleaseDate *openapi_types.Date `json:"appReleaseDate,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppPreview defines model for AppPreview.
type AppPreview struct {
	Attributes *struct {
		AssetDeliveryState   *AppMediaAssetState `json:"assetDeliveryState,omitempty"`
		FileName             *string             `json:"fileName,omitempty"`
		FileSize             *int                `json:"fileSize,omitempty"`
		MimeType             *string             `json:"mimeType,omitempty"`
		PreviewFrameTimeCode *string             `json:"previewFrameTimeCode,omitempty"`
		PreviewImage         *ImageAsset         `json:"previewImage,omitempty"`
		SourceFileChecksum   *string             `json:"sourceFileChecksum,omitempty"`
		UploadOperations     *[]UploadOperation  `json:"uploadOperations,omitempty"`
		VideoUrl             *string             `json:"videoUrl,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppPreviewSet *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appPreviewSet,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppPreviewCreateRequest defines model for AppPreviewCreateRequest.
type AppPreviewCreateRequest struct {
	Data struct {
		Attributes struct {
			FileName             string  `json:"fileName"`
			FileSize             int     `json:"fileSize"`
			MimeType             *string `json:"mimeType,omitempty"`
			PreviewFrameTimeCode *string `json:"previewFrameTimeCode,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			AppPreviewSet struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appPreviewSet"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppPreviewResponse defines model for AppPreviewResponse.
type AppPreviewResponse struct {
	Data  AppPreview    `json:"data"`
	Links DocumentLinks `json:"links"`
}

// AppPreviewSet defines model for AppPreviewSet.
type AppPreviewSet struct {
	Attributes *struct {
		PreviewType *PreviewType `json:"previewType,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppPreviews *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appPreviews,omitempty"`
		AppStoreVersionLocalization *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersionLocalization,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppPreviewSetAppPreviewsLinkagesRequest defines model for AppPreviewSetAppPreviewsLinkagesRequest.
type AppPreviewSetAppPreviewsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppPreviewSetAppPreviewsLinkagesResponse defines model for AppPreviewSetAppPreviewsLinkagesResponse.
type AppPreviewSetAppPreviewsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// AppPreviewSetCreateRequest defines model for AppPreviewSetCreateRequest.
type AppPreviewSetCreateRequest struct {
	Data struct {
		Attributes struct {
			PreviewType PreviewType `json:"previewType"`
		} `json:"attributes"`
		Relationships struct {
			AppStoreVersionLocalization struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersionLocalization"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppPreviewSetResponse defines model for AppPreviewSetResponse.
type AppPreviewSetResponse struct {
	Data     AppPreviewSet `json:"data"`
	Included *[]AppPreview `json:"included,omitempty"`
	Links    DocumentLinks `json:"links"`
}

// AppPreviewSetsResponse defines model for AppPreviewSetsResponse.
type AppPreviewSetsResponse struct {
	Data     []AppPreviewSet    `json:"data"`
	Included *[]AppPreview      `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppPreviewUpdateRequest defines model for AppPreviewUpdateRequest.
type AppPreviewUpdateRequest struct {
	Data struct {
		Attributes *struct {
			PreviewFrameTimeCode *string `json:"previewFrameTimeCode,omitempty"`
			SourceFileChecksum   *string `json:"sourceFileChecksum,omitempty"`
			Uploaded             *bool   `json:"uploaded,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppPreviewsResponse defines model for AppPreviewsResponse.
type AppPreviewsResponse struct {
	Data  []AppPreview       `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// AppPrice defines model for AppPrice.
type AppPrice struct {
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		PriceTier *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"priceTier,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppPricePoint defines model for AppPricePoint.
type AppPricePoint struct {
	Attributes *struct {
		CustomerPrice *string `json:"customerPrice,omitempty"`
		Proceeds      *string `json:"proceeds,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		PriceTier *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"priceTier,omitempty"`
		Territory *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"territory,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppPricePointResponse defines model for AppPricePointResponse.
type AppPricePointResponse struct {
	Data     AppPricePoint `json:"data"`
	Included *[]Territory  `json:"included,omitempty"`
	Links    DocumentLinks `json:"links"`
}

// AppPricePointsResponse defines model for AppPricePointsResponse.
type AppPricePointsResponse struct {
	Data     []AppPricePoint    `json:"data"`
	Included *[]Territory       `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppPriceResponse defines model for AppPriceResponse.
type AppPriceResponse struct {
	Data  AppPrice      `json:"data"`
	Links DocumentLinks `json:"links"`
}

// AppPriceTier defines model for AppPriceTier.
type AppPriceTier struct {
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		PricePoints *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"pricePoints,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppPriceTierResponse defines model for AppPriceTierResponse.
type AppPriceTierResponse struct {
	Data     AppPriceTier     `json:"data"`
	Included *[]AppPricePoint `json:"included,omitempty"`
	Links    DocumentLinks    `json:"links"`
}

// AppPriceTiersResponse defines model for AppPriceTiersResponse.
type AppPriceTiersResponse struct {
	Data     []AppPriceTier     `json:"data"`
	Included *[]AppPricePoint   `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppPricesResponse defines model for AppPricesResponse.
type AppPricesResponse struct {
	Data  []AppPrice         `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// AppResponse defines model for AppResponse.
type AppResponse struct {
	Data     App            `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// AppScreenshot defines model for AppScreenshot.
type AppScreenshot struct {
	Attributes *struct {
		AssetDeliveryState *AppMediaAssetState `json:"assetDeliveryState,omitempty"`
		AssetToken         *string             `json:"assetToken,omitempty"`
		AssetType          *string             `json:"assetType,omitempty"`
		FileName           *string             `json:"fileName,omitempty"`
		FileSize           *int                `json:"fileSize,omitempty"`
		ImageAsset         *ImageAsset         `json:"imageAsset,omitempty"`
		SourceFileChecksum *string             `json:"sourceFileChecksum,omitempty"`
		UploadOperations   *[]UploadOperation  `json:"uploadOperations,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppScreenshotSet *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appScreenshotSet,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppScreenshotCreateRequest defines model for AppScreenshotCreateRequest.
type AppScreenshotCreateRequest struct {
	Data struct {
		Attributes struct {
			FileName string `json:"fileName"`
			FileSize int    `json:"fileSize"`
		} `json:"attributes"`
		Relationships struct {
			AppScreenshotSet struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appScreenshotSet"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppScreenshotResponse defines model for AppScreenshotResponse.
type AppScreenshotResponse struct {
	Data  AppScreenshot `json:"data"`
	Links DocumentLinks `json:"links"`
}

// AppScreenshotSet defines model for AppScreenshotSet.
type AppScreenshotSet struct {
	Attributes *struct {
		ScreenshotDisplayType *ScreenshotDisplayType `json:"screenshotDisplayType,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppScreenshots *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appScreenshots,omitempty"`
		AppStoreVersionLocalization *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersionLocalization,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppScreenshotSetAppScreenshotsLinkagesRequest defines model for AppScreenshotSetAppScreenshotsLinkagesRequest.
type AppScreenshotSetAppScreenshotsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppScreenshotSetAppScreenshotsLinkagesResponse defines model for AppScreenshotSetAppScreenshotsLinkagesResponse.
type AppScreenshotSetAppScreenshotsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// AppScreenshotSetCreateRequest defines model for AppScreenshotSetCreateRequest.
type AppScreenshotSetCreateRequest struct {
	Data struct {
		Attributes struct {
			ScreenshotDisplayType ScreenshotDisplayType `json:"screenshotDisplayType"`
		} `json:"attributes"`
		Relationships struct {
			AppStoreVersionLocalization struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersionLocalization"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppScreenshotSetResponse defines model for AppScreenshotSetResponse.
type AppScreenshotSetResponse struct {
	Data     AppScreenshotSet `json:"data"`
	Included *[]AppScreenshot `json:"included,omitempty"`
	Links    DocumentLinks    `json:"links"`
}

// AppScreenshotSetsResponse defines model for AppScreenshotSetsResponse.
type AppScreenshotSetsResponse struct {
	Data     []AppScreenshotSet `json:"data"`
	Included *[]AppScreenshot   `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppScreenshotUpdateRequest defines model for AppScreenshotUpdateRequest.
type AppScreenshotUpdateRequest struct {
	Data struct {
		Attributes *struct {
			SourceFileChecksum *string `json:"sourceFileChecksum,omitempty"`
			Uploaded           *bool   `json:"uploaded,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppScreenshotsResponse defines model for AppScreenshotsResponse.
type AppScreenshotsResponse struct {
	Data  []AppScreenshot    `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// AppStoreAgeRating defines model for AppStoreAgeRating.
type AppStoreAgeRating string

// List of AppStoreAgeRating
const (
	AppStoreAgeRating_FOUR_PLUS      AppStoreAgeRating = "FOUR_PLUS"
	AppStoreAgeRating_NINE_PLUS      AppStoreAgeRating = "NINE_PLUS"
	AppStoreAgeRating_SEVENTEEN_PLUS AppStoreAgeRating = "SEVENTEEN_PLUS"
	AppStoreAgeRating_TWELVE_PLUS    AppStoreAgeRating = "TWELVE_PLUS"
)

// AppStoreReviewAttachment defines model for AppStoreReviewAttachment.
type AppStoreReviewAttachment struct {
	Attributes *struct {
		AssetDeliveryState *AppMediaAssetState `json:"assetDeliveryState,omitempty"`
		FileName           *string             `json:"fileName,omitempty"`
		FileSize           *int                `json:"fileSize,omitempty"`
		SourceFileChecksum *string             `json:"sourceFileChecksum,omitempty"`
		UploadOperations   *[]UploadOperation  `json:"uploadOperations,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppStoreReviewDetail *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreReviewDetail,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppStoreReviewAttachmentCreateRequest defines model for AppStoreReviewAttachmentCreateRequest.
type AppStoreReviewAttachmentCreateRequest struct {
	Data struct {
		Attributes struct {
			FileName string `json:"fileName"`
			FileSize int    `json:"fileSize"`
		} `json:"attributes"`
		Relationships struct {
			AppStoreReviewDetail struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreReviewDetail"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreReviewAttachmentResponse defines model for AppStoreReviewAttachmentResponse.
type AppStoreReviewAttachmentResponse struct {
	Data  AppStoreReviewAttachment `json:"data"`
	Links DocumentLinks            `json:"links"`
}

// AppStoreReviewAttachmentUpdateRequest defines model for AppStoreReviewAttachmentUpdateRequest.
type AppStoreReviewAttachmentUpdateRequest struct {
	Data struct {
		Attributes *struct {
			SourceFileChecksum *string `json:"sourceFileChecksum,omitempty"`
			Uploaded           *bool   `json:"uploaded,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreReviewAttachmentsResponse defines model for AppStoreReviewAttachmentsResponse.
type AppStoreReviewAttachmentsResponse struct {
	Data  []AppStoreReviewAttachment `json:"data"`
	Links PagedDocumentLinks         `json:"links"`
	Meta  *PagingInformation         `json:"meta,omitempty"`
}

// AppStoreReviewDetail defines model for AppStoreReviewDetail.
type AppStoreReviewDetail struct {
	Attributes *struct {
		ContactEmail        *string `json:"contactEmail,omitempty"`
		ContactFirstName    *string `json:"contactFirstName,omitempty"`
		ContactLastName     *string `json:"contactLastName,omitempty"`
		ContactPhone        *string `json:"contactPhone,omitempty"`
		DemoAccountName     *string `json:"demoAccountName,omitempty"`
		DemoAccountPassword *string `json:"demoAccountPassword,omitempty"`
		DemoAccountRequired *bool   `json:"demoAccountRequired,omitempty"`
		Notes               *string `json:"notes,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppStoreReviewAttachments *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appStoreReviewAttachments,omitempty"`
		AppStoreVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersion,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppStoreReviewDetailCreateRequest defines model for AppStoreReviewDetailCreateRequest.
type AppStoreReviewDetailCreateRequest struct {
	Data struct {
		Attributes *struct {
			ContactEmail        *string `json:"contactEmail,omitempty"`
			ContactFirstName    *string `json:"contactFirstName,omitempty"`
			ContactLastName     *string `json:"contactLastName,omitempty"`
			ContactPhone        *string `json:"contactPhone,omitempty"`
			DemoAccountName     *string `json:"demoAccountName,omitempty"`
			DemoAccountPassword *string `json:"demoAccountPassword,omitempty"`
			DemoAccountRequired *bool   `json:"demoAccountRequired,omitempty"`
			Notes               *string `json:"notes,omitempty"`
		} `json:"attributes,omitempty"`
		Relationships struct {
			AppStoreVersion struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersion"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreReviewDetailResponse defines model for AppStoreReviewDetailResponse.
type AppStoreReviewDetailResponse struct {
	Data     AppStoreReviewDetail        `json:"data"`
	Included *[]AppStoreReviewAttachment `json:"included,omitempty"`
	Links    DocumentLinks               `json:"links"`
}

// AppStoreReviewDetailUpdateRequest defines model for AppStoreReviewDetailUpdateRequest.
type AppStoreReviewDetailUpdateRequest struct {
	Data struct {
		Attributes *struct {
			ContactEmail        *string `json:"contactEmail,omitempty"`
			ContactFirstName    *string `json:"contactFirstName,omitempty"`
			ContactLastName     *string `json:"contactLastName,omitempty"`
			ContactPhone        *string `json:"contactPhone,omitempty"`
			DemoAccountName     *string `json:"demoAccountName,omitempty"`
			DemoAccountPassword *string `json:"demoAccountPassword,omitempty"`
			DemoAccountRequired *bool   `json:"demoAccountRequired,omitempty"`
			Notes               *string `json:"notes,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersion defines model for AppStoreVersion.
type AppStoreVersion struct {
	Attributes *struct {
		AppStoreState       *AppStoreVersionState `json:"appStoreState,omitempty"`
		Copyright           *string               `json:"copyright,omitempty"`
		CreatedDate         *time.Time            `json:"createdDate,omitempty"`
		Downloadable        *bool                 `json:"downloadable,omitempty"`
		EarliestReleaseDate *time.Time            `json:"earliestReleaseDate,omitempty"`
		Platform            *Platform             `json:"platform,omitempty"`
		ReleaseType         *string               `json:"releaseType,omitempty"`
		UsesIdfa            *bool                 `json:"usesIdfa,omitempty"`
		VersionString       *string               `json:"versionString,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AgeRatingDeclaration *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"ageRatingDeclaration,omitempty"`
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		AppStoreReviewDetail *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreReviewDetail,omitempty"`
		AppStoreVersionLocalizations *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appStoreVersionLocalizations,omitempty"`
		AppStoreVersionPhasedRelease *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersionPhasedRelease,omitempty"`
		AppStoreVersionSubmission *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersionSubmission,omitempty"`
		Build *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"build,omitempty"`
		IdfaDeclaration *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"idfaDeclaration,omitempty"`
		RoutingAppCoverage *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"routingAppCoverage,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppStoreVersionBuildLinkageRequest defines model for AppStoreVersionBuildLinkageRequest.
type AppStoreVersionBuildLinkageRequest struct {
	Data struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionBuildLinkageResponse defines model for AppStoreVersionBuildLinkageResponse.
type AppStoreVersionBuildLinkageResponse struct {
	Data struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links DocumentLinks `json:"links"`
}

// AppStoreVersionCreateRequest defines model for AppStoreVersionCreateRequest.
type AppStoreVersionCreateRequest struct {
	Data struct {
		Attributes struct {
			Copyright           *string    `json:"copyright,omitempty"`
			EarliestReleaseDate *time.Time `json:"earliestReleaseDate,omitempty"`
			Platform            Platform   `json:"platform"`
			ReleaseType         *string    `json:"releaseType,omitempty"`
			UsesIdfa            *bool      `json:"usesIdfa,omitempty"`
			VersionString       string     `json:"versionString"`
		} `json:"attributes"`
		Relationships struct {
			App struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"app"`
			Build *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"build,omitempty"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionLocalization defines model for AppStoreVersionLocalization.
type AppStoreVersionLocalization struct {
	Attributes *struct {
		Description     *string `json:"description,omitempty"`
		Keywords        *string `json:"keywords,omitempty"`
		Locale          *string `json:"locale,omitempty"`
		MarketingUrl    *string `json:"marketingUrl,omitempty"`
		PromotionalText *string `json:"promotionalText,omitempty"`
		SupportUrl      *string `json:"supportUrl,omitempty"`
		WhatsNew        *string `json:"whatsNew,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppPreviewSets *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appPreviewSets,omitempty"`
		AppScreenshotSets *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"appScreenshotSets,omitempty"`
		AppStoreVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersion,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppStoreVersionLocalizationCreateRequest defines model for AppStoreVersionLocalizationCreateRequest.
type AppStoreVersionLocalizationCreateRequest struct {
	Data struct {
		Attributes struct {
			Description     *string `json:"description,omitempty"`
			Keywords        *string `json:"keywords,omitempty"`
			Locale          string  `json:"locale"`
			MarketingUrl    *string `json:"marketingUrl,omitempty"`
			PromotionalText *string `json:"promotionalText,omitempty"`
			SupportUrl      *string `json:"supportUrl,omitempty"`
			WhatsNew        *string `json:"whatsNew,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			AppStoreVersion struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersion"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionLocalizationResponse defines model for AppStoreVersionLocalizationResponse.
type AppStoreVersionLocalizationResponse struct {
	Data     AppStoreVersionLocalization `json:"data"`
	Included *[]interface{}              `json:"included,omitempty"`
	Links    DocumentLinks               `json:"links"`
}

// AppStoreVersionLocalizationUpdateRequest defines model for AppStoreVersionLocalizationUpdateRequest.
type AppStoreVersionLocalizationUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Description     *string `json:"description,omitempty"`
			Keywords        *string `json:"keywords,omitempty"`
			MarketingUrl    *string `json:"marketingUrl,omitempty"`
			PromotionalText *string `json:"promotionalText,omitempty"`
			SupportUrl      *string `json:"supportUrl,omitempty"`
			WhatsNew        *string `json:"whatsNew,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionLocalizationsResponse defines model for AppStoreVersionLocalizationsResponse.
type AppStoreVersionLocalizationsResponse struct {
	Data     []AppStoreVersionLocalization `json:"data"`
	Included *[]interface{}                `json:"included,omitempty"`
	Links    PagedDocumentLinks            `json:"links"`
	Meta     *PagingInformation            `json:"meta,omitempty"`
}

// AppStoreVersionPhasedRelease defines model for AppStoreVersionPhasedRelease.
type AppStoreVersionPhasedRelease struct {
	Attributes *struct {
		CurrentDayNumber   *int                `json:"currentDayNumber,omitempty"`
		PhasedReleaseState *PhasedReleaseState `json:"phasedReleaseState,omitempty"`
		StartDate          *time.Time          `json:"startDate,omitempty"`
		TotalPauseDuration *int                `json:"totalPauseDuration,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// AppStoreVersionPhasedReleaseCreateRequest defines model for AppStoreVersionPhasedReleaseCreateRequest.
type AppStoreVersionPhasedReleaseCreateRequest struct {
	Data struct {
		Attributes *struct {
			PhasedReleaseState *PhasedReleaseState `json:"phasedReleaseState,omitempty"`
		} `json:"attributes,omitempty"`
		Relationships struct {
			AppStoreVersion struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersion"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionPhasedReleaseResponse defines model for AppStoreVersionPhasedReleaseResponse.
type AppStoreVersionPhasedReleaseResponse struct {
	Data  AppStoreVersionPhasedRelease `json:"data"`
	Links DocumentLinks                `json:"links"`
}

// AppStoreVersionPhasedReleaseUpdateRequest defines model for AppStoreVersionPhasedReleaseUpdateRequest.
type AppStoreVersionPhasedReleaseUpdateRequest struct {
	Data struct {
		Attributes *struct {
			PhasedReleaseState *PhasedReleaseState `json:"phasedReleaseState,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionResponse defines model for AppStoreVersionResponse.
type AppStoreVersionResponse struct {
	Data     AppStoreVersion `json:"data"`
	Included *[]interface{}  `json:"included,omitempty"`
	Links    DocumentLinks   `json:"links"`
}

// AppStoreVersionState defines model for AppStoreVersionState.
type AppStoreVersionState string

// List of AppStoreVersionState
const (
	AppStoreVersionState_DEVELOPER_REJECTED            AppStoreVersionState = "DEVELOPER_REJECTED"
	AppStoreVersionState_DEVELOPER_REMOVED_FROM_SALE   AppStoreVersionState = "DEVELOPER_REMOVED_FROM_SALE"
	AppStoreVersionState_INVALID_BINARY                AppStoreVersionState = "INVALID_BINARY"
	AppStoreVersionState_IN_REVIEW                     AppStoreVersionState = "IN_REVIEW"
	AppStoreVersionState_METADATA_REJECTED             AppStoreVersionState = "METADATA_REJECTED"
	AppStoreVersionState_PENDING_APPLE_RELEASE         AppStoreVersionState = "PENDING_APPLE_RELEASE"
	AppStoreVersionState_PENDING_CONTRACT              AppStoreVersionState = "PENDING_CONTRACT"
	AppStoreVersionState_PENDING_DEVELOPER_RELEASE     AppStoreVersionState = "PENDING_DEVELOPER_RELEASE"
	AppStoreVersionState_PREORDER_READY_FOR_SALE       AppStoreVersionState = "PREORDER_READY_FOR_SALE"
	AppStoreVersionState_PREPARE_FOR_SUBMISSION        AppStoreVersionState = "PREPARE_FOR_SUBMISSION"
	AppStoreVersionState_PROCESSING_FOR_APP_STORE      AppStoreVersionState = "PROCESSING_FOR_APP_STORE"
	AppStoreVersionState_READY_FOR_SALE                AppStoreVersionState = "READY_FOR_SALE"
	AppStoreVersionState_REJECTED                      AppStoreVersionState = "REJECTED"
	AppStoreVersionState_REMOVED_FROM_SALE             AppStoreVersionState = "REMOVED_FROM_SALE"
	AppStoreVersionState_REPLACED_WITH_NEW_VERSION     AppStoreVersionState = "REPLACED_WITH_NEW_VERSION"
	AppStoreVersionState_WAITING_FOR_EXPORT_COMPLIANCE AppStoreVersionState = "WAITING_FOR_EXPORT_COMPLIANCE"
	AppStoreVersionState_WAITING_FOR_REVIEW            AppStoreVersionState = "WAITING_FOR_REVIEW"
)

// AppStoreVersionSubmission defines model for AppStoreVersionSubmission.
type AppStoreVersionSubmission struct {
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppStoreVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersion,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// AppStoreVersionSubmissionCreateRequest defines model for AppStoreVersionSubmissionCreateRequest.
type AppStoreVersionSubmissionCreateRequest struct {
	Data struct {
		Relationships struct {
			AppStoreVersion struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersion"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionSubmissionResponse defines model for AppStoreVersionSubmissionResponse.
type AppStoreVersionSubmissionResponse struct {
	Data  AppStoreVersionSubmission `json:"data"`
	Links DocumentLinks             `json:"links"`
}

// AppStoreVersionUpdateRequest defines model for AppStoreVersionUpdateRequest.
type AppStoreVersionUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Copyright           *string    `json:"copyright,omitempty"`
			Downloadable        *bool      `json:"downloadable,omitempty"`
			EarliestReleaseDate *time.Time `json:"earliestReleaseDate,omitempty"`
			ReleaseType         *string    `json:"releaseType,omitempty"`
			UsesIdfa            *bool      `json:"usesIdfa,omitempty"`
			VersionString       *string    `json:"versionString,omitempty"`
		} `json:"attributes,omitempty"`
		Id            string `json:"id"`
		Relationships *struct {
			Build *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"build,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppStoreVersionsResponse defines model for AppStoreVersionsResponse.
type AppStoreVersionsResponse struct {
	Data     []AppStoreVersion  `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AppUpdateRequest defines model for AppUpdateRequest.
type AppUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AvailableInNewTerritories *bool   `json:"availableInNewTerritories,omitempty"`
			BundleId                  *string `json:"bundleId,omitempty"`
			ContentRightsDeclaration  *string `json:"contentRightsDeclaration,omitempty"`
			PrimaryLocale             *string `json:"primaryLocale,omitempty"`
		} `json:"attributes,omitempty"`
		Id            string `json:"id"`
		Relationships *struct {
			AvailableTerritories *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"availableTerritories,omitempty"`
			Prices *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"prices,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// AppsResponse defines model for AppsResponse.
type AppsResponse struct {
	Data     []App              `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// BetaAppLocalization defines model for BetaAppLocalization.
type BetaAppLocalization struct {
	Attributes *struct {
		Description       *string `json:"description,omitempty"`
		FeedbackEmail     *string `json:"feedbackEmail,omitempty"`
		Locale            *string `json:"locale,omitempty"`
		MarketingUrl      *string `json:"marketingUrl,omitempty"`
		PrivacyPolicyUrl  *string `json:"privacyPolicyUrl,omitempty"`
		TvOsPrivacyPolicy *string `json:"tvOsPrivacyPolicy,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaAppLocalizationCreateRequest defines model for BetaAppLocalizationCreateRequest.
type BetaAppLocalizationCreateRequest struct {
	Data struct {
		Attributes struct {
			Description       *string `json:"description,omitempty"`
			FeedbackEmail     *string `json:"feedbackEmail,omitempty"`
			Locale            string  `json:"locale"`
			MarketingUrl      *string `json:"marketingUrl,omitempty"`
			PrivacyPolicyUrl  *string `json:"privacyPolicyUrl,omitempty"`
			TvOsPrivacyPolicy *string `json:"tvOsPrivacyPolicy,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			App struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"app"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaAppLocalizationResponse defines model for BetaAppLocalizationResponse.
type BetaAppLocalizationResponse struct {
	Data     BetaAppLocalization `json:"data"`
	Included *[]App              `json:"included,omitempty"`
	Links    DocumentLinks       `json:"links"`
}

// BetaAppLocalizationUpdateRequest defines model for BetaAppLocalizationUpdateRequest.
type BetaAppLocalizationUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Description       *string `json:"description,omitempty"`
			FeedbackEmail     *string `json:"feedbackEmail,omitempty"`
			MarketingUrl      *string `json:"marketingUrl,omitempty"`
			PrivacyPolicyUrl  *string `json:"privacyPolicyUrl,omitempty"`
			TvOsPrivacyPolicy *string `json:"tvOsPrivacyPolicy,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaAppLocalizationsResponse defines model for BetaAppLocalizationsResponse.
type BetaAppLocalizationsResponse struct {
	Data     []BetaAppLocalization `json:"data"`
	Included *[]App                `json:"included,omitempty"`
	Links    PagedDocumentLinks    `json:"links"`
	Meta     *PagingInformation    `json:"meta,omitempty"`
}

// BetaAppReviewDetail defines model for BetaAppReviewDetail.
type BetaAppReviewDetail struct {
	Attributes *struct {
		ContactEmail        *string `json:"contactEmail,omitempty"`
		ContactFirstName    *string `json:"contactFirstName,omitempty"`
		ContactLastName     *string `json:"contactLastName,omitempty"`
		ContactPhone        *string `json:"contactPhone,omitempty"`
		DemoAccountName     *string `json:"demoAccountName,omitempty"`
		DemoAccountPassword *string `json:"demoAccountPassword,omitempty"`
		DemoAccountRequired *bool   `json:"demoAccountRequired,omitempty"`
		Notes               *string `json:"notes,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaAppReviewDetailResponse defines model for BetaAppReviewDetailResponse.
type BetaAppReviewDetailResponse struct {
	Data     BetaAppReviewDetail `json:"data"`
	Included *[]App              `json:"included,omitempty"`
	Links    DocumentLinks       `json:"links"`
}

// BetaAppReviewDetailUpdateRequest defines model for BetaAppReviewDetailUpdateRequest.
type BetaAppReviewDetailUpdateRequest struct {
	Data struct {
		Attributes *struct {
			ContactEmail        *string `json:"contactEmail,omitempty"`
			ContactFirstName    *string `json:"contactFirstName,omitempty"`
			ContactLastName     *string `json:"contactLastName,omitempty"`
			ContactPhone        *string `json:"contactPhone,omitempty"`
			DemoAccountName     *string `json:"demoAccountName,omitempty"`
			DemoAccountPassword *string `json:"demoAccountPassword,omitempty"`
			DemoAccountRequired *bool   `json:"demoAccountRequired,omitempty"`
			Notes               *string `json:"notes,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaAppReviewDetailsResponse defines model for BetaAppReviewDetailsResponse.
type BetaAppReviewDetailsResponse struct {
	Data     []BetaAppReviewDetail `json:"data"`
	Included *[]App                `json:"included,omitempty"`
	Links    PagedDocumentLinks    `json:"links"`
	Meta     *PagingInformation    `json:"meta,omitempty"`
}

// BetaAppReviewSubmission defines model for BetaAppReviewSubmission.
type BetaAppReviewSubmission struct {
	Attributes *struct {
		BetaReviewState *BetaReviewState `json:"betaReviewState,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		Build *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"build,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaAppReviewSubmissionCreateRequest defines model for BetaAppReviewSubmissionCreateRequest.
type BetaAppReviewSubmissionCreateRequest struct {
	Data struct {
		Relationships struct {
			Build struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"build"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaAppReviewSubmissionResponse defines model for BetaAppReviewSubmissionResponse.
type BetaAppReviewSubmissionResponse struct {
	Data     BetaAppReviewSubmission `json:"data"`
	Included *[]Build                `json:"included,omitempty"`
	Links    DocumentLinks           `json:"links"`
}

// BetaAppReviewSubmissionsResponse defines model for BetaAppReviewSubmissionsResponse.
type BetaAppReviewSubmissionsResponse struct {
	Data     []BetaAppReviewSubmission `json:"data"`
	Included *[]Build                  `json:"included,omitempty"`
	Links    PagedDocumentLinks        `json:"links"`
	Meta     *PagingInformation        `json:"meta,omitempty"`
}

// BetaBuildLocalization defines model for BetaBuildLocalization.
type BetaBuildLocalization struct {
	Attributes *struct {
		Locale   *string `json:"locale,omitempty"`
		WhatsNew *string `json:"whatsNew,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		Build *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"build,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaBuildLocalizationCreateRequest defines model for BetaBuildLocalizationCreateRequest.
type BetaBuildLocalizationCreateRequest struct {
	Data struct {
		Attributes struct {
			Locale   string  `json:"locale"`
			WhatsNew *string `json:"whatsNew,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			Build struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"build"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaBuildLocalizationResponse defines model for BetaBuildLocalizationResponse.
type BetaBuildLocalizationResponse struct {
	Data     BetaBuildLocalization `json:"data"`
	Included *[]Build              `json:"included,omitempty"`
	Links    DocumentLinks         `json:"links"`
}

// BetaBuildLocalizationUpdateRequest defines model for BetaBuildLocalizationUpdateRequest.
type BetaBuildLocalizationUpdateRequest struct {
	Data struct {
		Attributes *struct {
			WhatsNew *string `json:"whatsNew,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaBuildLocalizationsResponse defines model for BetaBuildLocalizationsResponse.
type BetaBuildLocalizationsResponse struct {
	Data     []BetaBuildLocalization `json:"data"`
	Included *[]Build                `json:"included,omitempty"`
	Links    PagedDocumentLinks      `json:"links"`
	Meta     *PagingInformation      `json:"meta,omitempty"`
}

// BetaGroup defines model for BetaGroup.
type BetaGroup struct {
	Attributes *struct {
		CreatedDate            *time.Time `json:"createdDate,omitempty"`
		FeedbackEnabled        *bool      `json:"feedbackEnabled,omitempty"`
		IsInternalGroup        *bool      `json:"isInternalGroup,omitempty"`
		Name                   *string    `json:"name,omitempty"`
		PublicLink             *string    `json:"publicLink,omitempty"`
		PublicLinkEnabled      *bool      `json:"publicLinkEnabled,omitempty"`
		PublicLinkId           *string    `json:"publicLinkId,omitempty"`
		PublicLinkLimit        *int       `json:"publicLinkLimit,omitempty"`
		PublicLinkLimitEnabled *bool      `json:"publicLinkLimitEnabled,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		BetaTesters *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"betaTesters,omitempty"`
		Builds *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"builds,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaGroupBetaTestersLinkagesRequest defines model for BetaGroupBetaTestersLinkagesRequest.
type BetaGroupBetaTestersLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaGroupBetaTestersLinkagesResponse defines model for BetaGroupBetaTestersLinkagesResponse.
type BetaGroupBetaTestersLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BetaGroupBuildsLinkagesRequest defines model for BetaGroupBuildsLinkagesRequest.
type BetaGroupBuildsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaGroupBuildsLinkagesResponse defines model for BetaGroupBuildsLinkagesResponse.
type BetaGroupBuildsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BetaGroupCreateRequest defines model for BetaGroupCreateRequest.
type BetaGroupCreateRequest struct {
	Data struct {
		Attributes struct {
			FeedbackEnabled        *bool  `json:"feedbackEnabled,omitempty"`
			Name                   string `json:"name"`
			PublicLinkEnabled      *bool  `json:"publicLinkEnabled,omitempty"`
			PublicLinkLimit        *int   `json:"publicLinkLimit,omitempty"`
			PublicLinkLimitEnabled *bool  `json:"publicLinkLimitEnabled,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			App struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"app"`
			BetaTesters *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"betaTesters,omitempty"`
			Builds *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"builds,omitempty"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaGroupResponse defines model for BetaGroupResponse.
type BetaGroupResponse struct {
	Data     BetaGroup      `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// BetaGroupUpdateRequest defines model for BetaGroupUpdateRequest.
type BetaGroupUpdateRequest struct {
	Data struct {
		Attributes *struct {
			FeedbackEnabled        *bool   `json:"feedbackEnabled,omitempty"`
			Name                   *string `json:"name,omitempty"`
			PublicLinkEnabled      *bool   `json:"publicLinkEnabled,omitempty"`
			PublicLinkLimit        *int    `json:"publicLinkLimit,omitempty"`
			PublicLinkLimitEnabled *bool   `json:"publicLinkLimitEnabled,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaGroupsResponse defines model for BetaGroupsResponse.
type BetaGroupsResponse struct {
	Data     []BetaGroup        `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// BetaInviteType defines model for BetaInviteType.
type BetaInviteType string

// List of BetaInviteType
const (
	BetaInviteType_EMAIL       BetaInviteType = "EMAIL"
	BetaInviteType_PUBLIC_LINK BetaInviteType = "PUBLIC_LINK"
)

// BetaLicenseAgreement defines model for BetaLicenseAgreement.
type BetaLicenseAgreement struct {
	Attributes *struct {
		AgreementText *string `json:"agreementText,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaLicenseAgreementResponse defines model for BetaLicenseAgreementResponse.
type BetaLicenseAgreementResponse struct {
	Data     BetaLicenseAgreement `json:"data"`
	Included *[]App               `json:"included,omitempty"`
	Links    DocumentLinks        `json:"links"`
}

// BetaLicenseAgreementUpdateRequest defines model for BetaLicenseAgreementUpdateRequest.
type BetaLicenseAgreementUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AgreementText *string `json:"agreementText,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaLicenseAgreementsResponse defines model for BetaLicenseAgreementsResponse.
type BetaLicenseAgreementsResponse struct {
	Data     []BetaLicenseAgreement `json:"data"`
	Included *[]App                 `json:"included,omitempty"`
	Links    PagedDocumentLinks     `json:"links"`
	Meta     *PagingInformation     `json:"meta,omitempty"`
}

// BetaReviewState defines model for BetaReviewState.
type BetaReviewState string

// List of BetaReviewState
const (
	BetaReviewState_APPROVED           BetaReviewState = "APPROVED"
	BetaReviewState_IN_REVIEW          BetaReviewState = "IN_REVIEW"
	BetaReviewState_REJECTED           BetaReviewState = "REJECTED"
	BetaReviewState_WAITING_FOR_REVIEW BetaReviewState = "WAITING_FOR_REVIEW"
)

// BetaTester defines model for BetaTester.
type BetaTester struct {
	Attributes *struct {
		Email      *openapi_types.Email `json:"email,omitempty"`
		FirstName  *string              `json:"firstName,omitempty"`
		InviteType *BetaInviteType      `json:"inviteType,omitempty"`
		LastName   *string              `json:"lastName,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		Apps *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"apps,omitempty"`
		BetaGroups *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"betaGroups,omitempty"`
		Builds *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"builds,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BetaTesterAppsLinkagesRequest defines model for BetaTesterAppsLinkagesRequest.
type BetaTesterAppsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaTesterAppsLinkagesResponse defines model for BetaTesterAppsLinkagesResponse.
type BetaTesterAppsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BetaTesterBetaGroupsLinkagesRequest defines model for BetaTesterBetaGroupsLinkagesRequest.
type BetaTesterBetaGroupsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaTesterBetaGroupsLinkagesResponse defines model for BetaTesterBetaGroupsLinkagesResponse.
type BetaTesterBetaGroupsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BetaTesterBuildsLinkagesRequest defines model for BetaTesterBuildsLinkagesRequest.
type BetaTesterBuildsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaTesterBuildsLinkagesResponse defines model for BetaTesterBuildsLinkagesResponse.
type BetaTesterBuildsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BetaTesterCreateRequest defines model for BetaTesterCreateRequest.
type BetaTesterCreateRequest struct {
	Data struct {
		Attributes struct {
			Email     openapi_types.Email `json:"email"`
			FirstName *string             `json:"firstName,omitempty"`
			LastName  *string             `json:"lastName,omitempty"`
		} `json:"attributes"`
		Relationships *struct {
			BetaGroups *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"betaGroups,omitempty"`
			Builds *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"builds,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaTesterInvitation defines model for BetaTesterInvitation.
type BetaTesterInvitation struct {
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// BetaTesterInvitationCreateRequest defines model for BetaTesterInvitationCreateRequest.
type BetaTesterInvitationCreateRequest struct {
	Data struct {
		Relationships struct {
			App struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"app"`
			BetaTester struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"betaTester"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BetaTesterInvitationResponse defines model for BetaTesterInvitationResponse.
type BetaTesterInvitationResponse struct {
	Data  BetaTesterInvitation `json:"data"`
	Links DocumentLinks        `json:"links"`
}

// BetaTesterResponse defines model for BetaTesterResponse.
type BetaTesterResponse struct {
	Data     BetaTester     `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// BetaTestersResponse defines model for BetaTestersResponse.
type BetaTestersResponse struct {
	Data     []BetaTester       `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// BrazilAgeRating defines model for BrazilAgeRating.
type BrazilAgeRating string

// List of BrazilAgeRating
const (
	BrazilAgeRating_EIGHTEEN BrazilAgeRating = "EIGHTEEN"
	BrazilAgeRating_FOURTEEN BrazilAgeRating = "FOURTEEN"
	BrazilAgeRating_L        BrazilAgeRating = "L"
	BrazilAgeRating_SIXTEEN  BrazilAgeRating = "SIXTEEN"
	BrazilAgeRating_TEN      BrazilAgeRating = "TEN"
	BrazilAgeRating_TWELVE   BrazilAgeRating = "TWELVE"
)

// Build defines model for Build.
type Build struct {
	Attributes *struct {
		ExpirationDate          *time.Time  `json:"expirationDate,omitempty"`
		Expired                 *bool       `json:"expired,omitempty"`
		IconAssetToken          *ImageAsset `json:"iconAssetToken,omitempty"`
		MinOsVersion            *string     `json:"minOsVersion,omitempty"`
		ProcessingState         *string     `json:"processingState,omitempty"`
		UploadedDate            *time.Time  `json:"uploadedDate,omitempty"`
		UsesNonExemptEncryption *bool       `json:"usesNonExemptEncryption,omitempty"`
		Version                 *string     `json:"version,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		AppEncryptionDeclaration *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appEncryptionDeclaration,omitempty"`
		AppStoreVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersion,omitempty"`
		BetaAppReviewSubmission *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"betaAppReviewSubmission,omitempty"`
		BetaBuildLocalizations *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"betaBuildLocalizations,omitempty"`
		BuildBetaDetail *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"buildBetaDetail,omitempty"`
		Icons *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"icons,omitempty"`
		IndividualTesters *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"individualTesters,omitempty"`
		PreReleaseVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"preReleaseVersion,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BuildAppEncryptionDeclarationLinkageRequest defines model for BuildAppEncryptionDeclarationLinkageRequest.
type BuildAppEncryptionDeclarationLinkageRequest struct {
	Data struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BuildAppEncryptionDeclarationLinkageResponse defines model for BuildAppEncryptionDeclarationLinkageResponse.
type BuildAppEncryptionDeclarationLinkageResponse struct {
	Data struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links DocumentLinks `json:"links"`
}

// BuildBetaDetail defines model for BuildBetaDetail.
type BuildBetaDetail struct {
	Attributes *struct {
		AutoNotifyEnabled  *bool              `json:"autoNotifyEnabled,omitempty"`
		ExternalBuildState *ExternalBetaState `json:"externalBuildState,omitempty"`
		InternalBuildState *InternalBetaState `json:"internalBuildState,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		Build *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"build,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BuildBetaDetailResponse defines model for BuildBetaDetailResponse.
type BuildBetaDetailResponse struct {
	Data     BuildBetaDetail `json:"data"`
	Included *[]Build        `json:"included,omitempty"`
	Links    DocumentLinks   `json:"links"`
}

// BuildBetaDetailUpdateRequest defines model for BuildBetaDetailUpdateRequest.
type BuildBetaDetailUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AutoNotifyEnabled *bool `json:"autoNotifyEnabled,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BuildBetaDetailsResponse defines model for BuildBetaDetailsResponse.
type BuildBetaDetailsResponse struct {
	Data     []BuildBetaDetail  `json:"data"`
	Included *[]Build           `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// BuildBetaGroupsLinkagesRequest defines model for BuildBetaGroupsLinkagesRequest.
type BuildBetaGroupsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BuildBetaNotification defines model for BuildBetaNotification.
type BuildBetaNotification struct {
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// BuildBetaNotificationCreateRequest defines model for BuildBetaNotificationCreateRequest.
type BuildBetaNotificationCreateRequest struct {
	Data struct {
		Relationships struct {
			Build struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"build"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BuildBetaNotificationResponse defines model for BuildBetaNotificationResponse.
type BuildBetaNotificationResponse struct {
	Data  BuildBetaNotification `json:"data"`
	Links DocumentLinks         `json:"links"`
}

// BuildIcon defines model for BuildIcon.
type BuildIcon struct {
	Attributes *struct {
		IconAsset *ImageAsset    `json:"iconAsset,omitempty"`
		IconType  *IconAssetType `json:"iconType,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// BuildIconsResponse defines model for BuildIconsResponse.
type BuildIconsResponse struct {
	Data  []BuildIcon        `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BuildIndividualTestersLinkagesRequest defines model for BuildIndividualTestersLinkagesRequest.
type BuildIndividualTestersLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BuildIndividualTestersLinkagesResponse defines model for BuildIndividualTestersLinkagesResponse.
type BuildIndividualTestersLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// BuildResponse defines model for BuildResponse.
type BuildResponse struct {
	Data     Build          `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// BuildUpdateRequest defines model for BuildUpdateRequest.
type BuildUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Expired                 *bool `json:"expired,omitempty"`
			UsesNonExemptEncryption *bool `json:"usesNonExemptEncryption,omitempty"`
		} `json:"attributes,omitempty"`
		Id            string `json:"id"`
		Relationships *struct {
			AppEncryptionDeclaration *struct {
				Data *struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"appEncryptionDeclaration,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// BuildsResponse defines model for BuildsResponse.
type BuildsResponse struct {
	Data     []Build            `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// BundleId defines model for BundleId.
type BundleId struct {
	Attributes *struct {
		Identifier *string           `json:"identifier,omitempty"`
		Name       *string           `json:"name,omitempty"`
		Platform   *BundleIdPlatform `json:"platform,omitempty"`
		SeedId     *string           `json:"seedId,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		BundleIdCapabilities *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"bundleIdCapabilities,omitempty"`
		Profiles *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"profiles,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// BundleIdCapabilitiesResponse defines model for BundleIdCapabilitiesResponse.
type BundleIdCapabilitiesResponse struct {
	Data  []BundleIdCapability `json:"data"`
	Links PagedDocumentLinks   `json:"links"`
	Meta  *PagingInformation   `json:"meta,omitempty"`
}

// BundleIdCapability defines model for BundleIdCapability.
type BundleIdCapability struct {
	Attributes *struct {
		CapabilityType *CapabilityType      `json:"capabilityType,omitempty"`
		Settings       *[]CapabilitySetting `json:"settings,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// BundleIdCapabilityCreateRequest defines model for BundleIdCapabilityCreateRequest.
type BundleIdCapabilityCreateRequest struct {
	Data struct {
		Attributes struct {
			CapabilityType CapabilityType       `json:"capabilityType"`
			Settings       *[]CapabilitySetting `json:"settings,omitempty"`
		} `json:"attributes"`
		Relationships struct {
			BundleId struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"bundleId"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// BundleIdCapabilityResponse defines model for BundleIdCapabilityResponse.
type BundleIdCapabilityResponse struct {
	Data  BundleIdCapability `json:"data"`
	Links DocumentLinks      `json:"links"`
}

// BundleIdCapabilityUpdateRequest defines model for BundleIdCapabilityUpdateRequest.
type BundleIdCapabilityUpdateRequest struct {
	Data struct {
		Attributes *struct {
			CapabilityType *CapabilityType      `json:"capabilityType,omitempty"`
			Settings       *[]CapabilitySetting `json:"settings,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BundleIdCreateRequest defines model for BundleIdCreateRequest.
type BundleIdCreateRequest struct {
	Data struct {
		Attributes struct {
			Identifier string           `json:"identifier"`
			Name       string           `json:"name"`
			Platform   BundleIdPlatform `json:"platform"`
			SeedId     *string          `json:"seedId,omitempty"`
		} `json:"attributes"`
		Type string `json:"type"`
	} `json:"data"`
}

// BundleIdPlatform defines model for BundleIdPlatform.
type BundleIdPlatform string

// List of BundleIdPlatform
const (
	BundleIdPlatform_IOS    BundleIdPlatform = "IOS"
	BundleIdPlatform_MAC_OS BundleIdPlatform = "MAC_OS"
)

// BundleIdResponse defines model for BundleIdResponse.
type BundleIdResponse struct {
	Data     BundleId       `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// BundleIdUpdateRequest defines model for BundleIdUpdateRequest.
type BundleIdUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Name *string `json:"name,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// BundleIdsResponse defines model for BundleIdsResponse.
type BundleIdsResponse struct {
	Data     []BundleId         `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// CapabilityOption defines model for CapabilityOption.
type CapabilityOption struct {
	Description      *string `json:"description,omitempty"`
	Enabled          *bool   `json:"enabled,omitempty"`
	EnabledByDefault *bool   `json:"enabledByDefault,omitempty"`
	Key              *string `json:"key,omitempty"`
	Name             *string `json:"name,omitempty"`
	SupportsWildcard *bool   `json:"supportsWildcard,omitempty"`
}

// CapabilitySetting defines model for CapabilitySetting.
type CapabilitySetting struct {
	AllowedInstances *string             `json:"allowedInstances,omitempty"`
	Description      *string             `json:"description,omitempty"`
	EnabledByDefault *bool               `json:"enabledByDefault,omitempty"`
	Key              *string             `json:"key,omitempty"`
	MinInstances     *int                `json:"minInstances,omitempty"`
	Name             *string             `json:"name,omitempty"`
	Options          *[]CapabilityOption `json:"options,omitempty"`
	Visible          *bool               `json:"visible,omitempty"`
}

// CapabilityType defines model for CapabilityType.
type CapabilityType string

// List of CapabilityType
const (
	CapabilityType_ACCESS_WIFI_INFORMATION          CapabilityType = "ACCESS_WIFI_INFORMATION"
	CapabilityType_APPLE_ID_AUTH                    CapabilityType = "APPLE_ID_AUTH"
	CapabilityType_APPLE_PAY                        CapabilityType = "APPLE_PAY"
	CapabilityType_APP_GROUPS                       CapabilityType = "APP_GROUPS"
	CapabilityType_ASSOCIATED_DOMAINS               CapabilityType = "ASSOCIATED_DOMAINS"
	CapabilityType_AUTOFILL_CREDENTIAL_PROVIDER     CapabilityType = "AUTOFILL_CREDENTIAL_PROVIDER"
	CapabilityType_CLASSKIT                         CapabilityType = "CLASSKIT"
	CapabilityType_COREMEDIA_HLS_LOW_LATENCY        CapabilityType = "COREMEDIA_HLS_LOW_LATENCY"
	CapabilityType_DATA_PROTECTION                  CapabilityType = "DATA_PROTECTION"
	CapabilityType_GAME_CENTER                      CapabilityType = "GAME_CENTER"
	CapabilityType_HEALTHKIT                        CapabilityType = "HEALTHKIT"
	CapabilityType_HOMEKIT                          CapabilityType = "HOMEKIT"
	CapabilityType_HOT_SPOT                         CapabilityType = "HOT_SPOT"
	CapabilityType_ICLOUD                           CapabilityType = "ICLOUD"
	CapabilityType_INTER_APP_AUDIO                  CapabilityType = "INTER_APP_AUDIO"
	CapabilityType_IN_APP_PURCHASE                  CapabilityType = "IN_APP_PURCHASE"
	CapabilityType_MAPS                             CapabilityType = "MAPS"
	CapabilityType_MULTIPATH                        CapabilityType = "MULTIPATH"
	CapabilityType_NETWORK_CUSTOM_PROTOCOL          CapabilityType = "NETWORK_CUSTOM_PROTOCOL"
	CapabilityType_NETWORK_EXTENSIONS               CapabilityType = "NETWORK_EXTENSIONS"
	CapabilityType_NFC_TAG_READING                  CapabilityType = "NFC_TAG_READING"
	CapabilityType_PERSONAL_VPN                     CapabilityType = "PERSONAL_VPN"
	CapabilityType_PUSH_NOTIFICATIONS               CapabilityType = "PUSH_NOTIFICATIONS"
	CapabilityType_SIRIKIT                          CapabilityType = "SIRIKIT"
	CapabilityType_SYSTEM_EXTENSION_INSTALL         CapabilityType = "SYSTEM_EXTENSION_INSTALL"
	CapabilityType_USER_MANAGEMENT                  CapabilityType = "USER_MANAGEMENT"
	CapabilityType_WALLET                           CapabilityType = "WALLET"
	CapabilityType_WIRELESS_ACCESSORY_CONFIGURATION CapabilityType = "WIRELESS_ACCESSORY_CONFIGURATION"
)

// Certificate defines model for Certificate.
type Certificate struct {
	Attributes *struct {
		CertificateContent *string           `json:"certificateContent,omitempty"`
		CertificateType    *CertificateType  `json:"certificateType,omitempty"`
		DisplayName        *string           `json:"displayName,omitempty"`
		ExpirationDate     *time.Time        `json:"expirationDate,omitempty"`
		Name               *string           `json:"name,omitempty"`
		Platform           *BundleIdPlatform `json:"platform,omitempty"`
		SerialNumber       *string           `json:"serialNumber,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// CertificateCreateRequest defines model for CertificateCreateRequest.
type CertificateCreateRequest struct {
	Data struct {
		Attributes struct {
			CertificateType CertificateType `json:"certificateType"`
			CsrContent      string          `json:"csrContent"`
		} `json:"attributes"`
		Type string `json:"type"`
	} `json:"data"`
}

// CertificateResponse defines model for CertificateResponse.
type CertificateResponse struct {
	Data  Certificate   `json:"data"`
	Links DocumentLinks `json:"links"`
}

// CertificateType defines model for CertificateType.
type CertificateType string

// List of CertificateType
const (
	CertificateType_DEVELOPER_ID_APPLICATION   CertificateType = "DEVELOPER_ID_APPLICATION"
	CertificateType_DEVELOPER_ID_KEXT          CertificateType = "DEVELOPER_ID_KEXT"
	CertificateType_DEVELOPMENT                CertificateType = "DEVELOPMENT"
	CertificateType_DISTRIBUTION               CertificateType = "DISTRIBUTION"
	CertificateType_IOS_DEVELOPMENT            CertificateType = "IOS_DEVELOPMENT"
	CertificateType_IOS_DISTRIBUTION           CertificateType = "IOS_DISTRIBUTION"
	CertificateType_MAC_APP_DEVELOPMENT        CertificateType = "MAC_APP_DEVELOPMENT"
	CertificateType_MAC_APP_DISTRIBUTION       CertificateType = "MAC_APP_DISTRIBUTION"
	CertificateType_MAC_INSTALLER_DISTRIBUTION CertificateType = "MAC_INSTALLER_DISTRIBUTION"
)

// CertificatesResponse defines model for CertificatesResponse.
type CertificatesResponse struct {
	Data  []Certificate      `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// Device defines model for Device.
type Device struct {
	Attributes *struct {
		AddedDate   *time.Time        `json:"addedDate,omitempty"`
		DeviceClass *string           `json:"deviceClass,omitempty"`
		Model       *string           `json:"model,omitempty"`
		Name        *string           `json:"name,omitempty"`
		Platform    *BundleIdPlatform `json:"platform,omitempty"`
		Status      *string           `json:"status,omitempty"`
		Udid        *string           `json:"udid,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// DeviceCreateRequest defines model for DeviceCreateRequest.
type DeviceCreateRequest struct {
	Data struct {
		Attributes struct {
			Name     string           `json:"name"`
			Platform BundleIdPlatform `json:"platform"`
			Udid     string           `json:"udid"`
		} `json:"attributes"`
		Type string `json:"type"`
	} `json:"data"`
}

// DeviceResponse defines model for DeviceResponse.
type DeviceResponse struct {
	Data  Device        `json:"data"`
	Links DocumentLinks `json:"links"`
}

// DeviceUpdateRequest defines model for DeviceUpdateRequest.
type DeviceUpdateRequest struct {
	Data struct {
		Attributes *struct {
			Name   *string `json:"name,omitempty"`
			Status *string `json:"status,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// DevicesResponse defines model for DevicesResponse.
type DevicesResponse struct {
	Data  []Device           `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// DiagnosticLog defines model for DiagnosticLog.
type DiagnosticLog struct {
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// DiagnosticLogsResponse defines model for DiagnosticLogsResponse.
type DiagnosticLogsResponse struct {
	Data  []DiagnosticLog    `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// DiagnosticSignature defines model for DiagnosticSignature.
type DiagnosticSignature struct {
	Attributes *struct {
		DiagnosticType *string  `json:"diagnosticType,omitempty"`
		Signature      *string  `json:"signature,omitempty"`
		Weight         *float32 `json:"weight,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// DiagnosticSignaturesResponse defines model for DiagnosticSignaturesResponse.
type DiagnosticSignaturesResponse struct {
	Data     []DiagnosticSignature `json:"data"`
	Included *[]DiagnosticLog      `json:"included,omitempty"`
	Links    PagedDocumentLinks    `json:"links"`
	Meta     *PagingInformation    `json:"meta,omitempty"`
}

// DocumentLinks defines model for DocumentLinks.
type DocumentLinks struct {
	Self string `json:"self"`
}

// EndUserLicenseAgreement defines model for EndUserLicenseAgreement.
type EndUserLicenseAgreement struct {
	Attributes *struct {
		AgreementText *string `json:"agreementText,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		Territories *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"territories,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// EndUserLicenseAgreementCreateRequest defines model for EndUserLicenseAgreementCreateRequest.
type EndUserLicenseAgreementCreateRequest struct {
	Data struct {
		Attributes struct {
			AgreementText string `json:"agreementText"`
		} `json:"attributes"`
		Relationships struct {
			App struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"app"`
			Territories struct {
				Data []struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"territories"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// EndUserLicenseAgreementResponse defines model for EndUserLicenseAgreementResponse.
type EndUserLicenseAgreementResponse struct {
	Data     EndUserLicenseAgreement `json:"data"`
	Included *[]Territory            `json:"included,omitempty"`
	Links    DocumentLinks           `json:"links"`
}

// EndUserLicenseAgreementUpdateRequest defines model for EndUserLicenseAgreementUpdateRequest.
type EndUserLicenseAgreementUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AgreementText *string `json:"agreementText,omitempty"`
		} `json:"attributes,omitempty"`
		Id            string `json:"id"`
		Relationships *struct {
			Territories *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"territories,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Errors *[]struct {
		Code   string       `json:"code"`
		Detail string       `json:"detail"`
		Id     *string      `json:"id,omitempty"`
		Source *interface{} `json:"source,omitempty"`
		Status string       `json:"status"`
		Title  string       `json:"title"`
	} `json:"errors,omitempty"`
}

// ExternalBetaState defines model for ExternalBetaState.
type ExternalBetaState string

// List of ExternalBetaState
const (
	ExternalBetaState_BETA_APPROVED               ExternalBetaState = "BETA_APPROVED"
	ExternalBetaState_BETA_REJECTED               ExternalBetaState = "BETA_REJECTED"
	ExternalBetaState_EXPIRED                     ExternalBetaState = "EXPIRED"
	ExternalBetaState_IN_BETA_REVIEW              ExternalBetaState = "IN_BETA_REVIEW"
	ExternalBetaState_IN_BETA_TESTING             ExternalBetaState = "IN_BETA_TESTING"
	ExternalBetaState_IN_EXPORT_COMPLIANCE_REVIEW ExternalBetaState = "IN_EXPORT_COMPLIANCE_REVIEW"
	ExternalBetaState_MISSING_EXPORT_COMPLIANCE   ExternalBetaState = "MISSING_EXPORT_COMPLIANCE"
	ExternalBetaState_PROCESSING                  ExternalBetaState = "PROCESSING"
	ExternalBetaState_PROCESSING_EXCEPTION        ExternalBetaState = "PROCESSING_EXCEPTION"
	ExternalBetaState_READY_FOR_BETA_SUBMISSION   ExternalBetaState = "READY_FOR_BETA_SUBMISSION"
	ExternalBetaState_READY_FOR_BETA_TESTING      ExternalBetaState = "READY_FOR_BETA_TESTING"
	ExternalBetaState_WAITING_FOR_BETA_REVIEW     ExternalBetaState = "WAITING_FOR_BETA_REVIEW"
)

// GameCenterEnabledVersion defines model for GameCenterEnabledVersion.
type GameCenterEnabledVersion struct {
	Attributes *struct {
		IconAsset     *ImageAsset `json:"iconAsset,omitempty"`
		Platform      *Platform   `json:"platform,omitempty"`
		VersionString *string     `json:"versionString,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		CompatibleVersions *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"compatibleVersions,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// GameCenterEnabledVersionCompatibleVersionsLinkagesRequest defines model for GameCenterEnabledVersionCompatibleVersionsLinkagesRequest.
type GameCenterEnabledVersionCompatibleVersionsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// GameCenterEnabledVersionCompatibleVersionsLinkagesResponse defines model for GameCenterEnabledVersionCompatibleVersionsLinkagesResponse.
type GameCenterEnabledVersionCompatibleVersionsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// GameCenterEnabledVersionsResponse defines model for GameCenterEnabledVersionsResponse.
type GameCenterEnabledVersionsResponse struct {
	Data     []GameCenterEnabledVersion  `json:"data"`
	Included *[]GameCenterEnabledVersion `json:"included,omitempty"`
	Links    PagedDocumentLinks          `json:"links"`
	Meta     *PagingInformation          `json:"meta,omitempty"`
}

// IconAssetType defines model for IconAssetType.
type IconAssetType string

// List of IconAssetType
const (
	IconAssetType_APP_STORE          IconAssetType = "APP_STORE"
	IconAssetType_MESSAGES_APP_STORE IconAssetType = "MESSAGES_APP_STORE"
	IconAssetType_TV_OS_HOME_SCREEN  IconAssetType = "TV_OS_HOME_SCREEN"
	IconAssetType_TV_OS_TOP_SHELF    IconAssetType = "TV_OS_TOP_SHELF"
	IconAssetType_WATCH_APP_STORE    IconAssetType = "WATCH_APP_STORE"
)

// IdfaDeclaration defines model for IdfaDeclaration.
type IdfaDeclaration struct {
	Attributes *struct {
		AttributesActionWithPreviousAd        *bool `json:"attributesActionWithPreviousAd,omitempty"`
		AttributesAppInstallationToPreviousAd *bool `json:"attributesAppInstallationToPreviousAd,omitempty"`
		HonorsLimitedAdTracking               *bool `json:"honorsLimitedAdTracking,omitempty"`
		ServesAds                             *bool `json:"servesAds,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppStoreVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersion,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// IdfaDeclarationCreateRequest defines model for IdfaDeclarationCreateRequest.
type IdfaDeclarationCreateRequest struct {
	Data struct {
		Attributes struct {
			AttributesActionWithPreviousAd        bool `json:"attributesActionWithPreviousAd"`
			AttributesAppInstallationToPreviousAd bool `json:"attributesAppInstallationToPreviousAd"`
			HonorsLimitedAdTracking               bool `json:"honorsLimitedAdTracking"`
			ServesAds                             bool `json:"servesAds"`
		} `json:"attributes"`
		Relationships struct {
			AppStoreVersion struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersion"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// IdfaDeclarationResponse defines model for IdfaDeclarationResponse.
type IdfaDeclarationResponse struct {
	Data  IdfaDeclaration `json:"data"`
	Links DocumentLinks   `json:"links"`
}

// IdfaDeclarationUpdateRequest defines model for IdfaDeclarationUpdateRequest.
type IdfaDeclarationUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AttributesActionWithPreviousAd        *bool `json:"attributesActionWithPreviousAd,omitempty"`
			AttributesAppInstallationToPreviousAd *bool `json:"attributesAppInstallationToPreviousAd,omitempty"`
			HonorsLimitedAdTracking               *bool `json:"honorsLimitedAdTracking,omitempty"`
			ServesAds                             *bool `json:"servesAds,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// ImageAsset defines model for ImageAsset.
type ImageAsset struct {
	Height      *int    `json:"height,omitempty"`
	TemplateUrl *string `json:"templateUrl,omitempty"`
	Width       *int    `json:"width,omitempty"`
}

// InAppPurchase defines model for InAppPurchase.
type InAppPurchase struct {
	Attributes *struct {
		InAppPurchaseType *string `json:"inAppPurchaseType,omitempty"`
		ProductId         *string `json:"productId,omitempty"`
		ReferenceName     *string `json:"referenceName,omitempty"`
		State             *string `json:"state,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		Apps *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"apps,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// InAppPurchaseResponse defines model for InAppPurchaseResponse.
type InAppPurchaseResponse struct {
	Data  InAppPurchase `json:"data"`
	Links DocumentLinks `json:"links"`
}

// InAppPurchasesResponse defines model for InAppPurchasesResponse.
type InAppPurchasesResponse struct {
	Data  []InAppPurchase    `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// InternalBetaState defines model for InternalBetaState.
type InternalBetaState string

// List of InternalBetaState
const (
	InternalBetaState_EXPIRED                     InternalBetaState = "EXPIRED"
	InternalBetaState_IN_BETA_TESTING             InternalBetaState = "IN_BETA_TESTING"
	InternalBetaState_IN_EXPORT_COMPLIANCE_REVIEW InternalBetaState = "IN_EXPORT_COMPLIANCE_REVIEW"
	InternalBetaState_MISSING_EXPORT_COMPLIANCE   InternalBetaState = "MISSING_EXPORT_COMPLIANCE"
	InternalBetaState_PROCESSING                  InternalBetaState = "PROCESSING"
	InternalBetaState_PROCESSING_EXCEPTION        InternalBetaState = "PROCESSING_EXCEPTION"
	InternalBetaState_READY_FOR_BETA_TESTING      InternalBetaState = "READY_FOR_BETA_TESTING"
)

// KidsAgeBand defines model for KidsAgeBand.
type KidsAgeBand string

// List of KidsAgeBand
const (
	KidsAgeBand_FIVE_AND_UNDER KidsAgeBand = "FIVE_AND_UNDER"
	KidsAgeBand_NINE_TO_ELEVEN KidsAgeBand = "NINE_TO_ELEVEN"
	KidsAgeBand_SIX_TO_EIGHT   KidsAgeBand = "SIX_TO_EIGHT"
)

// PagedDocumentLinks defines model for PagedDocumentLinks.
type PagedDocumentLinks struct {
	First *string `json:"first,omitempty"`
	Next  *string `json:"next,omitempty"`
	Self  string  `json:"self"`
}

// PagingInformation defines model for PagingInformation.
type PagingInformation struct {
	Paging struct {
		Limit int `json:"limit"`
		Total int `json:"total"`
	} `json:"paging"`
}

// PerfPowerMetric defines model for PerfPowerMetric.
type PerfPowerMetric struct {
	Attributes *struct {
		DeviceType *string `json:"deviceType,omitempty"`
		MetricType *string `json:"metricType,omitempty"`
		Platform   *string `json:"platform,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// PerfPowerMetricsResponse defines model for PerfPowerMetricsResponse.
type PerfPowerMetricsResponse struct {
	Data  []PerfPowerMetric  `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// PhasedReleaseState defines model for PhasedReleaseState.
type PhasedReleaseState string

// List of PhasedReleaseState
const (
	PhasedReleaseState_ACTIVE   PhasedReleaseState = "ACTIVE"
	PhasedReleaseState_COMPLETE PhasedReleaseState = "COMPLETE"
	PhasedReleaseState_INACTIVE PhasedReleaseState = "INACTIVE"
	PhasedReleaseState_PAUSED   PhasedReleaseState = "PAUSED"
)

// Platform defines model for Platform.
type Platform string

// List of Platform
const (
	Platform_IOS    Platform = "IOS"
	Platform_MAC_OS Platform = "MAC_OS"
	Platform_TV_OS  Platform = "TV_OS"
)

// PreReleaseVersionsResponse defines model for PreReleaseVersionsResponse.
type PreReleaseVersionsResponse struct {
	Data     []PrereleaseVersion `json:"data"`
	Included *[]interface{}      `json:"included,omitempty"`
	Links    PagedDocumentLinks  `json:"links"`
	Meta     *PagingInformation  `json:"meta,omitempty"`
}

// PrereleaseVersion defines model for PrereleaseVersion.
type PrereleaseVersion struct {
	Attributes *struct {
		Platform *Platform `json:"platform,omitempty"`
		Version  *string   `json:"version,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		App *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"app,omitempty"`
		Builds *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"builds,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// PrereleaseVersionResponse defines model for PrereleaseVersionResponse.
type PrereleaseVersionResponse struct {
	Data     PrereleaseVersion `json:"data"`
	Included *[]interface{}    `json:"included,omitempty"`
	Links    DocumentLinks     `json:"links"`
}

// PreviewType defines model for PreviewType.
type PreviewType string

// List of PreviewType
const (
	PreviewType_APPLE_TV          PreviewType = "APPLE_TV"
	PreviewType_DESKTOP           PreviewType = "DESKTOP"
	PreviewType_IPAD_105          PreviewType = "IPAD_105"
	PreviewType_IPAD_97           PreviewType = "IPAD_97"
	PreviewType_IPAD_PRO_129      PreviewType = "IPAD_PRO_129"
	PreviewType_IPAD_PRO_3GEN_11  PreviewType = "IPAD_PRO_3GEN_11"
	PreviewType_IPAD_PRO_3GEN_129 PreviewType = "IPAD_PRO_3GEN_129"
	PreviewType_IPHONE_35         PreviewType = "IPHONE_35"
	PreviewType_IPHONE_40         PreviewType = "IPHONE_40"
	PreviewType_IPHONE_47         PreviewType = "IPHONE_47"
	PreviewType_IPHONE_55         PreviewType = "IPHONE_55"
	PreviewType_IPHONE_58         PreviewType = "IPHONE_58"
	PreviewType_IPHONE_65         PreviewType = "IPHONE_65"
	PreviewType_WATCH_SERIES_3    PreviewType = "WATCH_SERIES_3"
	PreviewType_WATCH_SERIES_4    PreviewType = "WATCH_SERIES_4"
)

// Profile defines model for Profile.
type Profile struct {
	Attributes *struct {
		CreatedDate    *time.Time        `json:"createdDate,omitempty"`
		ExpirationDate *time.Time        `json:"expirationDate,omitempty"`
		Name           *string           `json:"name,omitempty"`
		Platform       *BundleIdPlatform `json:"platform,omitempty"`
		ProfileContent *string           `json:"profileContent,omitempty"`
		ProfileState   *string           `json:"profileState,omitempty"`
		ProfileType    *string           `json:"profileType,omitempty"`
		Uuid           *string           `json:"uuid,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		BundleId *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"bundleId,omitempty"`
		Certificates *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"certificates,omitempty"`
		Devices *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"devices,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// ProfileCreateRequest defines model for ProfileCreateRequest.
type ProfileCreateRequest struct {
	Data struct {
		Attributes struct {
			Name        string `json:"name"`
			ProfileType string `json:"profileType"`
		} `json:"attributes"`
		Relationships struct {
			BundleId struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"bundleId"`
			Certificates struct {
				Data []struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"certificates"`
			Devices *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"devices,omitempty"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// ProfileResponse defines model for ProfileResponse.
type ProfileResponse struct {
	Data     Profile        `json:"data"`
	Included *[]interface{} `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// ProfilesResponse defines model for ProfilesResponse.
type ProfilesResponse struct {
	Data     []Profile          `json:"data"`
	Included *[]interface{}     `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// ResourceLinks defines model for ResourceLinks.
type ResourceLinks struct {
	Self string `json:"self"`
}

// RoutingAppCoverage defines model for RoutingAppCoverage.
type RoutingAppCoverage struct {
	Attributes *struct {
		AssetDeliveryState *AppMediaAssetState `json:"assetDeliveryState,omitempty"`
		FileName           *string             `json:"fileName,omitempty"`
		FileSize           *int                `json:"fileSize,omitempty"`
		SourceFileChecksum *string             `json:"sourceFileChecksum,omitempty"`
		UploadOperations   *[]UploadOperation  `json:"uploadOperations,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		AppStoreVersion *struct {
			Data *struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
		} `json:"appStoreVersion,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// RoutingAppCoverageCreateRequest defines model for RoutingAppCoverageCreateRequest.
type RoutingAppCoverageCreateRequest struct {
	Data struct {
		Attributes struct {
			FileName string `json:"fileName"`
			FileSize int    `json:"fileSize"`
		} `json:"attributes"`
		Relationships struct {
			AppStoreVersion struct {
				Data struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data"`
			} `json:"appStoreVersion"`
		} `json:"relationships"`
		Type string `json:"type"`
	} `json:"data"`
}

// RoutingAppCoverageResponse defines model for RoutingAppCoverageResponse.
type RoutingAppCoverageResponse struct {
	Data  RoutingAppCoverage `json:"data"`
	Links DocumentLinks      `json:"links"`
}

// RoutingAppCoverageUpdateRequest defines model for RoutingAppCoverageUpdateRequest.
type RoutingAppCoverageUpdateRequest struct {
	Data struct {
		Attributes *struct {
			SourceFileChecksum *string `json:"sourceFileChecksum,omitempty"`
			Uploaded           *bool   `json:"uploaded,omitempty"`
		} `json:"attributes,omitempty"`
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// ScreenshotDisplayType defines model for ScreenshotDisplayType.
type ScreenshotDisplayType string

// List of ScreenshotDisplayType
const (
	ScreenshotDisplayType_APP_APPLE_TV                   ScreenshotDisplayType = "APP_APPLE_TV"
	ScreenshotDisplayType_APP_DESKTOP                    ScreenshotDisplayType = "APP_DESKTOP"
	ScreenshotDisplayType_APP_IPAD_105                   ScreenshotDisplayType = "APP_IPAD_105"
	ScreenshotDisplayType_APP_IPAD_97                    ScreenshotDisplayType = "APP_IPAD_97"
	ScreenshotDisplayType_APP_IPAD_PRO_129               ScreenshotDisplayType = "APP_IPAD_PRO_129"
	ScreenshotDisplayType_APP_IPAD_PRO_3GEN_11           ScreenshotDisplayType = "APP_IPAD_PRO_3GEN_11"
	ScreenshotDisplayType_APP_IPAD_PRO_3GEN_129          ScreenshotDisplayType = "APP_IPAD_PRO_3GEN_129"
	ScreenshotDisplayType_APP_IPHONE_35                  ScreenshotDisplayType = "APP_IPHONE_35"
	ScreenshotDisplayType_APP_IPHONE_40                  ScreenshotDisplayType = "APP_IPHONE_40"
	ScreenshotDisplayType_APP_IPHONE_47                  ScreenshotDisplayType = "APP_IPHONE_47"
	ScreenshotDisplayType_APP_IPHONE_55                  ScreenshotDisplayType = "APP_IPHONE_55"
	ScreenshotDisplayType_APP_IPHONE_58                  ScreenshotDisplayType = "APP_IPHONE_58"
	ScreenshotDisplayType_APP_IPHONE_65                  ScreenshotDisplayType = "APP_IPHONE_65"
	ScreenshotDisplayType_APP_WATCH_SERIES_3             ScreenshotDisplayType = "APP_WATCH_SERIES_3"
	ScreenshotDisplayType_APP_WATCH_SERIES_4             ScreenshotDisplayType = "APP_WATCH_SERIES_4"
	ScreenshotDisplayType_IMESSAGE_APP_IPAD_105          ScreenshotDisplayType = "IMESSAGE_APP_IPAD_105"
	ScreenshotDisplayType_IMESSAGE_APP_IPAD_97           ScreenshotDisplayType = "IMESSAGE_APP_IPAD_97"
	ScreenshotDisplayType_IMESSAGE_APP_IPAD_PRO_129      ScreenshotDisplayType = "IMESSAGE_APP_IPAD_PRO_129"
	ScreenshotDisplayType_IMESSAGE_APP_IPAD_PRO_3GEN_11  ScreenshotDisplayType = "IMESSAGE_APP_IPAD_PRO_3GEN_11"
	ScreenshotDisplayType_IMESSAGE_APP_IPAD_PRO_3GEN_129 ScreenshotDisplayType = "IMESSAGE_APP_IPAD_PRO_3GEN_129"
	ScreenshotDisplayType_IMESSAGE_APP_IPHONE_40         ScreenshotDisplayType = "IMESSAGE_APP_IPHONE_40"
	ScreenshotDisplayType_IMESSAGE_APP_IPHONE_47         ScreenshotDisplayType = "IMESSAGE_APP_IPHONE_47"
	ScreenshotDisplayType_IMESSAGE_APP_IPHONE_55         ScreenshotDisplayType = "IMESSAGE_APP_IPHONE_55"
	ScreenshotDisplayType_IMESSAGE_APP_IPHONE_58         ScreenshotDisplayType = "IMESSAGE_APP_IPHONE_58"
	ScreenshotDisplayType_IMESSAGE_APP_IPHONE_65         ScreenshotDisplayType = "IMESSAGE_APP_IPHONE_65"
)

// TerritoriesResponse defines model for TerritoriesResponse.
type TerritoriesResponse struct {
	Data  []Territory        `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// Territory defines model for Territory.
type Territory struct {
	Attributes *struct {
		Currency *string `json:"currency,omitempty"`
	} `json:"attributes,omitempty"`
	Id    string        `json:"id"`
	Links ResourceLinks `json:"links"`
	Type  string        `json:"type"`
}

// TerritoryResponse defines model for TerritoryResponse.
type TerritoryResponse struct {
	Data  Territory     `json:"data"`
	Links DocumentLinks `json:"links"`
}

// UploadOperation defines model for UploadOperation.
type UploadOperation struct {
	Length         *int                     `json:"length,omitempty"`
	Method         *string                  `json:"method,omitempty"`
	Offset         *int                     `json:"offset,omitempty"`
	RequestHeaders *[]UploadOperationHeader `json:"requestHeaders,omitempty"`
	Url            *string                  `json:"url,omitempty"`
}

// UploadOperationHeader defines model for UploadOperationHeader.
type UploadOperationHeader struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// User defines model for User.
type User struct {
	Attributes *struct {
		AllAppsVisible      *bool       `json:"allAppsVisible,omitempty"`
		FirstName           *string     `json:"firstName,omitempty"`
		LastName            *string     `json:"lastName,omitempty"`
		ProvisioningAllowed *bool       `json:"provisioningAllowed,omitempty"`
		Roles               *[]UserRole `json:"roles,omitempty"`
		Username            *string     `json:"username,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		VisibleApps *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"visibleApps,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// UserInvitation defines model for UserInvitation.
type UserInvitation struct {
	Attributes *struct {
		AllAppsVisible      *bool                `json:"allAppsVisible,omitempty"`
		Email               *openapi_types.Email `json:"email,omitempty"`
		ExpirationDate      *time.Time           `json:"expirationDate,omitempty"`
		FirstName           *string              `json:"firstName,omitempty"`
		LastName            *string              `json:"lastName,omitempty"`
		ProvisioningAllowed *bool                `json:"provisioningAllowed,omitempty"`
		Roles               *[]UserRole          `json:"roles,omitempty"`
	} `json:"attributes,omitempty"`
	Id            string        `json:"id"`
	Links         ResourceLinks `json:"links"`
	Relationships *struct {
		VisibleApps *struct {
			Data *[]struct {
				Id   string `json:"id"`
				Type string `json:"type"`
			} `json:"data,omitempty"`
			Links *struct {
				Related *string `json:"related,omitempty"`
				Self    *string `json:"self,omitempty"`
			} `json:"links,omitempty"`
			Meta *PagingInformation `json:"meta,omitempty"`
		} `json:"visibleApps,omitempty"`
	} `json:"relationships,omitempty"`
	Type string `json:"type"`
}

// UserInvitationCreateRequest defines model for UserInvitationCreateRequest.
type UserInvitationCreateRequest struct {
	Data struct {
		Attributes struct {
			AllAppsVisible      *bool               `json:"allAppsVisible,omitempty"`
			Email               openapi_types.Email `json:"email"`
			FirstName           string              `json:"firstName"`
			LastName            string              `json:"lastName"`
			ProvisioningAllowed *bool               `json:"provisioningAllowed,omitempty"`
			Roles               []UserRole          `json:"roles"`
		} `json:"attributes"`
		Relationships *struct {
			VisibleApps *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"visibleApps,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// UserInvitationResponse defines model for UserInvitationResponse.
type UserInvitationResponse struct {
	Data     UserInvitation `json:"data"`
	Included *[]App         `json:"included,omitempty"`
	Links    DocumentLinks  `json:"links"`
}

// UserInvitationsResponse defines model for UserInvitationsResponse.
type UserInvitationsResponse struct {
	Data     []UserInvitation   `json:"data"`
	Included *[]App             `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Data     User          `json:"data"`
	Included *[]App        `json:"included,omitempty"`
	Links    DocumentLinks `json:"links"`
}

// UserRole defines model for UserRole.
type UserRole string

// List of UserRole
const (
	UserRole_ACCESS_TO_REPORTS UserRole = "ACCESS_TO_REPORTS"
	UserRole_ACCOUNT_HOLDER    UserRole = "ACCOUNT_HOLDER"
	UserRole_ADMIN             UserRole = "ADMIN"
	UserRole_APP_MANAGER       UserRole = "APP_MANAGER"
	UserRole_CUSTOMER_SUPPORT  UserRole = "CUSTOMER_SUPPORT"
	UserRole_DEVELOPER         UserRole = "DEVELOPER"
	UserRole_FINANCE           UserRole = "FINANCE"
	UserRole_MARKETING         UserRole = "MARKETING"
	UserRole_READ_ONLY         UserRole = "READ_ONLY"
	UserRole_SALES             UserRole = "SALES"
	UserRole_TECHNICAL         UserRole = "TECHNICAL"
)

// UserUpdateRequest defines model for UserUpdateRequest.
type UserUpdateRequest struct {
	Data struct {
		Attributes *struct {
			AllAppsVisible      *bool       `json:"allAppsVisible,omitempty"`
			ProvisioningAllowed *bool       `json:"provisioningAllowed,omitempty"`
			Roles               *[]UserRole `json:"roles,omitempty"`
		} `json:"attributes,omitempty"`
		Id            string `json:"id"`
		Relationships *struct {
			VisibleApps *struct {
				Data *[]struct {
					Id   string `json:"id"`
					Type string `json:"type"`
				} `json:"data,omitempty"`
			} `json:"visibleApps,omitempty"`
		} `json:"relationships,omitempty"`
		Type string `json:"type"`
	} `json:"data"`
}

// UserVisibleAppsLinkagesRequest defines model for UserVisibleAppsLinkagesRequest.
type UserVisibleAppsLinkagesRequest struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
}

// UserVisibleAppsLinkagesResponse defines model for UserVisibleAppsLinkagesResponse.
type UserVisibleAppsLinkagesResponse struct {
	Data []struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `json:"data"`
	Links PagedDocumentLinks `json:"links"`
	Meta  *PagingInformation `json:"meta,omitempty"`
}

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Data     []User             `json:"data"`
	Included *[]App             `json:"included,omitempty"`
	Links    PagedDocumentLinks `json:"links"`
	Meta     *PagingInformation `json:"meta,omitempty"`
}

// AgeRatingDeclarationsUpdateInstanceJSONBody defines parameters for AgeRatingDeclarationsUpdateInstance.
type AgeRatingDeclarationsUpdateInstanceJSONBody AgeRatingDeclarationUpdateRequest

// AppCategoriesGetCollectionParams defines parameters for AppCategoriesGetCollection.
type AppCategoriesGetCollectionParams struct {

	// filter by attribute 'platforms'
	FilterPlatforms *[]string `json:"filter[platforms],omitempty"`

	// filter by existence or non-existence of related 'parent'
	ExistsParent *[]string `json:"exists[parent],omitempty"`

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// maximum number of related subcategories returned (when they are included)
	LimitSubcategories *int `json:"limit[subcategories],omitempty"`
}

// AppCategoriesGetInstanceParams defines parameters for AppCategoriesGetInstance.
type AppCategoriesGetInstanceParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// maximum number of related subcategories returned (when they are included)
	LimitSubcategories *int `json:"limit[subcategories],omitempty"`
}

// AppCategoriesParentGetToOneRelatedParams defines parameters for AppCategoriesParentGetToOneRelated.
type AppCategoriesParentGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppCategoriesSubcategoriesGetToManyRelatedParams defines parameters for AppCategoriesSubcategoriesGetToManyRelated.
type AppCategoriesSubcategoriesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppEncryptionDeclarationsGetCollectionParams defines parameters for AppEncryptionDeclarationsGetCollection.
type AppEncryptionDeclarationsGetCollectionParams struct {

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// filter by id(s) of related 'builds'
	FilterBuilds *[]string `json:"filter[builds],omitempty"`

	// the fields to include for returned resources of type appEncryptionDeclarations
	FieldsAppEncryptionDeclarations *[]string `json:"fields[appEncryptionDeclarations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// AppEncryptionDeclarationsGetInstanceParams defines parameters for AppEncryptionDeclarationsGetInstance.
type AppEncryptionDeclarationsGetInstanceParams struct {

	// the fields to include for returned resources of type appEncryptionDeclarations
	FieldsAppEncryptionDeclarations *[]string `json:"fields[appEncryptionDeclarations],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// AppEncryptionDeclarationsAppGetToOneRelatedParams defines parameters for AppEncryptionDeclarationsAppGetToOneRelated.
type AppEncryptionDeclarationsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONBody defines parameters for AppEncryptionDeclarationsBuildsCreateToManyRelationship.
type AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONBody AppEncryptionDeclarationBuildsLinkagesRequest

// AppInfoLocalizationsCreateInstanceJSONBody defines parameters for AppInfoLocalizationsCreateInstance.
type AppInfoLocalizationsCreateInstanceJSONBody AppInfoLocalizationCreateRequest

// AppInfoLocalizationsGetInstanceParams defines parameters for AppInfoLocalizationsGetInstance.
type AppInfoLocalizationsGetInstanceParams struct {

	// the fields to include for returned resources of type appInfoLocalizations
	FieldsAppInfoLocalizations *[]string `json:"fields[appInfoLocalizations],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppInfoLocalizationsUpdateInstanceJSONBody defines parameters for AppInfoLocalizationsUpdateInstance.
type AppInfoLocalizationsUpdateInstanceJSONBody AppInfoLocalizationUpdateRequest

// AppInfosGetInstanceParams defines parameters for AppInfosGetInstance.
type AppInfosGetInstanceParams struct {

	// the fields to include for returned resources of type appInfos
	FieldsAppInfos *[]string `json:"fields[appInfos],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`

	// the fields to include for returned resources of type appInfoLocalizations
	FieldsAppInfoLocalizations *[]string `json:"fields[appInfoLocalizations],omitempty"`

	// maximum number of related appInfoLocalizations returned (when they are included)
	LimitAppInfoLocalizations *int `json:"limit[appInfoLocalizations],omitempty"`
}

// AppInfosUpdateInstanceJSONBody defines parameters for AppInfosUpdateInstance.
type AppInfosUpdateInstanceJSONBody AppInfoUpdateRequest

// AppInfosAppInfoLocalizationsGetToManyRelatedParams defines parameters for AppInfosAppInfoLocalizationsGetToManyRelated.
type AppInfosAppInfoLocalizationsGetToManyRelatedParams struct {

	// filter by attribute 'locale'
	FilterLocale *[]string `json:"filter[locale],omitempty"`

	// the fields to include for returned resources of type appInfos
	FieldsAppInfos *[]string `json:"fields[appInfos],omitempty"`

	// the fields to include for returned resources of type appInfoLocalizations
	FieldsAppInfoLocalizations *[]string `json:"fields[appInfoLocalizations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppInfosPrimaryCategoryGetToOneRelatedParams defines parameters for AppInfosPrimaryCategoryGetToOneRelated.
type AppInfosPrimaryCategoryGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppInfosPrimarySubcategoryOneGetToOneRelatedParams defines parameters for AppInfosPrimarySubcategoryOneGetToOneRelated.
type AppInfosPrimarySubcategoryOneGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppInfosPrimarySubcategoryTwoGetToOneRelatedParams defines parameters for AppInfosPrimarySubcategoryTwoGetToOneRelated.
type AppInfosPrimarySubcategoryTwoGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppInfosSecondaryCategoryGetToOneRelatedParams defines parameters for AppInfosSecondaryCategoryGetToOneRelated.
type AppInfosSecondaryCategoryGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppInfosSecondarySubcategoryOneGetToOneRelatedParams defines parameters for AppInfosSecondarySubcategoryOneGetToOneRelated.
type AppInfosSecondarySubcategoryOneGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppInfosSecondarySubcategoryTwoGetToOneRelatedParams defines parameters for AppInfosSecondarySubcategoryTwoGetToOneRelated.
type AppInfosSecondarySubcategoryTwoGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`
}

// AppPreOrdersCreateInstanceJSONBody defines parameters for AppPreOrdersCreateInstance.
type AppPreOrdersCreateInstanceJSONBody AppPreOrderCreateRequest

// AppPreOrdersGetInstanceParams defines parameters for AppPreOrdersGetInstance.
type AppPreOrdersGetInstanceParams struct {

	// the fields to include for returned resources of type appPreOrders
	FieldsAppPreOrders *[]string `json:"fields[appPreOrders],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppPreOrdersUpdateInstanceJSONBody defines parameters for AppPreOrdersUpdateInstance.
type AppPreOrdersUpdateInstanceJSONBody AppPreOrderUpdateRequest

// AppPreviewSetsCreateInstanceJSONBody defines parameters for AppPreviewSetsCreateInstance.
type AppPreviewSetsCreateInstanceJSONBody AppPreviewSetCreateRequest

// AppPreviewSetsGetInstanceParams defines parameters for AppPreviewSetsGetInstance.
type AppPreviewSetsGetInstanceParams struct {

	// the fields to include for returned resources of type appPreviewSets
	FieldsAppPreviewSets *[]string `json:"fields[appPreviewSets],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appPreviews
	FieldsAppPreviews *[]string `json:"fields[appPreviews],omitempty"`

	// maximum number of related appPreviews returned (when they are included)
	LimitAppPreviews *int `json:"limit[appPreviews],omitempty"`
}

// AppPreviewSetsAppPreviewsGetToManyRelatedParams defines parameters for AppPreviewSetsAppPreviewsGetToManyRelated.
type AppPreviewSetsAppPreviewsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appPreviews
	FieldsAppPreviews *[]string `json:"fields[appPreviews],omitempty"`

	// the fields to include for returned resources of type appPreviewSets
	FieldsAppPreviewSets *[]string `json:"fields[appPreviewSets],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppPreviewSetsAppPreviewsGetToManyRelationshipParams defines parameters for AppPreviewSetsAppPreviewsGetToManyRelationship.
type AppPreviewSetsAppPreviewsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONBody defines parameters for AppPreviewSetsAppPreviewsReplaceToManyRelationship.
type AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONBody AppPreviewSetAppPreviewsLinkagesRequest

// AppPreviewsCreateInstanceJSONBody defines parameters for AppPreviewsCreateInstance.
type AppPreviewsCreateInstanceJSONBody AppPreviewCreateRequest

// AppPreviewsGetInstanceParams defines parameters for AppPreviewsGetInstance.
type AppPreviewsGetInstanceParams struct {

	// the fields to include for returned resources of type appPreviews
	FieldsAppPreviews *[]string `json:"fields[appPreviews],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppPreviewsUpdateInstanceJSONBody defines parameters for AppPreviewsUpdateInstance.
type AppPreviewsUpdateInstanceJSONBody AppPreviewUpdateRequest

// AppPricePointsGetCollectionParams defines parameters for AppPricePointsGetCollection.
type AppPricePointsGetCollectionParams struct {

	// filter by id(s) of related 'priceTier'
	FilterPriceTier *[]string `json:"filter[priceTier],omitempty"`

	// filter by id(s) of related 'territory'
	FilterTerritory *[]string `json:"filter[territory],omitempty"`

	// the fields to include for returned resources of type appPricePoints
	FieldsAppPricePoints *[]string `json:"fields[appPricePoints],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`
}

// AppPricePointsGetInstanceParams defines parameters for AppPricePointsGetInstance.
type AppPricePointsGetInstanceParams struct {

	// the fields to include for returned resources of type appPricePoints
	FieldsAppPricePoints *[]string `json:"fields[appPricePoints],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`
}

// AppPricePointsTerritoryGetToOneRelatedParams defines parameters for AppPricePointsTerritoryGetToOneRelated.
type AppPricePointsTerritoryGetToOneRelatedParams struct {

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`
}

// AppPriceTiersGetCollectionParams defines parameters for AppPriceTiersGetCollection.
type AppPriceTiersGetCollectionParams struct {

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// the fields to include for returned resources of type appPriceTiers
	FieldsAppPriceTiers *[]string `json:"fields[appPriceTiers],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appPricePoints
	FieldsAppPricePoints *[]string `json:"fields[appPricePoints],omitempty"`

	// maximum number of related pricePoints returned (when they are included)
	LimitPricePoints *int `json:"limit[pricePoints],omitempty"`
}

// AppPriceTiersGetInstanceParams defines parameters for AppPriceTiersGetInstance.
type AppPriceTiersGetInstanceParams struct {

	// the fields to include for returned resources of type appPriceTiers
	FieldsAppPriceTiers *[]string `json:"fields[appPriceTiers],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appPricePoints
	FieldsAppPricePoints *[]string `json:"fields[appPricePoints],omitempty"`

	// maximum number of related pricePoints returned (when they are included)
	LimitPricePoints *int `json:"limit[pricePoints],omitempty"`
}

// AppPriceTiersPricePointsGetToManyRelatedParams defines parameters for AppPriceTiersPricePointsGetToManyRelated.
type AppPriceTiersPricePointsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appPricePoints
	FieldsAppPricePoints *[]string `json:"fields[appPricePoints],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppPricesGetInstanceParams defines parameters for AppPricesGetInstance.
type AppPricesGetInstanceParams struct {

	// the fields to include for returned resources of type appPrices
	FieldsAppPrices *[]string `json:"fields[appPrices],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppScreenshotSetsCreateInstanceJSONBody defines parameters for AppScreenshotSetsCreateInstance.
type AppScreenshotSetsCreateInstanceJSONBody AppScreenshotSetCreateRequest

// AppScreenshotSetsGetInstanceParams defines parameters for AppScreenshotSetsGetInstance.
type AppScreenshotSetsGetInstanceParams struct {

	// the fields to include for returned resources of type appScreenshotSets
	FieldsAppScreenshotSets *[]string `json:"fields[appScreenshotSets],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appScreenshots
	FieldsAppScreenshots *[]string `json:"fields[appScreenshots],omitempty"`

	// maximum number of related appScreenshots returned (when they are included)
	LimitAppScreenshots *int `json:"limit[appScreenshots],omitempty"`
}

// AppScreenshotSetsAppScreenshotsGetToManyRelatedParams defines parameters for AppScreenshotSetsAppScreenshotsGetToManyRelated.
type AppScreenshotSetsAppScreenshotsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appScreenshotSets
	FieldsAppScreenshotSets *[]string `json:"fields[appScreenshotSets],omitempty"`

	// the fields to include for returned resources of type appScreenshots
	FieldsAppScreenshots *[]string `json:"fields[appScreenshots],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams defines parameters for AppScreenshotSetsAppScreenshotsGetToManyRelationship.
type AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONBody defines parameters for AppScreenshotSetsAppScreenshotsReplaceToManyRelationship.
type AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONBody AppScreenshotSetAppScreenshotsLinkagesRequest

// AppScreenshotsCreateInstanceJSONBody defines parameters for AppScreenshotsCreateInstance.
type AppScreenshotsCreateInstanceJSONBody AppScreenshotCreateRequest

// AppScreenshotsGetInstanceParams defines parameters for AppScreenshotsGetInstance.
type AppScreenshotsGetInstanceParams struct {

	// the fields to include for returned resources of type appScreenshots
	FieldsAppScreenshots *[]string `json:"fields[appScreenshots],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppScreenshotsUpdateInstanceJSONBody defines parameters for AppScreenshotsUpdateInstance.
type AppScreenshotsUpdateInstanceJSONBody AppScreenshotUpdateRequest

// AppStoreReviewAttachmentsCreateInstanceJSONBody defines parameters for AppStoreReviewAttachmentsCreateInstance.
type AppStoreReviewAttachmentsCreateInstanceJSONBody AppStoreReviewAttachmentCreateRequest

// AppStoreReviewAttachmentsGetInstanceParams defines parameters for AppStoreReviewAttachmentsGetInstance.
type AppStoreReviewAttachmentsGetInstanceParams struct {

	// the fields to include for returned resources of type appStoreReviewAttachments
	FieldsAppStoreReviewAttachments *[]string `json:"fields[appStoreReviewAttachments],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppStoreReviewAttachmentsUpdateInstanceJSONBody defines parameters for AppStoreReviewAttachmentsUpdateInstance.
type AppStoreReviewAttachmentsUpdateInstanceJSONBody AppStoreReviewAttachmentUpdateRequest

// AppStoreReviewDetailsCreateInstanceJSONBody defines parameters for AppStoreReviewDetailsCreateInstance.
type AppStoreReviewDetailsCreateInstanceJSONBody AppStoreReviewDetailCreateRequest

// AppStoreReviewDetailsGetInstanceParams defines parameters for AppStoreReviewDetailsGetInstance.
type AppStoreReviewDetailsGetInstanceParams struct {

	// the fields to include for returned resources of type appStoreReviewDetails
	FieldsAppStoreReviewDetails *[]string `json:"fields[appStoreReviewDetails],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appStoreReviewAttachments
	FieldsAppStoreReviewAttachments *[]string `json:"fields[appStoreReviewAttachments],omitempty"`

	// maximum number of related appStoreReviewAttachments returned (when they are included)
	LimitAppStoreReviewAttachments *int `json:"limit[appStoreReviewAttachments],omitempty"`
}

// AppStoreReviewDetailsUpdateInstanceJSONBody defines parameters for AppStoreReviewDetailsUpdateInstance.
type AppStoreReviewDetailsUpdateInstanceJSONBody AppStoreReviewDetailUpdateRequest

// AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams defines parameters for AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated.
type AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appStoreReviewDetails
	FieldsAppStoreReviewDetails *[]string `json:"fields[appStoreReviewDetails],omitempty"`

	// the fields to include for returned resources of type appStoreReviewAttachments
	FieldsAppStoreReviewAttachments *[]string `json:"fields[appStoreReviewAttachments],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppStoreVersionLocalizationsCreateInstanceJSONBody defines parameters for AppStoreVersionLocalizationsCreateInstance.
type AppStoreVersionLocalizationsCreateInstanceJSONBody AppStoreVersionLocalizationCreateRequest

// AppStoreVersionLocalizationsGetInstanceParams defines parameters for AppStoreVersionLocalizationsGetInstance.
type AppStoreVersionLocalizationsGetInstanceParams struct {

	// the fields to include for returned resources of type appStoreVersionLocalizations
	FieldsAppStoreVersionLocalizations *[]string `json:"fields[appStoreVersionLocalizations],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appScreenshotSets
	FieldsAppScreenshotSets *[]string `json:"fields[appScreenshotSets],omitempty"`

	// the fields to include for returned resources of type appPreviewSets
	FieldsAppPreviewSets *[]string `json:"fields[appPreviewSets],omitempty"`

	// maximum number of related appPreviewSets returned (when they are included)
	LimitAppPreviewSets *int `json:"limit[appPreviewSets],omitempty"`

	// maximum number of related appScreenshotSets returned (when they are included)
	LimitAppScreenshotSets *int `json:"limit[appScreenshotSets],omitempty"`
}

// AppStoreVersionLocalizationsUpdateInstanceJSONBody defines parameters for AppStoreVersionLocalizationsUpdateInstance.
type AppStoreVersionLocalizationsUpdateInstanceJSONBody AppStoreVersionLocalizationUpdateRequest

// AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams defines parameters for AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated.
type AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams struct {

	// filter by attribute 'previewType'
	FilterPreviewType *[]string `json:"filter[previewType],omitempty"`

	// the fields to include for returned resources of type appStoreVersionLocalizations
	FieldsAppStoreVersionLocalizations *[]string `json:"fields[appStoreVersionLocalizations],omitempty"`

	// the fields to include for returned resources of type appPreviews
	FieldsAppPreviews *[]string `json:"fields[appPreviews],omitempty"`

	// the fields to include for returned resources of type appPreviewSets
	FieldsAppPreviewSets *[]string `json:"fields[appPreviewSets],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams defines parameters for AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated.
type AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams struct {

	// filter by attribute 'screenshotDisplayType'
	FilterScreenshotDisplayType *[]string `json:"filter[screenshotDisplayType],omitempty"`

	// the fields to include for returned resources of type appStoreVersionLocalizations
	FieldsAppStoreVersionLocalizations *[]string `json:"fields[appStoreVersionLocalizations],omitempty"`

	// the fields to include for returned resources of type appScreenshotSets
	FieldsAppScreenshotSets *[]string `json:"fields[appScreenshotSets],omitempty"`

	// the fields to include for returned resources of type appScreenshots
	FieldsAppScreenshots *[]string `json:"fields[appScreenshots],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppStoreVersionPhasedReleasesCreateInstanceJSONBody defines parameters for AppStoreVersionPhasedReleasesCreateInstance.
type AppStoreVersionPhasedReleasesCreateInstanceJSONBody AppStoreVersionPhasedReleaseCreateRequest

// AppStoreVersionPhasedReleasesUpdateInstanceJSONBody defines parameters for AppStoreVersionPhasedReleasesUpdateInstance.
type AppStoreVersionPhasedReleasesUpdateInstanceJSONBody AppStoreVersionPhasedReleaseUpdateRequest

// AppStoreVersionSubmissionsCreateInstanceJSONBody defines parameters for AppStoreVersionSubmissionsCreateInstance.
type AppStoreVersionSubmissionsCreateInstanceJSONBody AppStoreVersionSubmissionCreateRequest

// AppStoreVersionsCreateInstanceJSONBody defines parameters for AppStoreVersionsCreateInstance.
type AppStoreVersionsCreateInstanceJSONBody AppStoreVersionCreateRequest

// AppStoreVersionsGetInstanceParams defines parameters for AppStoreVersionsGetInstance.
type AppStoreVersionsGetInstanceParams struct {

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appStoreVersionLocalizations
	FieldsAppStoreVersionLocalizations *[]string `json:"fields[appStoreVersionLocalizations],omitempty"`

	// the fields to include for returned resources of type idfaDeclarations
	FieldsIdfaDeclarations *[]string `json:"fields[idfaDeclarations],omitempty"`

	// the fields to include for returned resources of type routingAppCoverages
	FieldsRoutingAppCoverages *[]string `json:"fields[routingAppCoverages],omitempty"`

	// the fields to include for returned resources of type appStoreVersionPhasedReleases
	FieldsAppStoreVersionPhasedReleases *[]string `json:"fields[appStoreVersionPhasedReleases],omitempty"`

	// the fields to include for returned resources of type ageRatingDeclarations
	FieldsAgeRatingDeclarations *[]string `json:"fields[ageRatingDeclarations],omitempty"`

	// the fields to include for returned resources of type appStoreReviewDetails
	FieldsAppStoreReviewDetails *[]string `json:"fields[appStoreReviewDetails],omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type appStoreVersionSubmissions
	FieldsAppStoreVersionSubmissions *[]string `json:"fields[appStoreVersionSubmissions],omitempty"`

	// maximum number of related appStoreVersionLocalizations returned (when they are included)
	LimitAppStoreVersionLocalizations *int `json:"limit[appStoreVersionLocalizations],omitempty"`
}

// AppStoreVersionsUpdateInstanceJSONBody defines parameters for AppStoreVersionsUpdateInstance.
type AppStoreVersionsUpdateInstanceJSONBody AppStoreVersionUpdateRequest

// AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams defines parameters for AppStoreVersionsAgeRatingDeclarationGetToOneRelated.
type AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams struct {

	// the fields to include for returned resources of type ageRatingDeclarations
	FieldsAgeRatingDeclarations *[]string `json:"fields[ageRatingDeclarations],omitempty"`
}

// AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams defines parameters for AppStoreVersionsAppStoreReviewDetailGetToOneRelated.
type AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appStoreReviewDetails
	FieldsAppStoreReviewDetails *[]string `json:"fields[appStoreReviewDetails],omitempty"`

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type appStoreReviewAttachments
	FieldsAppStoreReviewAttachments *[]string `json:"fields[appStoreReviewAttachments],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams defines parameters for AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated.
type AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appStoreVersionLocalizations
	FieldsAppStoreVersionLocalizations *[]string `json:"fields[appStoreVersionLocalizations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams defines parameters for AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated.
type AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appStoreVersionPhasedReleases
	FieldsAppStoreVersionPhasedReleases *[]string `json:"fields[appStoreVersionPhasedReleases],omitempty"`
}

// AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams defines parameters for AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated.
type AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type appStoreVersionSubmissions
	FieldsAppStoreVersionSubmissions *[]string `json:"fields[appStoreVersionSubmissions],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppStoreVersionsBuildGetToOneRelatedParams defines parameters for AppStoreVersionsBuildGetToOneRelated.
type AppStoreVersionsBuildGetToOneRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// AppStoreVersionsIdfaDeclarationGetToOneRelatedParams defines parameters for AppStoreVersionsIdfaDeclarationGetToOneRelated.
type AppStoreVersionsIdfaDeclarationGetToOneRelatedParams struct {

	// the fields to include for returned resources of type idfaDeclarations
	FieldsIdfaDeclarations *[]string `json:"fields[idfaDeclarations],omitempty"`
}

// AppStoreVersionsBuildUpdateToOneRelationshipJSONBody defines parameters for AppStoreVersionsBuildUpdateToOneRelationship.
type AppStoreVersionsBuildUpdateToOneRelationshipJSONBody AppStoreVersionBuildLinkageRequest

// AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams defines parameters for AppStoreVersionsRoutingAppCoverageGetToOneRelated.
type AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams struct {

	// the fields to include for returned resources of type routingAppCoverages
	FieldsRoutingAppCoverages *[]string `json:"fields[routingAppCoverages],omitempty"`
}

// AppsGetCollectionParams defines parameters for AppsGetCollection.
type AppsGetCollectionParams struct {

	// filter by attribute 'appStoreVersions.appStoreState'
	FilterAppStoreVersionsAppStoreState *[]string `json:"filter[appStoreVersions.appStoreState],omitempty"`

	// filter by attribute 'appStoreVersions.platform'
	FilterAppStoreVersionsPlatform *[]string `json:"filter[appStoreVersions.platform],omitempty"`

	// filter by attribute 'bundleId'
	FilterBundleId *[]string `json:"filter[bundleId],omitempty"`

	// filter by attribute 'name'
	FilterName *[]string `json:"filter[name],omitempty"`

	// filter by attribute 'sku'
	FilterSku *[]string `json:"filter[sku],omitempty"`

	// filter by id(s) of related 'appStoreVersions'
	FilterAppStoreVersions *[]string `json:"filter[appStoreVersions],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// filter by existence or non-existence of related 'gameCenterEnabledVersions'
	ExistsGameCenterEnabledVersions *[]string `json:"exists[gameCenterEnabledVersions],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// the fields to include for returned resources of type perfPowerMetrics
	FieldsPerfPowerMetrics *[]string `json:"fields[perfPowerMetrics],omitempty"`

	// the fields to include for returned resources of type appInfos
	FieldsAppInfos *[]string `json:"fields[appInfos],omitempty"`

	// the fields to include for returned resources of type appPreOrders
	FieldsAppPreOrders *[]string `json:"fields[appPreOrders],omitempty"`

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// the fields to include for returned resources of type appPrices
	FieldsAppPrices *[]string `json:"fields[appPrices],omitempty"`

	// the fields to include for returned resources of type inAppPurchases
	FieldsInAppPurchases *[]string `json:"fields[inAppPurchases],omitempty"`

	// the fields to include for returned resources of type betaAppReviewDetails
	FieldsBetaAppReviewDetails *[]string `json:"fields[betaAppReviewDetails],omitempty"`

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`

	// the fields to include for returned resources of type gameCenterEnabledVersions
	FieldsGameCenterEnabledVersions *[]string `json:"fields[gameCenterEnabledVersions],omitempty"`

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type betaAppLocalizations
	FieldsBetaAppLocalizations *[]string `json:"fields[betaAppLocalizations],omitempty"`

	// the fields to include for returned resources of type betaLicenseAgreements
	FieldsBetaLicenseAgreements *[]string `json:"fields[betaLicenseAgreements],omitempty"`

	// the fields to include for returned resources of type endUserLicenseAgreements
	FieldsEndUserLicenseAgreements *[]string `json:"fields[endUserLicenseAgreements],omitempty"`

	// maximum number of related appInfos returned (when they are included)
	LimitAppInfos *int `json:"limit[appInfos],omitempty"`

	// maximum number of related appStoreVersions returned (when they are included)
	LimitAppStoreVersions *int `json:"limit[appStoreVersions],omitempty"`

	// maximum number of related availableTerritories returned (when they are included)
	LimitAvailableTerritories *int `json:"limit[availableTerritories],omitempty"`

	// maximum number of related betaAppLocalizations returned (when they are included)
	LimitBetaAppLocalizations *int `json:"limit[betaAppLocalizations],omitempty"`

	// maximum number of related betaGroups returned (when they are included)
	LimitBetaGroups *int `json:"limit[betaGroups],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`

	// maximum number of related gameCenterEnabledVersions returned (when they are included)
	LimitGameCenterEnabledVersions *int `json:"limit[gameCenterEnabledVersions],omitempty"`

	// maximum number of related inAppPurchases returned (when they are included)
	LimitInAppPurchases *int `json:"limit[inAppPurchases],omitempty"`

	// maximum number of related preReleaseVersions returned (when they are included)
	LimitPreReleaseVersions *int `json:"limit[preReleaseVersions],omitempty"`

	// maximum number of related prices returned (when they are included)
	LimitPrices *int `json:"limit[prices],omitempty"`
}

// AppsGetInstanceParams defines parameters for AppsGetInstance.
type AppsGetInstanceParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// the fields to include for returned resources of type perfPowerMetrics
	FieldsPerfPowerMetrics *[]string `json:"fields[perfPowerMetrics],omitempty"`

	// the fields to include for returned resources of type appInfos
	FieldsAppInfos *[]string `json:"fields[appInfos],omitempty"`

	// the fields to include for returned resources of type appPreOrders
	FieldsAppPreOrders *[]string `json:"fields[appPreOrders],omitempty"`

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// the fields to include for returned resources of type appPrices
	FieldsAppPrices *[]string `json:"fields[appPrices],omitempty"`

	// the fields to include for returned resources of type inAppPurchases
	FieldsInAppPurchases *[]string `json:"fields[inAppPurchases],omitempty"`

	// the fields to include for returned resources of type betaAppReviewDetails
	FieldsBetaAppReviewDetails *[]string `json:"fields[betaAppReviewDetails],omitempty"`

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`

	// the fields to include for returned resources of type gameCenterEnabledVersions
	FieldsGameCenterEnabledVersions *[]string `json:"fields[gameCenterEnabledVersions],omitempty"`

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type betaAppLocalizations
	FieldsBetaAppLocalizations *[]string `json:"fields[betaAppLocalizations],omitempty"`

	// the fields to include for returned resources of type betaLicenseAgreements
	FieldsBetaLicenseAgreements *[]string `json:"fields[betaLicenseAgreements],omitempty"`

	// the fields to include for returned resources of type endUserLicenseAgreements
	FieldsEndUserLicenseAgreements *[]string `json:"fields[endUserLicenseAgreements],omitempty"`

	// maximum number of related appInfos returned (when they are included)
	LimitAppInfos *int `json:"limit[appInfos],omitempty"`

	// maximum number of related appStoreVersions returned (when they are included)
	LimitAppStoreVersions *int `json:"limit[appStoreVersions],omitempty"`

	// maximum number of related availableTerritories returned (when they are included)
	LimitAvailableTerritories *int `json:"limit[availableTerritories],omitempty"`

	// maximum number of related betaAppLocalizations returned (when they are included)
	LimitBetaAppLocalizations *int `json:"limit[betaAppLocalizations],omitempty"`

	// maximum number of related betaGroups returned (when they are included)
	LimitBetaGroups *int `json:"limit[betaGroups],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`

	// maximum number of related gameCenterEnabledVersions returned (when they are included)
	LimitGameCenterEnabledVersions *int `json:"limit[gameCenterEnabledVersions],omitempty"`

	// maximum number of related inAppPurchases returned (when they are included)
	LimitInAppPurchases *int `json:"limit[inAppPurchases],omitempty"`

	// maximum number of related preReleaseVersions returned (when they are included)
	LimitPreReleaseVersions *int `json:"limit[preReleaseVersions],omitempty"`

	// maximum number of related prices returned (when they are included)
	LimitPrices *int `json:"limit[prices],omitempty"`
}

// AppsUpdateInstanceJSONBody defines parameters for AppsUpdateInstance.
type AppsUpdateInstanceJSONBody AppUpdateRequest

// AppsAppInfosGetToManyRelatedParams defines parameters for AppsAppInfosGetToManyRelated.
type AppsAppInfosGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appInfos
	FieldsAppInfos *[]string `json:"fields[appInfos],omitempty"`

	// the fields to include for returned resources of type appCategories
	FieldsAppCategories *[]string `json:"fields[appCategories],omitempty"`

	// the fields to include for returned resources of type appInfoLocalizations
	FieldsAppInfoLocalizations *[]string `json:"fields[appInfoLocalizations],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppsAppStoreVersionsGetToManyRelatedParams defines parameters for AppsAppStoreVersionsGetToManyRelated.
type AppsAppStoreVersionsGetToManyRelatedParams struct {

	// filter by attribute 'appStoreState'
	FilterAppStoreState *[]string `json:"filter[appStoreState],omitempty"`

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by attribute 'versionString'
	FilterVersionString *[]string `json:"filter[versionString],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// the fields to include for returned resources of type idfaDeclarations
	FieldsIdfaDeclarations *[]string `json:"fields[idfaDeclarations],omitempty"`

	// the fields to include for returned resources of type appStoreVersionLocalizations
	FieldsAppStoreVersionLocalizations *[]string `json:"fields[appStoreVersionLocalizations],omitempty"`

	// the fields to include for returned resources of type routingAppCoverages
	FieldsRoutingAppCoverages *[]string `json:"fields[routingAppCoverages],omitempty"`

	// the fields to include for returned resources of type appStoreVersionPhasedReleases
	FieldsAppStoreVersionPhasedReleases *[]string `json:"fields[appStoreVersionPhasedReleases],omitempty"`

	// the fields to include for returned resources of type ageRatingDeclarations
	FieldsAgeRatingDeclarations *[]string `json:"fields[ageRatingDeclarations],omitempty"`

	// the fields to include for returned resources of type appStoreReviewDetails
	FieldsAppStoreReviewDetails *[]string `json:"fields[appStoreReviewDetails],omitempty"`

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type appStoreVersionSubmissions
	FieldsAppStoreVersionSubmissions *[]string `json:"fields[appStoreVersionSubmissions],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppsAvailableTerritoriesGetToManyRelatedParams defines parameters for AppsAvailableTerritoriesGetToManyRelated.
type AppsAvailableTerritoriesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppsBetaAppLocalizationsGetToManyRelatedParams defines parameters for AppsBetaAppLocalizationsGetToManyRelated.
type AppsBetaAppLocalizationsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type betaAppLocalizations
	FieldsBetaAppLocalizations *[]string `json:"fields[betaAppLocalizations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppsBetaAppReviewDetailGetToOneRelatedParams defines parameters for AppsBetaAppReviewDetailGetToOneRelated.
type AppsBetaAppReviewDetailGetToOneRelatedParams struct {

	// the fields to include for returned resources of type betaAppReviewDetails
	FieldsBetaAppReviewDetails *[]string `json:"fields[betaAppReviewDetails],omitempty"`
}

// AppsBetaGroupsGetToManyRelatedParams defines parameters for AppsBetaGroupsGetToManyRelated.
type AppsBetaGroupsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppsBetaLicenseAgreementGetToOneRelatedParams defines parameters for AppsBetaLicenseAgreementGetToOneRelated.
type AppsBetaLicenseAgreementGetToOneRelatedParams struct {

	// the fields to include for returned resources of type betaLicenseAgreements
	FieldsBetaLicenseAgreements *[]string `json:"fields[betaLicenseAgreements],omitempty"`
}

// AppsBuildsGetToManyRelatedParams defines parameters for AppsBuildsGetToManyRelated.
type AppsBuildsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppsEndUserLicenseAgreementGetToOneRelatedParams defines parameters for AppsEndUserLicenseAgreementGetToOneRelated.
type AppsEndUserLicenseAgreementGetToOneRelatedParams struct {

	// the fields to include for returned resources of type endUserLicenseAgreements
	FieldsEndUserLicenseAgreements *[]string `json:"fields[endUserLicenseAgreements],omitempty"`
}

// AppsGameCenterEnabledVersionsGetToManyRelatedParams defines parameters for AppsGameCenterEnabledVersionsGetToManyRelated.
type AppsGameCenterEnabledVersionsGetToManyRelatedParams struct {

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by attribute 'versionString'
	FilterVersionString *[]string `json:"filter[versionString],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type gameCenterEnabledVersions
	FieldsGameCenterEnabledVersions *[]string `json:"fields[gameCenterEnabledVersions],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppsInAppPurchasesGetToManyRelatedParams defines parameters for AppsInAppPurchasesGetToManyRelated.
type AppsInAppPurchasesGetToManyRelatedParams struct {

	// filter by attribute 'inAppPurchaseType'
	FilterInAppPurchaseType *[]string `json:"filter[inAppPurchaseType],omitempty"`

	// filter by canBeSubmitted
	FilterCanBeSubmitted *[]string `json:"filter[canBeSubmitted],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type inAppPurchases
	FieldsInAppPurchases *[]string `json:"fields[inAppPurchases],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppsPerfPowerMetricsGetToManyRelatedParams defines parameters for AppsPerfPowerMetricsGetToManyRelated.
type AppsPerfPowerMetricsGetToManyRelatedParams struct {

	// filter by attribute 'deviceType'
	FilterDeviceType *[]string `json:"filter[deviceType],omitempty"`

	// filter by attribute 'metricType'
	FilterMetricType *[]string `json:"filter[metricType],omitempty"`

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`
}

// AppsPreOrderGetToOneRelatedParams defines parameters for AppsPreOrderGetToOneRelated.
type AppsPreOrderGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appPreOrders
	FieldsAppPreOrders *[]string `json:"fields[appPreOrders],omitempty"`
}

// AppsPreReleaseVersionsGetToManyRelatedParams defines parameters for AppsPreReleaseVersionsGetToManyRelated.
type AppsPreReleaseVersionsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AppsPricesGetToManyRelatedParams defines parameters for AppsPricesGetToManyRelated.
type AppsPricesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type appPrices
	FieldsAppPrices *[]string `json:"fields[appPrices],omitempty"`

	// the fields to include for returned resources of type appPriceTiers
	FieldsAppPriceTiers *[]string `json:"fields[appPriceTiers],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// AppsBetaTestersDeleteToManyRelationshipJSONBody defines parameters for AppsBetaTestersDeleteToManyRelationship.
type AppsBetaTestersDeleteToManyRelationshipJSONBody AppBetaTestersLinkagesRequest

// BetaAppLocalizationsGetCollectionParams defines parameters for BetaAppLocalizationsGetCollection.
type BetaAppLocalizationsGetCollectionParams struct {

	// filter by attribute 'locale'
	FilterLocale *[]string `json:"filter[locale],omitempty"`

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// the fields to include for returned resources of type betaAppLocalizations
	FieldsBetaAppLocalizations *[]string `json:"fields[betaAppLocalizations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaAppLocalizationsCreateInstanceJSONBody defines parameters for BetaAppLocalizationsCreateInstance.
type BetaAppLocalizationsCreateInstanceJSONBody BetaAppLocalizationCreateRequest

// BetaAppLocalizationsGetInstanceParams defines parameters for BetaAppLocalizationsGetInstance.
type BetaAppLocalizationsGetInstanceParams struct {

	// the fields to include for returned resources of type betaAppLocalizations
	FieldsBetaAppLocalizations *[]string `json:"fields[betaAppLocalizations],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaAppLocalizationsUpdateInstanceJSONBody defines parameters for BetaAppLocalizationsUpdateInstance.
type BetaAppLocalizationsUpdateInstanceJSONBody BetaAppLocalizationUpdateRequest

// BetaAppLocalizationsAppGetToOneRelatedParams defines parameters for BetaAppLocalizationsAppGetToOneRelated.
type BetaAppLocalizationsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaAppReviewDetailsGetCollectionParams defines parameters for BetaAppReviewDetailsGetCollection.
type BetaAppReviewDetailsGetCollectionParams struct {

	// filter by id(s) of related 'app'
	FilterApp []string `json:"filter[app]"`

	// the fields to include for returned resources of type betaAppReviewDetails
	FieldsBetaAppReviewDetails *[]string `json:"fields[betaAppReviewDetails],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaAppReviewDetailsGetInstanceParams defines parameters for BetaAppReviewDetailsGetInstance.
type BetaAppReviewDetailsGetInstanceParams struct {

	// the fields to include for returned resources of type betaAppReviewDetails
	FieldsBetaAppReviewDetails *[]string `json:"fields[betaAppReviewDetails],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaAppReviewDetailsUpdateInstanceJSONBody defines parameters for BetaAppReviewDetailsUpdateInstance.
type BetaAppReviewDetailsUpdateInstanceJSONBody BetaAppReviewDetailUpdateRequest

// BetaAppReviewDetailsAppGetToOneRelatedParams defines parameters for BetaAppReviewDetailsAppGetToOneRelated.
type BetaAppReviewDetailsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaAppReviewSubmissionsGetCollectionParams defines parameters for BetaAppReviewSubmissionsGetCollection.
type BetaAppReviewSubmissionsGetCollectionParams struct {

	// filter by attribute 'betaReviewState'
	FilterBetaReviewState *[]string `json:"filter[betaReviewState],omitempty"`

	// filter by id(s) of related 'build'
	FilterBuild []string `json:"filter[build]"`

	// the fields to include for returned resources of type betaAppReviewSubmissions
	FieldsBetaAppReviewSubmissions *[]string `json:"fields[betaAppReviewSubmissions],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BetaAppReviewSubmissionsCreateInstanceJSONBody defines parameters for BetaAppReviewSubmissionsCreateInstance.
type BetaAppReviewSubmissionsCreateInstanceJSONBody BetaAppReviewSubmissionCreateRequest

// BetaAppReviewSubmissionsGetInstanceParams defines parameters for BetaAppReviewSubmissionsGetInstance.
type BetaAppReviewSubmissionsGetInstanceParams struct {

	// the fields to include for returned resources of type betaAppReviewSubmissions
	FieldsBetaAppReviewSubmissions *[]string `json:"fields[betaAppReviewSubmissions],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BetaAppReviewSubmissionsBuildGetToOneRelatedParams defines parameters for BetaAppReviewSubmissionsBuildGetToOneRelated.
type BetaAppReviewSubmissionsBuildGetToOneRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BetaBuildLocalizationsGetCollectionParams defines parameters for BetaBuildLocalizationsGetCollection.
type BetaBuildLocalizationsGetCollectionParams struct {

	// filter by attribute 'locale'
	FilterLocale *[]string `json:"filter[locale],omitempty"`

	// filter by id(s) of related 'build'
	FilterBuild *[]string `json:"filter[build],omitempty"`

	// the fields to include for returned resources of type betaBuildLocalizations
	FieldsBetaBuildLocalizations *[]string `json:"fields[betaBuildLocalizations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BetaBuildLocalizationsCreateInstanceJSONBody defines parameters for BetaBuildLocalizationsCreateInstance.
type BetaBuildLocalizationsCreateInstanceJSONBody BetaBuildLocalizationCreateRequest

// BetaBuildLocalizationsGetInstanceParams defines parameters for BetaBuildLocalizationsGetInstance.
type BetaBuildLocalizationsGetInstanceParams struct {

	// the fields to include for returned resources of type betaBuildLocalizations
	FieldsBetaBuildLocalizations *[]string `json:"fields[betaBuildLocalizations],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BetaBuildLocalizationsUpdateInstanceJSONBody defines parameters for BetaBuildLocalizationsUpdateInstance.
type BetaBuildLocalizationsUpdateInstanceJSONBody BetaBuildLocalizationUpdateRequest

// BetaBuildLocalizationsBuildGetToOneRelatedParams defines parameters for BetaBuildLocalizationsBuildGetToOneRelated.
type BetaBuildLocalizationsBuildGetToOneRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BetaGroupsGetCollectionParams defines parameters for BetaGroupsGetCollection.
type BetaGroupsGetCollectionParams struct {

	// filter by attribute 'isInternalGroup'
	FilterIsInternalGroup *[]string `json:"filter[isInternalGroup],omitempty"`

	// filter by attribute 'name'
	FilterName *[]string `json:"filter[name],omitempty"`

	// filter by attribute 'publicLink'
	FilterPublicLink *[]string `json:"filter[publicLink],omitempty"`

	// filter by attribute 'publicLinkEnabled'
	FilterPublicLinkEnabled *[]string `json:"filter[publicLinkEnabled],omitempty"`

	// filter by attribute 'publicLinkLimitEnabled'
	FilterPublicLinkLimitEnabled *[]string `json:"filter[publicLinkLimitEnabled],omitempty"`

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// filter by id(s) of related 'builds'
	FilterBuilds *[]string `json:"filter[builds],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related betaTesters returned (when they are included)
	LimitBetaTesters *int `json:"limit[betaTesters],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`
}

// BetaGroupsCreateInstanceJSONBody defines parameters for BetaGroupsCreateInstance.
type BetaGroupsCreateInstanceJSONBody BetaGroupCreateRequest

// BetaGroupsGetInstanceParams defines parameters for BetaGroupsGetInstance.
type BetaGroupsGetInstanceParams struct {

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related betaTesters returned (when they are included)
	LimitBetaTesters *int `json:"limit[betaTesters],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`
}

// BetaGroupsUpdateInstanceJSONBody defines parameters for BetaGroupsUpdateInstance.
type BetaGroupsUpdateInstanceJSONBody BetaGroupUpdateRequest

// BetaGroupsAppGetToOneRelatedParams defines parameters for BetaGroupsAppGetToOneRelated.
type BetaGroupsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaGroupsBetaTestersGetToManyRelatedParams defines parameters for BetaGroupsBetaTestersGetToManyRelated.
type BetaGroupsBetaTestersGetToManyRelatedParams struct {

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaGroupsBuildsGetToManyRelatedParams defines parameters for BetaGroupsBuildsGetToManyRelated.
type BetaGroupsBuildsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaGroupsBetaTestersDeleteToManyRelationshipJSONBody defines parameters for BetaGroupsBetaTestersDeleteToManyRelationship.
type BetaGroupsBetaTestersDeleteToManyRelationshipJSONBody BetaGroupBetaTestersLinkagesRequest

// BetaGroupsBetaTestersGetToManyRelationshipParams defines parameters for BetaGroupsBetaTestersGetToManyRelationship.
type BetaGroupsBetaTestersGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaGroupsBetaTestersCreateToManyRelationshipJSONBody defines parameters for BetaGroupsBetaTestersCreateToManyRelationship.
type BetaGroupsBetaTestersCreateToManyRelationshipJSONBody BetaGroupBetaTestersLinkagesRequest

// BetaGroupsBuildsDeleteToManyRelationshipJSONBody defines parameters for BetaGroupsBuildsDeleteToManyRelationship.
type BetaGroupsBuildsDeleteToManyRelationshipJSONBody BetaGroupBuildsLinkagesRequest

// BetaGroupsBuildsGetToManyRelationshipParams defines parameters for BetaGroupsBuildsGetToManyRelationship.
type BetaGroupsBuildsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaGroupsBuildsCreateToManyRelationshipJSONBody defines parameters for BetaGroupsBuildsCreateToManyRelationship.
type BetaGroupsBuildsCreateToManyRelationshipJSONBody BetaGroupBuildsLinkagesRequest

// BetaLicenseAgreementsGetCollectionParams defines parameters for BetaLicenseAgreementsGetCollection.
type BetaLicenseAgreementsGetCollectionParams struct {

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// the fields to include for returned resources of type betaLicenseAgreements
	FieldsBetaLicenseAgreements *[]string `json:"fields[betaLicenseAgreements],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaLicenseAgreementsGetInstanceParams defines parameters for BetaLicenseAgreementsGetInstance.
type BetaLicenseAgreementsGetInstanceParams struct {

	// the fields to include for returned resources of type betaLicenseAgreements
	FieldsBetaLicenseAgreements *[]string `json:"fields[betaLicenseAgreements],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaLicenseAgreementsUpdateInstanceJSONBody defines parameters for BetaLicenseAgreementsUpdateInstance.
type BetaLicenseAgreementsUpdateInstanceJSONBody BetaLicenseAgreementUpdateRequest

// BetaLicenseAgreementsAppGetToOneRelatedParams defines parameters for BetaLicenseAgreementsAppGetToOneRelated.
type BetaLicenseAgreementsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BetaTesterInvitationsCreateInstanceJSONBody defines parameters for BetaTesterInvitationsCreateInstance.
type BetaTesterInvitationsCreateInstanceJSONBody BetaTesterInvitationCreateRequest

// BetaTestersGetCollectionParams defines parameters for BetaTestersGetCollection.
type BetaTestersGetCollectionParams struct {

	// filter by attribute 'email'
	FilterEmail *[]string `json:"filter[email],omitempty"`

	// filter by attribute 'firstName'
	FilterFirstName *[]string `json:"filter[firstName],omitempty"`

	// filter by attribute 'inviteType'
	FilterInviteType *[]string `json:"filter[inviteType],omitempty"`

	// filter by attribute 'lastName'
	FilterLastName *[]string `json:"filter[lastName],omitempty"`

	// filter by id(s) of related 'apps'
	FilterApps *[]string `json:"filter[apps],omitempty"`

	// filter by id(s) of related 'betaGroups'
	FilterBetaGroups *[]string `json:"filter[betaGroups],omitempty"`

	// filter by id(s) of related 'builds'
	FilterBuilds *[]string `json:"filter[builds],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related apps returned (when they are included)
	LimitApps *int `json:"limit[apps],omitempty"`

	// maximum number of related betaGroups returned (when they are included)
	LimitBetaGroups *int `json:"limit[betaGroups],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`
}

// BetaTestersCreateInstanceJSONBody defines parameters for BetaTestersCreateInstance.
type BetaTestersCreateInstanceJSONBody BetaTesterCreateRequest

// BetaTestersGetInstanceParams defines parameters for BetaTestersGetInstance.
type BetaTestersGetInstanceParams struct {

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related apps returned (when they are included)
	LimitApps *int `json:"limit[apps],omitempty"`

	// maximum number of related betaGroups returned (when they are included)
	LimitBetaGroups *int `json:"limit[betaGroups],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`
}

// BetaTestersAppsGetToManyRelatedParams defines parameters for BetaTestersAppsGetToManyRelated.
type BetaTestersAppsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaTestersBetaGroupsGetToManyRelatedParams defines parameters for BetaTestersBetaGroupsGetToManyRelated.
type BetaTestersBetaGroupsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type betaGroups
	FieldsBetaGroups *[]string `json:"fields[betaGroups],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaTestersBuildsGetToManyRelatedParams defines parameters for BetaTestersBuildsGetToManyRelated.
type BetaTestersBuildsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaTestersAppsDeleteToManyRelationshipJSONBody defines parameters for BetaTestersAppsDeleteToManyRelationship.
type BetaTestersAppsDeleteToManyRelationshipJSONBody BetaTesterAppsLinkagesRequest

// BetaTestersAppsGetToManyRelationshipParams defines parameters for BetaTestersAppsGetToManyRelationship.
type BetaTestersAppsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaTestersBetaGroupsDeleteToManyRelationshipJSONBody defines parameters for BetaTestersBetaGroupsDeleteToManyRelationship.
type BetaTestersBetaGroupsDeleteToManyRelationshipJSONBody BetaTesterBetaGroupsLinkagesRequest

// BetaTestersBetaGroupsGetToManyRelationshipParams defines parameters for BetaTestersBetaGroupsGetToManyRelationship.
type BetaTestersBetaGroupsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaTestersBetaGroupsCreateToManyRelationshipJSONBody defines parameters for BetaTestersBetaGroupsCreateToManyRelationship.
type BetaTestersBetaGroupsCreateToManyRelationshipJSONBody BetaTesterBetaGroupsLinkagesRequest

// BetaTestersBuildsDeleteToManyRelationshipJSONBody defines parameters for BetaTestersBuildsDeleteToManyRelationship.
type BetaTestersBuildsDeleteToManyRelationshipJSONBody BetaTesterBuildsLinkagesRequest

// BetaTestersBuildsGetToManyRelationshipParams defines parameters for BetaTestersBuildsGetToManyRelationship.
type BetaTestersBuildsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BetaTestersBuildsCreateToManyRelationshipJSONBody defines parameters for BetaTestersBuildsCreateToManyRelationship.
type BetaTestersBuildsCreateToManyRelationshipJSONBody BetaTesterBuildsLinkagesRequest

// BuildBetaDetailsGetCollectionParams defines parameters for BuildBetaDetailsGetCollection.
type BuildBetaDetailsGetCollectionParams struct {

	// filter by id(s) of related 'build'
	FilterBuild *[]string `json:"filter[build],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// the fields to include for returned resources of type buildBetaDetails
	FieldsBuildBetaDetails *[]string `json:"fields[buildBetaDetails],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BuildBetaDetailsGetInstanceParams defines parameters for BuildBetaDetailsGetInstance.
type BuildBetaDetailsGetInstanceParams struct {

	// the fields to include for returned resources of type buildBetaDetails
	FieldsBuildBetaDetails *[]string `json:"fields[buildBetaDetails],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BuildBetaDetailsUpdateInstanceJSONBody defines parameters for BuildBetaDetailsUpdateInstance.
type BuildBetaDetailsUpdateInstanceJSONBody BuildBetaDetailUpdateRequest

// BuildBetaDetailsBuildGetToOneRelatedParams defines parameters for BuildBetaDetailsBuildGetToOneRelated.
type BuildBetaDetailsBuildGetToOneRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`
}

// BuildBetaNotificationsCreateInstanceJSONBody defines parameters for BuildBetaNotificationsCreateInstance.
type BuildBetaNotificationsCreateInstanceJSONBody BuildBetaNotificationCreateRequest

// BuildsGetCollectionParams defines parameters for BuildsGetCollection.
type BuildsGetCollectionParams struct {

	// filter by attribute 'betaAppReviewSubmission.betaReviewState'
	FilterBetaAppReviewSubmissionBetaReviewState *[]string `json:"filter[betaAppReviewSubmission.betaReviewState],omitempty"`

	// filter by attribute 'expired'
	FilterExpired *[]string `json:"filter[expired],omitempty"`

	// filter by attribute 'preReleaseVersion.platform'
	FilterPreReleaseVersionPlatform *[]string `json:"filter[preReleaseVersion.platform],omitempty"`

	// filter by attribute 'preReleaseVersion.version'
	FilterPreReleaseVersionVersion *[]string `json:"filter[preReleaseVersion.version],omitempty"`

	// filter by attribute 'processingState'
	FilterProcessingState *[]string `json:"filter[processingState],omitempty"`

	// filter by attribute 'usesNonExemptEncryption'
	FilterUsesNonExemptEncryption *[]string `json:"filter[usesNonExemptEncryption],omitempty"`

	// filter by attribute 'version'
	FilterVersion *[]string `json:"filter[version],omitempty"`

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// filter by id(s) of related 'appStoreVersion'
	FilterAppStoreVersion *[]string `json:"filter[appStoreVersion],omitempty"`

	// filter by id(s) of related 'betaGroups'
	FilterBetaGroups *[]string `json:"filter[betaGroups],omitempty"`

	// filter by id(s) of related 'preReleaseVersion'
	FilterPreReleaseVersion *[]string `json:"filter[preReleaseVersion],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appEncryptionDeclarations
	FieldsAppEncryptionDeclarations *[]string `json:"fields[appEncryptionDeclarations],omitempty"`

	// the fields to include for returned resources of type betaAppReviewSubmissions
	FieldsBetaAppReviewSubmissions *[]string `json:"fields[betaAppReviewSubmissions],omitempty"`

	// the fields to include for returned resources of type buildBetaDetails
	FieldsBuildBetaDetails *[]string `json:"fields[buildBetaDetails],omitempty"`

	// the fields to include for returned resources of type buildIcons
	FieldsBuildIcons *[]string `json:"fields[buildIcons],omitempty"`

	// the fields to include for returned resources of type perfPowerMetrics
	FieldsPerfPowerMetrics *[]string `json:"fields[perfPowerMetrics],omitempty"`

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type diagnosticSignatures
	FieldsDiagnosticSignatures *[]string `json:"fields[diagnosticSignatures],omitempty"`

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// the fields to include for returned resources of type betaBuildLocalizations
	FieldsBetaBuildLocalizations *[]string `json:"fields[betaBuildLocalizations],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related betaBuildLocalizations returned (when they are included)
	LimitBetaBuildLocalizations *int `json:"limit[betaBuildLocalizations],omitempty"`

	// maximum number of related icons returned (when they are included)
	LimitIcons *int `json:"limit[icons],omitempty"`

	// maximum number of related individualTesters returned (when they are included)
	LimitIndividualTesters *int `json:"limit[individualTesters],omitempty"`
}

// BuildsGetInstanceParams defines parameters for BuildsGetInstance.
type BuildsGetInstanceParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type appEncryptionDeclarations
	FieldsAppEncryptionDeclarations *[]string `json:"fields[appEncryptionDeclarations],omitempty"`

	// the fields to include for returned resources of type betaAppReviewSubmissions
	FieldsBetaAppReviewSubmissions *[]string `json:"fields[betaAppReviewSubmissions],omitempty"`

	// the fields to include for returned resources of type buildBetaDetails
	FieldsBuildBetaDetails *[]string `json:"fields[buildBetaDetails],omitempty"`

	// the fields to include for returned resources of type buildIcons
	FieldsBuildIcons *[]string `json:"fields[buildIcons],omitempty"`

	// the fields to include for returned resources of type perfPowerMetrics
	FieldsPerfPowerMetrics *[]string `json:"fields[perfPowerMetrics],omitempty"`

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`

	// the fields to include for returned resources of type diagnosticSignatures
	FieldsDiagnosticSignatures *[]string `json:"fields[diagnosticSignatures],omitempty"`

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// the fields to include for returned resources of type betaBuildLocalizations
	FieldsBetaBuildLocalizations *[]string `json:"fields[betaBuildLocalizations],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related betaBuildLocalizations returned (when they are included)
	LimitBetaBuildLocalizations *int `json:"limit[betaBuildLocalizations],omitempty"`

	// maximum number of related icons returned (when they are included)
	LimitIcons *int `json:"limit[icons],omitempty"`

	// maximum number of related individualTesters returned (when they are included)
	LimitIndividualTesters *int `json:"limit[individualTesters],omitempty"`
}

// BuildsUpdateInstanceJSONBody defines parameters for BuildsUpdateInstance.
type BuildsUpdateInstanceJSONBody BuildUpdateRequest

// BuildsAppGetToOneRelatedParams defines parameters for BuildsAppGetToOneRelated.
type BuildsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BuildsAppEncryptionDeclarationGetToOneRelatedParams defines parameters for BuildsAppEncryptionDeclarationGetToOneRelated.
type BuildsAppEncryptionDeclarationGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appEncryptionDeclarations
	FieldsAppEncryptionDeclarations *[]string `json:"fields[appEncryptionDeclarations],omitempty"`
}

// BuildsAppStoreVersionGetToOneRelatedParams defines parameters for BuildsAppStoreVersionGetToOneRelated.
type BuildsAppStoreVersionGetToOneRelatedParams struct {

	// the fields to include for returned resources of type appStoreVersions
	FieldsAppStoreVersions *[]string `json:"fields[appStoreVersions],omitempty"`
}

// BuildsBetaAppReviewSubmissionGetToOneRelatedParams defines parameters for BuildsBetaAppReviewSubmissionGetToOneRelated.
type BuildsBetaAppReviewSubmissionGetToOneRelatedParams struct {

	// the fields to include for returned resources of type betaAppReviewSubmissions
	FieldsBetaAppReviewSubmissions *[]string `json:"fields[betaAppReviewSubmissions],omitempty"`
}

// BuildsBetaBuildLocalizationsGetToManyRelatedParams defines parameters for BuildsBetaBuildLocalizationsGetToManyRelated.
type BuildsBetaBuildLocalizationsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type betaBuildLocalizations
	FieldsBetaBuildLocalizations *[]string `json:"fields[betaBuildLocalizations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BuildsBuildBetaDetailGetToOneRelatedParams defines parameters for BuildsBuildBetaDetailGetToOneRelated.
type BuildsBuildBetaDetailGetToOneRelatedParams struct {

	// the fields to include for returned resources of type buildBetaDetails
	FieldsBuildBetaDetails *[]string `json:"fields[buildBetaDetails],omitempty"`
}

// BuildsDiagnosticSignaturesGetToManyRelatedParams defines parameters for BuildsDiagnosticSignaturesGetToManyRelated.
type BuildsDiagnosticSignaturesGetToManyRelatedParams struct {

	// filter by attribute 'diagnosticType'
	FilterDiagnosticType *[]string `json:"filter[diagnosticType],omitempty"`

	// the fields to include for returned resources of type diagnosticSignatures
	FieldsDiagnosticSignatures *[]string `json:"fields[diagnosticSignatures],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BuildsIconsGetToManyRelatedParams defines parameters for BuildsIconsGetToManyRelated.
type BuildsIconsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type buildIcons
	FieldsBuildIcons *[]string `json:"fields[buildIcons],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BuildsIndividualTestersGetToManyRelatedParams defines parameters for BuildsIndividualTestersGetToManyRelated.
type BuildsIndividualTestersGetToManyRelatedParams struct {

	// the fields to include for returned resources of type betaTesters
	FieldsBetaTesters *[]string `json:"fields[betaTesters],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BuildsPerfPowerMetricsGetToManyRelatedParams defines parameters for BuildsPerfPowerMetricsGetToManyRelated.
type BuildsPerfPowerMetricsGetToManyRelatedParams struct {

	// filter by attribute 'deviceType'
	FilterDeviceType *[]string `json:"filter[deviceType],omitempty"`

	// filter by attribute 'metricType'
	FilterMetricType *[]string `json:"filter[metricType],omitempty"`

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`
}

// BuildsPreReleaseVersionGetToOneRelatedParams defines parameters for BuildsPreReleaseVersionGetToOneRelated.
type BuildsPreReleaseVersionGetToOneRelatedParams struct {

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`
}

// BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONBody defines parameters for BuildsAppEncryptionDeclarationUpdateToOneRelationship.
type BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONBody BuildAppEncryptionDeclarationLinkageRequest

// BuildsBetaGroupsDeleteToManyRelationshipJSONBody defines parameters for BuildsBetaGroupsDeleteToManyRelationship.
type BuildsBetaGroupsDeleteToManyRelationshipJSONBody BuildBetaGroupsLinkagesRequest

// BuildsBetaGroupsCreateToManyRelationshipJSONBody defines parameters for BuildsBetaGroupsCreateToManyRelationship.
type BuildsBetaGroupsCreateToManyRelationshipJSONBody BuildBetaGroupsLinkagesRequest

// BuildsIndividualTestersDeleteToManyRelationshipJSONBody defines parameters for BuildsIndividualTestersDeleteToManyRelationship.
type BuildsIndividualTestersDeleteToManyRelationshipJSONBody BuildIndividualTestersLinkagesRequest

// BuildsIndividualTestersGetToManyRelationshipParams defines parameters for BuildsIndividualTestersGetToManyRelationship.
type BuildsIndividualTestersGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BuildsIndividualTestersCreateToManyRelationshipJSONBody defines parameters for BuildsIndividualTestersCreateToManyRelationship.
type BuildsIndividualTestersCreateToManyRelationshipJSONBody BuildIndividualTestersLinkagesRequest

// BundleIdCapabilitiesCreateInstanceJSONBody defines parameters for BundleIdCapabilitiesCreateInstance.
type BundleIdCapabilitiesCreateInstanceJSONBody BundleIdCapabilityCreateRequest

// BundleIdCapabilitiesUpdateInstanceJSONBody defines parameters for BundleIdCapabilitiesUpdateInstance.
type BundleIdCapabilitiesUpdateInstanceJSONBody BundleIdCapabilityUpdateRequest

// BundleIdsGetCollectionParams defines parameters for BundleIdsGetCollection.
type BundleIdsGetCollectionParams struct {

	// filter by attribute 'identifier'
	FilterIdentifier *[]string `json:"filter[identifier],omitempty"`

	// filter by attribute 'name'
	FilterName *[]string `json:"filter[name],omitempty"`

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by attribute 'seedId'
	FilterSeedId *[]string `json:"filter[seedId],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type bundleIds
	FieldsBundleIds *[]string `json:"fields[bundleIds],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type bundleIdCapabilities
	FieldsBundleIdCapabilities *[]string `json:"fields[bundleIdCapabilities],omitempty"`

	// the fields to include for returned resources of type profiles
	FieldsProfiles *[]string `json:"fields[profiles],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related bundleIdCapabilities returned (when they are included)
	LimitBundleIdCapabilities *int `json:"limit[bundleIdCapabilities],omitempty"`

	// maximum number of related profiles returned (when they are included)
	LimitProfiles *int `json:"limit[profiles],omitempty"`
}

// BundleIdsCreateInstanceJSONBody defines parameters for BundleIdsCreateInstance.
type BundleIdsCreateInstanceJSONBody BundleIdCreateRequest

// BundleIdsGetInstanceParams defines parameters for BundleIdsGetInstance.
type BundleIdsGetInstanceParams struct {

	// the fields to include for returned resources of type bundleIds
	FieldsBundleIds *[]string `json:"fields[bundleIds],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type bundleIdCapabilities
	FieldsBundleIdCapabilities *[]string `json:"fields[bundleIdCapabilities],omitempty"`

	// the fields to include for returned resources of type profiles
	FieldsProfiles *[]string `json:"fields[profiles],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related bundleIdCapabilities returned (when they are included)
	LimitBundleIdCapabilities *int `json:"limit[bundleIdCapabilities],omitempty"`

	// maximum number of related profiles returned (when they are included)
	LimitProfiles *int `json:"limit[profiles],omitempty"`
}

// BundleIdsUpdateInstanceJSONBody defines parameters for BundleIdsUpdateInstance.
type BundleIdsUpdateInstanceJSONBody BundleIdUpdateRequest

// BundleIdsAppGetToOneRelatedParams defines parameters for BundleIdsAppGetToOneRelated.
type BundleIdsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// BundleIdsBundleIdCapabilitiesGetToManyRelatedParams defines parameters for BundleIdsBundleIdCapabilitiesGetToManyRelated.
type BundleIdsBundleIdCapabilitiesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type bundleIdCapabilities
	FieldsBundleIdCapabilities *[]string `json:"fields[bundleIdCapabilities],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// BundleIdsProfilesGetToManyRelatedParams defines parameters for BundleIdsProfilesGetToManyRelated.
type BundleIdsProfilesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type profiles
	FieldsProfiles *[]string `json:"fields[profiles],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// CertificatesGetCollectionParams defines parameters for CertificatesGetCollection.
type CertificatesGetCollectionParams struct {

	// filter by attribute 'certificateType'
	FilterCertificateType *[]string `json:"filter[certificateType],omitempty"`

	// filter by attribute 'displayName'
	FilterDisplayName *[]string `json:"filter[displayName],omitempty"`

	// filter by attribute 'serialNumber'
	FilterSerialNumber *[]string `json:"filter[serialNumber],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type certificates
	FieldsCertificates *[]string `json:"fields[certificates],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// CertificatesCreateInstanceJSONBody defines parameters for CertificatesCreateInstance.
type CertificatesCreateInstanceJSONBody CertificateCreateRequest

// CertificatesGetInstanceParams defines parameters for CertificatesGetInstance.
type CertificatesGetInstanceParams struct {

	// the fields to include for returned resources of type certificates
	FieldsCertificates *[]string `json:"fields[certificates],omitempty"`
}

// DevicesGetCollectionParams defines parameters for DevicesGetCollection.
type DevicesGetCollectionParams struct {

	// filter by attribute 'name'
	FilterName *[]string `json:"filter[name],omitempty"`

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by attribute 'status'
	FilterStatus *[]string `json:"filter[status],omitempty"`

	// filter by attribute 'udid'
	FilterUdid *[]string `json:"filter[udid],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type devices
	FieldsDevices *[]string `json:"fields[devices],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// DevicesCreateInstanceJSONBody defines parameters for DevicesCreateInstance.
type DevicesCreateInstanceJSONBody DeviceCreateRequest

// DevicesGetInstanceParams defines parameters for DevicesGetInstance.
type DevicesGetInstanceParams struct {

	// the fields to include for returned resources of type devices
	FieldsDevices *[]string `json:"fields[devices],omitempty"`
}

// DevicesUpdateInstanceJSONBody defines parameters for DevicesUpdateInstance.
type DevicesUpdateInstanceJSONBody DeviceUpdateRequest

// DiagnosticSignaturesLogsGetToManyRelatedParams defines parameters for DiagnosticSignaturesLogsGetToManyRelated.
type DiagnosticSignaturesLogsGetToManyRelatedParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// EndUserLicenseAgreementsCreateInstanceJSONBody defines parameters for EndUserLicenseAgreementsCreateInstance.
type EndUserLicenseAgreementsCreateInstanceJSONBody EndUserLicenseAgreementCreateRequest

// EndUserLicenseAgreementsGetInstanceParams defines parameters for EndUserLicenseAgreementsGetInstance.
type EndUserLicenseAgreementsGetInstanceParams struct {

	// the fields to include for returned resources of type endUserLicenseAgreements
	FieldsEndUserLicenseAgreements *[]string `json:"fields[endUserLicenseAgreements],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`

	// maximum number of related territories returned (when they are included)
	LimitTerritories *int `json:"limit[territories],omitempty"`
}

// EndUserLicenseAgreementsUpdateInstanceJSONBody defines parameters for EndUserLicenseAgreementsUpdateInstance.
type EndUserLicenseAgreementsUpdateInstanceJSONBody EndUserLicenseAgreementUpdateRequest

// EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams defines parameters for EndUserLicenseAgreementsTerritoriesGetToManyRelated.
type EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// FinanceReportsGetCollectionParams defines parameters for FinanceReportsGetCollection.
type FinanceReportsGetCollectionParams struct {

	// filter by attribute 'regionCode'
	FilterRegionCode []string `json:"filter[regionCode]"`

	// filter by attribute 'reportDate'
	FilterReportDate []string `json:"filter[reportDate]"`

	// filter by attribute 'reportType'
	FilterReportType []string `json:"filter[reportType]"`

	// filter by attribute 'vendorNumber'
	FilterVendorNumber []string `json:"filter[vendorNumber]"`
}

// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams defines parameters for GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated.
type GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams struct {

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by attribute 'versionString'
	FilterVersionString *[]string `json:"filter[versionString],omitempty"`

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type gameCenterEnabledVersions
	FieldsGameCenterEnabledVersions *[]string `json:"fields[gameCenterEnabledVersions],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONBody defines parameters for GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship.
type GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONBody GameCenterEnabledVersionCompatibleVersionsLinkagesRequest

// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams defines parameters for GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship.
type GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONBody defines parameters for GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship.
type GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONBody GameCenterEnabledVersionCompatibleVersionsLinkagesRequest

// GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONBody defines parameters for GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship.
type GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONBody GameCenterEnabledVersionCompatibleVersionsLinkagesRequest

// IdfaDeclarationsCreateInstanceJSONBody defines parameters for IdfaDeclarationsCreateInstance.
type IdfaDeclarationsCreateInstanceJSONBody IdfaDeclarationCreateRequest

// IdfaDeclarationsUpdateInstanceJSONBody defines parameters for IdfaDeclarationsUpdateInstance.
type IdfaDeclarationsUpdateInstanceJSONBody IdfaDeclarationUpdateRequest

// InAppPurchasesGetInstanceParams defines parameters for InAppPurchasesGetInstance.
type InAppPurchasesGetInstanceParams struct {

	// the fields to include for returned resources of type inAppPurchases
	FieldsInAppPurchases *[]string `json:"fields[inAppPurchases],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// maximum number of related apps returned (when they are included)
	LimitApps *int `json:"limit[apps],omitempty"`
}

// PreReleaseVersionsGetCollectionParams defines parameters for PreReleaseVersionsGetCollection.
type PreReleaseVersionsGetCollectionParams struct {

	// filter by attribute 'builds.expired'
	FilterBuildsExpired *[]string `json:"filter[builds.expired],omitempty"`

	// filter by attribute 'builds.processingState'
	FilterBuildsProcessingState *[]string `json:"filter[builds.processingState],omitempty"`

	// filter by attribute 'platform'
	FilterPlatform *[]string `json:"filter[platform],omitempty"`

	// filter by attribute 'version'
	FilterVersion *[]string `json:"filter[version],omitempty"`

	// filter by id(s) of related 'app'
	FilterApp *[]string `json:"filter[app],omitempty"`

	// filter by id(s) of related 'builds'
	FilterBuilds *[]string `json:"filter[builds],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`
}

// PreReleaseVersionsGetInstanceParams defines parameters for PreReleaseVersionsGetInstance.
type PreReleaseVersionsGetInstanceParams struct {

	// the fields to include for returned resources of type preReleaseVersions
	FieldsPreReleaseVersions *[]string `json:"fields[preReleaseVersions],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related builds returned (when they are included)
	LimitBuilds *int `json:"limit[builds],omitempty"`
}

// PreReleaseVersionsAppGetToOneRelatedParams defines parameters for PreReleaseVersionsAppGetToOneRelated.
type PreReleaseVersionsAppGetToOneRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`
}

// PreReleaseVersionsBuildsGetToManyRelatedParams defines parameters for PreReleaseVersionsBuildsGetToManyRelated.
type PreReleaseVersionsBuildsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type builds
	FieldsBuilds *[]string `json:"fields[builds],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// ProfilesGetCollectionParams defines parameters for ProfilesGetCollection.
type ProfilesGetCollectionParams struct {

	// filter by attribute 'name'
	FilterName *[]string `json:"filter[name],omitempty"`

	// filter by attribute 'profileState'
	FilterProfileState *[]string `json:"filter[profileState],omitempty"`

	// filter by attribute 'profileType'
	FilterProfileType *[]string `json:"filter[profileType],omitempty"`

	// filter by id(s)
	FilterId *[]string `json:"filter[id],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type profiles
	FieldsProfiles *[]string `json:"fields[profiles],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type certificates
	FieldsCertificates *[]string `json:"fields[certificates],omitempty"`

	// the fields to include for returned resources of type devices
	FieldsDevices *[]string `json:"fields[devices],omitempty"`

	// the fields to include for returned resources of type bundleIds
	FieldsBundleIds *[]string `json:"fields[bundleIds],omitempty"`

	// maximum number of related certificates returned (when they are included)
	LimitCertificates *int `json:"limit[certificates],omitempty"`

	// maximum number of related devices returned (when they are included)
	LimitDevices *int `json:"limit[devices],omitempty"`
}

// ProfilesCreateInstanceJSONBody defines parameters for ProfilesCreateInstance.
type ProfilesCreateInstanceJSONBody ProfileCreateRequest

// ProfilesGetInstanceParams defines parameters for ProfilesGetInstance.
type ProfilesGetInstanceParams struct {

	// the fields to include for returned resources of type profiles
	FieldsProfiles *[]string `json:"fields[profiles],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type certificates
	FieldsCertificates *[]string `json:"fields[certificates],omitempty"`

	// the fields to include for returned resources of type devices
	FieldsDevices *[]string `json:"fields[devices],omitempty"`

	// the fields to include for returned resources of type bundleIds
	FieldsBundleIds *[]string `json:"fields[bundleIds],omitempty"`

	// maximum number of related certificates returned (when they are included)
	LimitCertificates *int `json:"limit[certificates],omitempty"`

	// maximum number of related devices returned (when they are included)
	LimitDevices *int `json:"limit[devices],omitempty"`
}

// ProfilesBundleIdGetToOneRelatedParams defines parameters for ProfilesBundleIdGetToOneRelated.
type ProfilesBundleIdGetToOneRelatedParams struct {

	// the fields to include for returned resources of type bundleIds
	FieldsBundleIds *[]string `json:"fields[bundleIds],omitempty"`
}

// ProfilesCertificatesGetToManyRelatedParams defines parameters for ProfilesCertificatesGetToManyRelated.
type ProfilesCertificatesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type certificates
	FieldsCertificates *[]string `json:"fields[certificates],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// ProfilesDevicesGetToManyRelatedParams defines parameters for ProfilesDevicesGetToManyRelated.
type ProfilesDevicesGetToManyRelatedParams struct {

	// the fields to include for returned resources of type devices
	FieldsDevices *[]string `json:"fields[devices],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// RoutingAppCoveragesCreateInstanceJSONBody defines parameters for RoutingAppCoveragesCreateInstance.
type RoutingAppCoveragesCreateInstanceJSONBody RoutingAppCoverageCreateRequest

// RoutingAppCoveragesGetInstanceParams defines parameters for RoutingAppCoveragesGetInstance.
type RoutingAppCoveragesGetInstanceParams struct {

	// the fields to include for returned resources of type routingAppCoverages
	FieldsRoutingAppCoverages *[]string `json:"fields[routingAppCoverages],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`
}

// RoutingAppCoveragesUpdateInstanceJSONBody defines parameters for RoutingAppCoveragesUpdateInstance.
type RoutingAppCoveragesUpdateInstanceJSONBody RoutingAppCoverageUpdateRequest

// SalesReportsGetCollectionParams defines parameters for SalesReportsGetCollection.
type SalesReportsGetCollectionParams struct {

	// filter by attribute 'frequency'
	FilterFrequency []string `json:"filter[frequency]"`

	// filter by attribute 'reportDate'
	FilterReportDate *[]string `json:"filter[reportDate],omitempty"`

	// filter by attribute 'reportSubType'
	FilterReportSubType []string `json:"filter[reportSubType]"`

	// filter by attribute 'reportType'
	FilterReportType []string `json:"filter[reportType]"`

	// filter by attribute 'vendorNumber'
	FilterVendorNumber []string `json:"filter[vendorNumber]"`

	// filter by attribute 'version'
	FilterVersion *[]string `json:"filter[version],omitempty"`
}

// TerritoriesGetCollectionParams defines parameters for TerritoriesGetCollection.
type TerritoriesGetCollectionParams struct {

	// the fields to include for returned resources of type territories
	FieldsTerritories *[]string `json:"fields[territories],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// UserInvitationsGetCollectionParams defines parameters for UserInvitationsGetCollection.
type UserInvitationsGetCollectionParams struct {

	// filter by attribute 'email'
	FilterEmail *[]string `json:"filter[email],omitempty"`

	// filter by attribute 'roles'
	FilterRoles *[]string `json:"filter[roles],omitempty"`

	// filter by id(s) of related 'visibleApps'
	FilterVisibleApps *[]string `json:"filter[visibleApps],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type userInvitations
	FieldsUserInvitations *[]string `json:"fields[userInvitations],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related visibleApps returned (when they are included)
	LimitVisibleApps *int `json:"limit[visibleApps],omitempty"`
}

// UserInvitationsCreateInstanceJSONBody defines parameters for UserInvitationsCreateInstance.
type UserInvitationsCreateInstanceJSONBody UserInvitationCreateRequest

// UserInvitationsGetInstanceParams defines parameters for UserInvitationsGetInstance.
type UserInvitationsGetInstanceParams struct {

	// the fields to include for returned resources of type userInvitations
	FieldsUserInvitations *[]string `json:"fields[userInvitations],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related visibleApps returned (when they are included)
	LimitVisibleApps *int `json:"limit[visibleApps],omitempty"`
}

// UserInvitationsVisibleAppsGetToManyRelatedParams defines parameters for UserInvitationsVisibleAppsGetToManyRelated.
type UserInvitationsVisibleAppsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// UsersGetCollectionParams defines parameters for UsersGetCollection.
type UsersGetCollectionParams struct {

	// filter by attribute 'roles'
	FilterRoles *[]string `json:"filter[roles],omitempty"`

	// filter by attribute 'username'
	FilterUsername *[]string `json:"filter[username],omitempty"`

	// filter by id(s) of related 'visibleApps'
	FilterVisibleApps *[]string `json:"filter[visibleApps],omitempty"`

	// comma-separated list of sort expressions; resources will be sorted as specified
	Sort *[]string `json:"sort,omitempty"`

	// the fields to include for returned resources of type users
	FieldsUsers *[]string `json:"fields[users],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related visibleApps returned (when they are included)
	LimitVisibleApps *int `json:"limit[visibleApps],omitempty"`
}

// UsersGetInstanceParams defines parameters for UsersGetInstance.
type UsersGetInstanceParams struct {

	// the fields to include for returned resources of type users
	FieldsUsers *[]string `json:"fields[users],omitempty"`

	// comma-separated list of relationships to include
	Include *[]string `json:"include,omitempty"`

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum number of related visibleApps returned (when they are included)
	LimitVisibleApps *int `json:"limit[visibleApps],omitempty"`
}

// UsersUpdateInstanceJSONBody defines parameters for UsersUpdateInstance.
type UsersUpdateInstanceJSONBody UserUpdateRequest

// UsersVisibleAppsDeleteToManyRelationshipJSONBody defines parameters for UsersVisibleAppsDeleteToManyRelationship.
type UsersVisibleAppsDeleteToManyRelationshipJSONBody UserVisibleAppsLinkagesRequest

// UsersVisibleAppsGetToManyRelationshipParams defines parameters for UsersVisibleAppsGetToManyRelationship.
type UsersVisibleAppsGetToManyRelationshipParams struct {

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// UsersVisibleAppsReplaceToManyRelationshipJSONBody defines parameters for UsersVisibleAppsReplaceToManyRelationship.
type UsersVisibleAppsReplaceToManyRelationshipJSONBody UserVisibleAppsLinkagesRequest

// UsersVisibleAppsCreateToManyRelationshipJSONBody defines parameters for UsersVisibleAppsCreateToManyRelationship.
type UsersVisibleAppsCreateToManyRelationshipJSONBody UserVisibleAppsLinkagesRequest

// UsersVisibleAppsGetToManyRelatedParams defines parameters for UsersVisibleAppsGetToManyRelated.
type UsersVisibleAppsGetToManyRelatedParams struct {

	// the fields to include for returned resources of type apps
	FieldsApps *[]string `json:"fields[apps],omitempty"`

	// maximum resources per page
	Limit *int `json:"limit,omitempty"`
}

// AgeRatingDeclarationsUpdateInstanceRequestBody defines body for AgeRatingDeclarationsUpdateInstance for application/json ContentType.
type AgeRatingDeclarationsUpdateInstanceJSONRequestBody AgeRatingDeclarationsUpdateInstanceJSONBody

// AppEncryptionDeclarationsBuildsCreateToManyRelationshipRequestBody defines body for AppEncryptionDeclarationsBuildsCreateToManyRelationship for application/json ContentType.
type AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONRequestBody AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONBody

// AppInfoLocalizationsCreateInstanceRequestBody defines body for AppInfoLocalizationsCreateInstance for application/json ContentType.
type AppInfoLocalizationsCreateInstanceJSONRequestBody AppInfoLocalizationsCreateInstanceJSONBody

// AppInfoLocalizationsUpdateInstanceRequestBody defines body for AppInfoLocalizationsUpdateInstance for application/json ContentType.
type AppInfoLocalizationsUpdateInstanceJSONRequestBody AppInfoLocalizationsUpdateInstanceJSONBody

// AppInfosUpdateInstanceRequestBody defines body for AppInfosUpdateInstance for application/json ContentType.
type AppInfosUpdateInstanceJSONRequestBody AppInfosUpdateInstanceJSONBody

// AppPreOrdersCreateInstanceRequestBody defines body for AppPreOrdersCreateInstance for application/json ContentType.
type AppPreOrdersCreateInstanceJSONRequestBody AppPreOrdersCreateInstanceJSONBody

// AppPreOrdersUpdateInstanceRequestBody defines body for AppPreOrdersUpdateInstance for application/json ContentType.
type AppPreOrdersUpdateInstanceJSONRequestBody AppPreOrdersUpdateInstanceJSONBody

// AppPreviewSetsCreateInstanceRequestBody defines body for AppPreviewSetsCreateInstance for application/json ContentType.
type AppPreviewSetsCreateInstanceJSONRequestBody AppPreviewSetsCreateInstanceJSONBody

// AppPreviewSetsAppPreviewsReplaceToManyRelationshipRequestBody defines body for AppPreviewSetsAppPreviewsReplaceToManyRelationship for application/json ContentType.
type AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONRequestBody AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONBody

// AppPreviewsCreateInstanceRequestBody defines body for AppPreviewsCreateInstance for application/json ContentType.
type AppPreviewsCreateInstanceJSONRequestBody AppPreviewsCreateInstanceJSONBody

// AppPreviewsUpdateInstanceRequestBody defines body for AppPreviewsUpdateInstance for application/json ContentType.
type AppPreviewsUpdateInstanceJSONRequestBody AppPreviewsUpdateInstanceJSONBody

// AppScreenshotSetsCreateInstanceRequestBody defines body for AppScreenshotSetsCreateInstance for application/json ContentType.
type AppScreenshotSetsCreateInstanceJSONRequestBody AppScreenshotSetsCreateInstanceJSONBody

// AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequestBody defines body for AppScreenshotSetsAppScreenshotsReplaceToManyRelationship for application/json ContentType.
type AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONRequestBody AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONBody

// AppScreenshotsCreateInstanceRequestBody defines body for AppScreenshotsCreateInstance for application/json ContentType.
type AppScreenshotsCreateInstanceJSONRequestBody AppScreenshotsCreateInstanceJSONBody

// AppScreenshotsUpdateInstanceRequestBody defines body for AppScreenshotsUpdateInstance for application/json ContentType.
type AppScreenshotsUpdateInstanceJSONRequestBody AppScreenshotsUpdateInstanceJSONBody

// AppStoreReviewAttachmentsCreateInstanceRequestBody defines body for AppStoreReviewAttachmentsCreateInstance for application/json ContentType.
type AppStoreReviewAttachmentsCreateInstanceJSONRequestBody AppStoreReviewAttachmentsCreateInstanceJSONBody

// AppStoreReviewAttachmentsUpdateInstanceRequestBody defines body for AppStoreReviewAttachmentsUpdateInstance for application/json ContentType.
type AppStoreReviewAttachmentsUpdateInstanceJSONRequestBody AppStoreReviewAttachmentsUpdateInstanceJSONBody

// AppStoreReviewDetailsCreateInstanceRequestBody defines body for AppStoreReviewDetailsCreateInstance for application/json ContentType.
type AppStoreReviewDetailsCreateInstanceJSONRequestBody AppStoreReviewDetailsCreateInstanceJSONBody

// AppStoreReviewDetailsUpdateInstanceRequestBody defines body for AppStoreReviewDetailsUpdateInstance for application/json ContentType.
type AppStoreReviewDetailsUpdateInstanceJSONRequestBody AppStoreReviewDetailsUpdateInstanceJSONBody

// AppStoreVersionLocalizationsCreateInstanceRequestBody defines body for AppStoreVersionLocalizationsCreateInstance for application/json ContentType.
type AppStoreVersionLocalizationsCreateInstanceJSONRequestBody AppStoreVersionLocalizationsCreateInstanceJSONBody

// AppStoreVersionLocalizationsUpdateInstanceRequestBody defines body for AppStoreVersionLocalizationsUpdateInstance for application/json ContentType.
type AppStoreVersionLocalizationsUpdateInstanceJSONRequestBody AppStoreVersionLocalizationsUpdateInstanceJSONBody

// AppStoreVersionPhasedReleasesCreateInstanceRequestBody defines body for AppStoreVersionPhasedReleasesCreateInstance for application/json ContentType.
type AppStoreVersionPhasedReleasesCreateInstanceJSONRequestBody AppStoreVersionPhasedReleasesCreateInstanceJSONBody

// AppStoreVersionPhasedReleasesUpdateInstanceRequestBody defines body for AppStoreVersionPhasedReleasesUpdateInstance for application/json ContentType.
type AppStoreVersionPhasedReleasesUpdateInstanceJSONRequestBody AppStoreVersionPhasedReleasesUpdateInstanceJSONBody

// AppStoreVersionSubmissionsCreateInstanceRequestBody defines body for AppStoreVersionSubmissionsCreateInstance for application/json ContentType.
type AppStoreVersionSubmissionsCreateInstanceJSONRequestBody AppStoreVersionSubmissionsCreateInstanceJSONBody

// AppStoreVersionsCreateInstanceRequestBody defines body for AppStoreVersionsCreateInstance for application/json ContentType.
type AppStoreVersionsCreateInstanceJSONRequestBody AppStoreVersionsCreateInstanceJSONBody

// AppStoreVersionsUpdateInstanceRequestBody defines body for AppStoreVersionsUpdateInstance for application/json ContentType.
type AppStoreVersionsUpdateInstanceJSONRequestBody AppStoreVersionsUpdateInstanceJSONBody

// AppStoreVersionsBuildUpdateToOneRelationshipRequestBody defines body for AppStoreVersionsBuildUpdateToOneRelationship for application/json ContentType.
type AppStoreVersionsBuildUpdateToOneRelationshipJSONRequestBody AppStoreVersionsBuildUpdateToOneRelationshipJSONBody

// AppsUpdateInstanceRequestBody defines body for AppsUpdateInstance for application/json ContentType.
type AppsUpdateInstanceJSONRequestBody AppsUpdateInstanceJSONBody

// AppsBetaTestersDeleteToManyRelationshipRequestBody defines body for AppsBetaTestersDeleteToManyRelationship for application/json ContentType.
type AppsBetaTestersDeleteToManyRelationshipJSONRequestBody AppsBetaTestersDeleteToManyRelationshipJSONBody

// BetaAppLocalizationsCreateInstanceRequestBody defines body for BetaAppLocalizationsCreateInstance for application/json ContentType.
type BetaAppLocalizationsCreateInstanceJSONRequestBody BetaAppLocalizationsCreateInstanceJSONBody

// BetaAppLocalizationsUpdateInstanceRequestBody defines body for BetaAppLocalizationsUpdateInstance for application/json ContentType.
type BetaAppLocalizationsUpdateInstanceJSONRequestBody BetaAppLocalizationsUpdateInstanceJSONBody

// BetaAppReviewDetailsUpdateInstanceRequestBody defines body for BetaAppReviewDetailsUpdateInstance for application/json ContentType.
type BetaAppReviewDetailsUpdateInstanceJSONRequestBody BetaAppReviewDetailsUpdateInstanceJSONBody

// BetaAppReviewSubmissionsCreateInstanceRequestBody defines body for BetaAppReviewSubmissionsCreateInstance for application/json ContentType.
type BetaAppReviewSubmissionsCreateInstanceJSONRequestBody BetaAppReviewSubmissionsCreateInstanceJSONBody

// BetaBuildLocalizationsCreateInstanceRequestBody defines body for BetaBuildLocalizationsCreateInstance for application/json ContentType.
type BetaBuildLocalizationsCreateInstanceJSONRequestBody BetaBuildLocalizationsCreateInstanceJSONBody

// BetaBuildLocalizationsUpdateInstanceRequestBody defines body for BetaBuildLocalizationsUpdateInstance for application/json ContentType.
type BetaBuildLocalizationsUpdateInstanceJSONRequestBody BetaBuildLocalizationsUpdateInstanceJSONBody

// BetaGroupsCreateInstanceRequestBody defines body for BetaGroupsCreateInstance for application/json ContentType.
type BetaGroupsCreateInstanceJSONRequestBody BetaGroupsCreateInstanceJSONBody

// BetaGroupsUpdateInstanceRequestBody defines body for BetaGroupsUpdateInstance for application/json ContentType.
type BetaGroupsUpdateInstanceJSONRequestBody BetaGroupsUpdateInstanceJSONBody

// BetaGroupsBetaTestersDeleteToManyRelationshipRequestBody defines body for BetaGroupsBetaTestersDeleteToManyRelationship for application/json ContentType.
type BetaGroupsBetaTestersDeleteToManyRelationshipJSONRequestBody BetaGroupsBetaTestersDeleteToManyRelationshipJSONBody

// BetaGroupsBetaTestersCreateToManyRelationshipRequestBody defines body for BetaGroupsBetaTestersCreateToManyRelationship for application/json ContentType.
type BetaGroupsBetaTestersCreateToManyRelationshipJSONRequestBody BetaGroupsBetaTestersCreateToManyRelationshipJSONBody

// BetaGroupsBuildsDeleteToManyRelationshipRequestBody defines body for BetaGroupsBuildsDeleteToManyRelationship for application/json ContentType.
type BetaGroupsBuildsDeleteToManyRelationshipJSONRequestBody BetaGroupsBuildsDeleteToManyRelationshipJSONBody

// BetaGroupsBuildsCreateToManyRelationshipRequestBody defines body for BetaGroupsBuildsCreateToManyRelationship for application/json ContentType.
type BetaGroupsBuildsCreateToManyRelationshipJSONRequestBody BetaGroupsBuildsCreateToManyRelationshipJSONBody

// BetaLicenseAgreementsUpdateInstanceRequestBody defines body for BetaLicenseAgreementsUpdateInstance for application/json ContentType.
type BetaLicenseAgreementsUpdateInstanceJSONRequestBody BetaLicenseAgreementsUpdateInstanceJSONBody

// BetaTesterInvitationsCreateInstanceRequestBody defines body for BetaTesterInvitationsCreateInstance for application/json ContentType.
type BetaTesterInvitationsCreateInstanceJSONRequestBody BetaTesterInvitationsCreateInstanceJSONBody

// BetaTestersCreateInstanceRequestBody defines body for BetaTestersCreateInstance for application/json ContentType.
type BetaTestersCreateInstanceJSONRequestBody BetaTestersCreateInstanceJSONBody

// BetaTestersAppsDeleteToManyRelationshipRequestBody defines body for BetaTestersAppsDeleteToManyRelationship for application/json ContentType.
type BetaTestersAppsDeleteToManyRelationshipJSONRequestBody BetaTestersAppsDeleteToManyRelationshipJSONBody

// BetaTestersBetaGroupsDeleteToManyRelationshipRequestBody defines body for BetaTestersBetaGroupsDeleteToManyRelationship for application/json ContentType.
type BetaTestersBetaGroupsDeleteToManyRelationshipJSONRequestBody BetaTestersBetaGroupsDeleteToManyRelationshipJSONBody

// BetaTestersBetaGroupsCreateToManyRelationshipRequestBody defines body for BetaTestersBetaGroupsCreateToManyRelationship for application/json ContentType.
type BetaTestersBetaGroupsCreateToManyRelationshipJSONRequestBody BetaTestersBetaGroupsCreateToManyRelationshipJSONBody

// BetaTestersBuildsDeleteToManyRelationshipRequestBody defines body for BetaTestersBuildsDeleteToManyRelationship for application/json ContentType.
type BetaTestersBuildsDeleteToManyRelationshipJSONRequestBody BetaTestersBuildsDeleteToManyRelationshipJSONBody

// BetaTestersBuildsCreateToManyRelationshipRequestBody defines body for BetaTestersBuildsCreateToManyRelationship for application/json ContentType.
type BetaTestersBuildsCreateToManyRelationshipJSONRequestBody BetaTestersBuildsCreateToManyRelationshipJSONBody

// BuildBetaDetailsUpdateInstanceRequestBody defines body for BuildBetaDetailsUpdateInstance for application/json ContentType.
type BuildBetaDetailsUpdateInstanceJSONRequestBody BuildBetaDetailsUpdateInstanceJSONBody

// BuildBetaNotificationsCreateInstanceRequestBody defines body for BuildBetaNotificationsCreateInstance for application/json ContentType.
type BuildBetaNotificationsCreateInstanceJSONRequestBody BuildBetaNotificationsCreateInstanceJSONBody

// BuildsUpdateInstanceRequestBody defines body for BuildsUpdateInstance for application/json ContentType.
type BuildsUpdateInstanceJSONRequestBody BuildsUpdateInstanceJSONBody

// BuildsAppEncryptionDeclarationUpdateToOneRelationshipRequestBody defines body for BuildsAppEncryptionDeclarationUpdateToOneRelationship for application/json ContentType.
type BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONRequestBody BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONBody

// BuildsBetaGroupsDeleteToManyRelationshipRequestBody defines body for BuildsBetaGroupsDeleteToManyRelationship for application/json ContentType.
type BuildsBetaGroupsDeleteToManyRelationshipJSONRequestBody BuildsBetaGroupsDeleteToManyRelationshipJSONBody

// BuildsBetaGroupsCreateToManyRelationshipRequestBody defines body for BuildsBetaGroupsCreateToManyRelationship for application/json ContentType.
type BuildsBetaGroupsCreateToManyRelationshipJSONRequestBody BuildsBetaGroupsCreateToManyRelationshipJSONBody

// BuildsIndividualTestersDeleteToManyRelationshipRequestBody defines body for BuildsIndividualTestersDeleteToManyRelationship for application/json ContentType.
type BuildsIndividualTestersDeleteToManyRelationshipJSONRequestBody BuildsIndividualTestersDeleteToManyRelationshipJSONBody

// BuildsIndividualTestersCreateToManyRelationshipRequestBody defines body for BuildsIndividualTestersCreateToManyRelationship for application/json ContentType.
type BuildsIndividualTestersCreateToManyRelationshipJSONRequestBody BuildsIndividualTestersCreateToManyRelationshipJSONBody

// BundleIdCapabilitiesCreateInstanceRequestBody defines body for BundleIdCapabilitiesCreateInstance for application/json ContentType.
type BundleIdCapabilitiesCreateInstanceJSONRequestBody BundleIdCapabilitiesCreateInstanceJSONBody

// BundleIdCapabilitiesUpdateInstanceRequestBody defines body for BundleIdCapabilitiesUpdateInstance for application/json ContentType.
type BundleIdCapabilitiesUpdateInstanceJSONRequestBody BundleIdCapabilitiesUpdateInstanceJSONBody

// BundleIdsCreateInstanceRequestBody defines body for BundleIdsCreateInstance for application/json ContentType.
type BundleIdsCreateInstanceJSONRequestBody BundleIdsCreateInstanceJSONBody

// BundleIdsUpdateInstanceRequestBody defines body for BundleIdsUpdateInstance for application/json ContentType.
type BundleIdsUpdateInstanceJSONRequestBody BundleIdsUpdateInstanceJSONBody

// CertificatesCreateInstanceRequestBody defines body for CertificatesCreateInstance for application/json ContentType.
type CertificatesCreateInstanceJSONRequestBody CertificatesCreateInstanceJSONBody

// DevicesCreateInstanceRequestBody defines body for DevicesCreateInstance for application/json ContentType.
type DevicesCreateInstanceJSONRequestBody DevicesCreateInstanceJSONBody

// DevicesUpdateInstanceRequestBody defines body for DevicesUpdateInstance for application/json ContentType.
type DevicesUpdateInstanceJSONRequestBody DevicesUpdateInstanceJSONBody

// EndUserLicenseAgreementsCreateInstanceRequestBody defines body for EndUserLicenseAgreementsCreateInstance for application/json ContentType.
type EndUserLicenseAgreementsCreateInstanceJSONRequestBody EndUserLicenseAgreementsCreateInstanceJSONBody

// EndUserLicenseAgreementsUpdateInstanceRequestBody defines body for EndUserLicenseAgreementsUpdateInstance for application/json ContentType.
type EndUserLicenseAgreementsUpdateInstanceJSONRequestBody EndUserLicenseAgreementsUpdateInstanceJSONBody

// GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequestBody defines body for GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship for application/json ContentType.
type GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONRequestBody GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONBody

// GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequestBody defines body for GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship for application/json ContentType.
type GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONRequestBody GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONBody

// GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequestBody defines body for GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship for application/json ContentType.
type GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONRequestBody GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONBody

// IdfaDeclarationsCreateInstanceRequestBody defines body for IdfaDeclarationsCreateInstance for application/json ContentType.
type IdfaDeclarationsCreateInstanceJSONRequestBody IdfaDeclarationsCreateInstanceJSONBody

// IdfaDeclarationsUpdateInstanceRequestBody defines body for IdfaDeclarationsUpdateInstance for application/json ContentType.
type IdfaDeclarationsUpdateInstanceJSONRequestBody IdfaDeclarationsUpdateInstanceJSONBody

// ProfilesCreateInstanceRequestBody defines body for ProfilesCreateInstance for application/json ContentType.
type ProfilesCreateInstanceJSONRequestBody ProfilesCreateInstanceJSONBody

// RoutingAppCoveragesCreateInstanceRequestBody defines body for RoutingAppCoveragesCreateInstance for application/json ContentType.
type RoutingAppCoveragesCreateInstanceJSONRequestBody RoutingAppCoveragesCreateInstanceJSONBody

// RoutingAppCoveragesUpdateInstanceRequestBody defines body for RoutingAppCoveragesUpdateInstance for application/json ContentType.
type RoutingAppCoveragesUpdateInstanceJSONRequestBody RoutingAppCoveragesUpdateInstanceJSONBody

// UserInvitationsCreateInstanceRequestBody defines body for UserInvitationsCreateInstance for application/json ContentType.
type UserInvitationsCreateInstanceJSONRequestBody UserInvitationsCreateInstanceJSONBody

// UsersUpdateInstanceRequestBody defines body for UsersUpdateInstance for application/json ContentType.
type UsersUpdateInstanceJSONRequestBody UsersUpdateInstanceJSONBody

// UsersVisibleAppsDeleteToManyRelationshipRequestBody defines body for UsersVisibleAppsDeleteToManyRelationship for application/json ContentType.
type UsersVisibleAppsDeleteToManyRelationshipJSONRequestBody UsersVisibleAppsDeleteToManyRelationshipJSONBody

// UsersVisibleAppsReplaceToManyRelationshipRequestBody defines body for UsersVisibleAppsReplaceToManyRelationship for application/json ContentType.
type UsersVisibleAppsReplaceToManyRelationshipJSONRequestBody UsersVisibleAppsReplaceToManyRelationshipJSONBody

// UsersVisibleAppsCreateToManyRelationshipRequestBody defines body for UsersVisibleAppsCreateToManyRelationship for application/json ContentType.
type UsersVisibleAppsCreateToManyRelationshipJSONRequestBody UsersVisibleAppsCreateToManyRelationshipJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AgeRatingDeclarationsUpdateInstance request  with any body
	AgeRatingDeclarationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AgeRatingDeclarationsUpdateInstance(ctx context.Context, id string, body AgeRatingDeclarationsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppCategoriesGetCollection request
	AppCategoriesGetCollection(ctx context.Context, params *AppCategoriesGetCollectionParams) (*http.Response, error)

	// AppCategoriesGetInstance request
	AppCategoriesGetInstance(ctx context.Context, id string, params *AppCategoriesGetInstanceParams) (*http.Response, error)

	// AppCategoriesParentGetToOneRelated request
	AppCategoriesParentGetToOneRelated(ctx context.Context, id string, params *AppCategoriesParentGetToOneRelatedParams) (*http.Response, error)

	// AppCategoriesSubcategoriesGetToManyRelated request
	AppCategoriesSubcategoriesGetToManyRelated(ctx context.Context, id string, params *AppCategoriesSubcategoriesGetToManyRelatedParams) (*http.Response, error)

	// AppEncryptionDeclarationsGetCollection request
	AppEncryptionDeclarationsGetCollection(ctx context.Context, params *AppEncryptionDeclarationsGetCollectionParams) (*http.Response, error)

	// AppEncryptionDeclarationsGetInstance request
	AppEncryptionDeclarationsGetInstance(ctx context.Context, id string, params *AppEncryptionDeclarationsGetInstanceParams) (*http.Response, error)

	// AppEncryptionDeclarationsAppGetToOneRelated request
	AppEncryptionDeclarationsAppGetToOneRelated(ctx context.Context, id string, params *AppEncryptionDeclarationsAppGetToOneRelatedParams) (*http.Response, error)

	// AppEncryptionDeclarationsBuildsCreateToManyRelationship request  with any body
	AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppEncryptionDeclarationsBuildsCreateToManyRelationship(ctx context.Context, id string, body AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// AppInfoLocalizationsCreateInstance request  with any body
	AppInfoLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppInfoLocalizationsCreateInstance(ctx context.Context, body AppInfoLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppInfoLocalizationsDeleteInstance request
	AppInfoLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppInfoLocalizationsGetInstance request
	AppInfoLocalizationsGetInstance(ctx context.Context, id string, params *AppInfoLocalizationsGetInstanceParams) (*http.Response, error)

	// AppInfoLocalizationsUpdateInstance request  with any body
	AppInfoLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppInfoLocalizationsUpdateInstance(ctx context.Context, id string, body AppInfoLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppInfosGetInstance request
	AppInfosGetInstance(ctx context.Context, id string, params *AppInfosGetInstanceParams) (*http.Response, error)

	// AppInfosUpdateInstance request  with any body
	AppInfosUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppInfosUpdateInstance(ctx context.Context, id string, body AppInfosUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppInfosAppInfoLocalizationsGetToManyRelated request
	AppInfosAppInfoLocalizationsGetToManyRelated(ctx context.Context, id string, params *AppInfosAppInfoLocalizationsGetToManyRelatedParams) (*http.Response, error)

	// AppInfosPrimaryCategoryGetToOneRelated request
	AppInfosPrimaryCategoryGetToOneRelated(ctx context.Context, id string, params *AppInfosPrimaryCategoryGetToOneRelatedParams) (*http.Response, error)

	// AppInfosPrimarySubcategoryOneGetToOneRelated request
	AppInfosPrimarySubcategoryOneGetToOneRelated(ctx context.Context, id string, params *AppInfosPrimarySubcategoryOneGetToOneRelatedParams) (*http.Response, error)

	// AppInfosPrimarySubcategoryTwoGetToOneRelated request
	AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx context.Context, id string, params *AppInfosPrimarySubcategoryTwoGetToOneRelatedParams) (*http.Response, error)

	// AppInfosSecondaryCategoryGetToOneRelated request
	AppInfosSecondaryCategoryGetToOneRelated(ctx context.Context, id string, params *AppInfosSecondaryCategoryGetToOneRelatedParams) (*http.Response, error)

	// AppInfosSecondarySubcategoryOneGetToOneRelated request
	AppInfosSecondarySubcategoryOneGetToOneRelated(ctx context.Context, id string, params *AppInfosSecondarySubcategoryOneGetToOneRelatedParams) (*http.Response, error)

	// AppInfosSecondarySubcategoryTwoGetToOneRelated request
	AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx context.Context, id string, params *AppInfosSecondarySubcategoryTwoGetToOneRelatedParams) (*http.Response, error)

	// AppPreOrdersCreateInstance request  with any body
	AppPreOrdersCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppPreOrdersCreateInstance(ctx context.Context, body AppPreOrdersCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppPreOrdersDeleteInstance request
	AppPreOrdersDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppPreOrdersGetInstance request
	AppPreOrdersGetInstance(ctx context.Context, id string, params *AppPreOrdersGetInstanceParams) (*http.Response, error)

	// AppPreOrdersUpdateInstance request  with any body
	AppPreOrdersUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppPreOrdersUpdateInstance(ctx context.Context, id string, body AppPreOrdersUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppPreviewSetsCreateInstance request  with any body
	AppPreviewSetsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppPreviewSetsCreateInstance(ctx context.Context, body AppPreviewSetsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppPreviewSetsDeleteInstance request
	AppPreviewSetsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppPreviewSetsGetInstance request
	AppPreviewSetsGetInstance(ctx context.Context, id string, params *AppPreviewSetsGetInstanceParams) (*http.Response, error)

	// AppPreviewSetsAppPreviewsGetToManyRelated request
	AppPreviewSetsAppPreviewsGetToManyRelated(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelatedParams) (*http.Response, error)

	// AppPreviewSetsAppPreviewsGetToManyRelationship request
	AppPreviewSetsAppPreviewsGetToManyRelationship(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelationshipParams) (*http.Response, error)

	// AppPreviewSetsAppPreviewsReplaceToManyRelationship request  with any body
	AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppPreviewSetsAppPreviewsReplaceToManyRelationship(ctx context.Context, id string, body AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error)

	// AppPreviewsCreateInstance request  with any body
	AppPreviewsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppPreviewsCreateInstance(ctx context.Context, body AppPreviewsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppPreviewsDeleteInstance request
	AppPreviewsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppPreviewsGetInstance request
	AppPreviewsGetInstance(ctx context.Context, id string, params *AppPreviewsGetInstanceParams) (*http.Response, error)

	// AppPreviewsUpdateInstance request  with any body
	AppPreviewsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppPreviewsUpdateInstance(ctx context.Context, id string, body AppPreviewsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppPricePointsGetCollection request
	AppPricePointsGetCollection(ctx context.Context, params *AppPricePointsGetCollectionParams) (*http.Response, error)

	// AppPricePointsGetInstance request
	AppPricePointsGetInstance(ctx context.Context, id string, params *AppPricePointsGetInstanceParams) (*http.Response, error)

	// AppPricePointsTerritoryGetToOneRelated request
	AppPricePointsTerritoryGetToOneRelated(ctx context.Context, id string, params *AppPricePointsTerritoryGetToOneRelatedParams) (*http.Response, error)

	// AppPriceTiersGetCollection request
	AppPriceTiersGetCollection(ctx context.Context, params *AppPriceTiersGetCollectionParams) (*http.Response, error)

	// AppPriceTiersGetInstance request
	AppPriceTiersGetInstance(ctx context.Context, id string, params *AppPriceTiersGetInstanceParams) (*http.Response, error)

	// AppPriceTiersPricePointsGetToManyRelated request
	AppPriceTiersPricePointsGetToManyRelated(ctx context.Context, id string, params *AppPriceTiersPricePointsGetToManyRelatedParams) (*http.Response, error)

	// AppPricesGetInstance request
	AppPricesGetInstance(ctx context.Context, id string, params *AppPricesGetInstanceParams) (*http.Response, error)

	// AppScreenshotSetsCreateInstance request  with any body
	AppScreenshotSetsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppScreenshotSetsCreateInstance(ctx context.Context, body AppScreenshotSetsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppScreenshotSetsDeleteInstance request
	AppScreenshotSetsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppScreenshotSetsGetInstance request
	AppScreenshotSetsGetInstance(ctx context.Context, id string, params *AppScreenshotSetsGetInstanceParams) (*http.Response, error)

	// AppScreenshotSetsAppScreenshotsGetToManyRelated request
	AppScreenshotSetsAppScreenshotsGetToManyRelated(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelatedParams) (*http.Response, error)

	// AppScreenshotSetsAppScreenshotsGetToManyRelationship request
	AppScreenshotSetsAppScreenshotsGetToManyRelationship(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams) (*http.Response, error)

	// AppScreenshotSetsAppScreenshotsReplaceToManyRelationship request  with any body
	AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(ctx context.Context, id string, body AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error)

	// AppScreenshotsCreateInstance request  with any body
	AppScreenshotsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppScreenshotsCreateInstance(ctx context.Context, body AppScreenshotsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppScreenshotsDeleteInstance request
	AppScreenshotsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppScreenshotsGetInstance request
	AppScreenshotsGetInstance(ctx context.Context, id string, params *AppScreenshotsGetInstanceParams) (*http.Response, error)

	// AppScreenshotsUpdateInstance request  with any body
	AppScreenshotsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppScreenshotsUpdateInstance(ctx context.Context, id string, body AppScreenshotsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreReviewAttachmentsCreateInstance request  with any body
	AppStoreReviewAttachmentsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppStoreReviewAttachmentsCreateInstance(ctx context.Context, body AppStoreReviewAttachmentsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreReviewAttachmentsDeleteInstance request
	AppStoreReviewAttachmentsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppStoreReviewAttachmentsGetInstance request
	AppStoreReviewAttachmentsGetInstance(ctx context.Context, id string, params *AppStoreReviewAttachmentsGetInstanceParams) (*http.Response, error)

	// AppStoreReviewAttachmentsUpdateInstance request  with any body
	AppStoreReviewAttachmentsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppStoreReviewAttachmentsUpdateInstance(ctx context.Context, id string, body AppStoreReviewAttachmentsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreReviewDetailsCreateInstance request  with any body
	AppStoreReviewDetailsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppStoreReviewDetailsCreateInstance(ctx context.Context, body AppStoreReviewDetailsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreReviewDetailsGetInstance request
	AppStoreReviewDetailsGetInstance(ctx context.Context, id string, params *AppStoreReviewDetailsGetInstanceParams) (*http.Response, error)

	// AppStoreReviewDetailsUpdateInstance request  with any body
	AppStoreReviewDetailsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppStoreReviewDetailsUpdateInstance(ctx context.Context, id string, body AppStoreReviewDetailsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated request
	AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(ctx context.Context, id string, params *AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams) (*http.Response, error)

	// AppStoreVersionLocalizationsCreateInstance request  with any body
	AppStoreVersionLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionLocalizationsCreateInstance(ctx context.Context, body AppStoreVersionLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionLocalizationsDeleteInstance request
	AppStoreVersionLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppStoreVersionLocalizationsGetInstance request
	AppStoreVersionLocalizationsGetInstance(ctx context.Context, id string, params *AppStoreVersionLocalizationsGetInstanceParams) (*http.Response, error)

	// AppStoreVersionLocalizationsUpdateInstance request  with any body
	AppStoreVersionLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionLocalizationsUpdateInstance(ctx context.Context, id string, body AppStoreVersionLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated request
	AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams) (*http.Response, error)

	// AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated request
	AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams) (*http.Response, error)

	// AppStoreVersionPhasedReleasesCreateInstance request  with any body
	AppStoreVersionPhasedReleasesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionPhasedReleasesCreateInstance(ctx context.Context, body AppStoreVersionPhasedReleasesCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionPhasedReleasesDeleteInstance request
	AppStoreVersionPhasedReleasesDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppStoreVersionPhasedReleasesUpdateInstance request  with any body
	AppStoreVersionPhasedReleasesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionPhasedReleasesUpdateInstance(ctx context.Context, id string, body AppStoreVersionPhasedReleasesUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionSubmissionsCreateInstance request  with any body
	AppStoreVersionSubmissionsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionSubmissionsCreateInstance(ctx context.Context, body AppStoreVersionSubmissionsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionSubmissionsDeleteInstance request
	AppStoreVersionSubmissionsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppStoreVersionsCreateInstance request  with any body
	AppStoreVersionsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionsCreateInstance(ctx context.Context, body AppStoreVersionsCreateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionsDeleteInstance request
	AppStoreVersionsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// AppStoreVersionsGetInstance request
	AppStoreVersionsGetInstance(ctx context.Context, id string, params *AppStoreVersionsGetInstanceParams) (*http.Response, error)

	// AppStoreVersionsUpdateInstance request  with any body
	AppStoreVersionsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionsUpdateInstance(ctx context.Context, id string, body AppStoreVersionsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppStoreVersionsAgeRatingDeclarationGetToOneRelated request
	AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams) (*http.Response, error)

	// AppStoreVersionsAppStoreReviewDetailGetToOneRelated request
	AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams) (*http.Response, error)

	// AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated request
	AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams) (*http.Response, error)

	// AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated request
	AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams) (*http.Response, error)

	// AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated request
	AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams) (*http.Response, error)

	// AppStoreVersionsBuildGetToOneRelated request
	AppStoreVersionsBuildGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsBuildGetToOneRelatedParams) (*http.Response, error)

	// AppStoreVersionsIdfaDeclarationGetToOneRelated request
	AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsIdfaDeclarationGetToOneRelatedParams) (*http.Response, error)

	// AppStoreVersionsBuildGetToOneRelationship request
	AppStoreVersionsBuildGetToOneRelationship(ctx context.Context, id string) (*http.Response, error)

	// AppStoreVersionsBuildUpdateToOneRelationship request  with any body
	AppStoreVersionsBuildUpdateToOneRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppStoreVersionsBuildUpdateToOneRelationship(ctx context.Context, id string, body AppStoreVersionsBuildUpdateToOneRelationshipJSONRequestBody) (*http.Response, error)

	// AppStoreVersionsRoutingAppCoverageGetToOneRelated request
	AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams) (*http.Response, error)

	// AppsGetCollection request
	AppsGetCollection(ctx context.Context, params *AppsGetCollectionParams) (*http.Response, error)

	// AppsGetInstance request
	AppsGetInstance(ctx context.Context, id string, params *AppsGetInstanceParams) (*http.Response, error)

	// AppsUpdateInstance request  with any body
	AppsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppsUpdateInstance(ctx context.Context, id string, body AppsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// AppsAppInfosGetToManyRelated request
	AppsAppInfosGetToManyRelated(ctx context.Context, id string, params *AppsAppInfosGetToManyRelatedParams) (*http.Response, error)

	// AppsAppStoreVersionsGetToManyRelated request
	AppsAppStoreVersionsGetToManyRelated(ctx context.Context, id string, params *AppsAppStoreVersionsGetToManyRelatedParams) (*http.Response, error)

	// AppsAvailableTerritoriesGetToManyRelated request
	AppsAvailableTerritoriesGetToManyRelated(ctx context.Context, id string, params *AppsAvailableTerritoriesGetToManyRelatedParams) (*http.Response, error)

	// AppsBetaAppLocalizationsGetToManyRelated request
	AppsBetaAppLocalizationsGetToManyRelated(ctx context.Context, id string, params *AppsBetaAppLocalizationsGetToManyRelatedParams) (*http.Response, error)

	// AppsBetaAppReviewDetailGetToOneRelated request
	AppsBetaAppReviewDetailGetToOneRelated(ctx context.Context, id string, params *AppsBetaAppReviewDetailGetToOneRelatedParams) (*http.Response, error)

	// AppsBetaGroupsGetToManyRelated request
	AppsBetaGroupsGetToManyRelated(ctx context.Context, id string, params *AppsBetaGroupsGetToManyRelatedParams) (*http.Response, error)

	// AppsBetaLicenseAgreementGetToOneRelated request
	AppsBetaLicenseAgreementGetToOneRelated(ctx context.Context, id string, params *AppsBetaLicenseAgreementGetToOneRelatedParams) (*http.Response, error)

	// AppsBuildsGetToManyRelated request
	AppsBuildsGetToManyRelated(ctx context.Context, id string, params *AppsBuildsGetToManyRelatedParams) (*http.Response, error)

	// AppsEndUserLicenseAgreementGetToOneRelated request
	AppsEndUserLicenseAgreementGetToOneRelated(ctx context.Context, id string, params *AppsEndUserLicenseAgreementGetToOneRelatedParams) (*http.Response, error)

	// AppsGameCenterEnabledVersionsGetToManyRelated request
	AppsGameCenterEnabledVersionsGetToManyRelated(ctx context.Context, id string, params *AppsGameCenterEnabledVersionsGetToManyRelatedParams) (*http.Response, error)

	// AppsInAppPurchasesGetToManyRelated request
	AppsInAppPurchasesGetToManyRelated(ctx context.Context, id string, params *AppsInAppPurchasesGetToManyRelatedParams) (*http.Response, error)

	// AppsPerfPowerMetricsGetToManyRelated request
	AppsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string, params *AppsPerfPowerMetricsGetToManyRelatedParams) (*http.Response, error)

	// AppsPreOrderGetToOneRelated request
	AppsPreOrderGetToOneRelated(ctx context.Context, id string, params *AppsPreOrderGetToOneRelatedParams) (*http.Response, error)

	// AppsPreReleaseVersionsGetToManyRelated request
	AppsPreReleaseVersionsGetToManyRelated(ctx context.Context, id string, params *AppsPreReleaseVersionsGetToManyRelatedParams) (*http.Response, error)

	// AppsPricesGetToManyRelated request
	AppsPricesGetToManyRelated(ctx context.Context, id string, params *AppsPricesGetToManyRelatedParams) (*http.Response, error)

	// AppsBetaTestersDeleteToManyRelationship request  with any body
	AppsBetaTestersDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	AppsBetaTestersDeleteToManyRelationship(ctx context.Context, id string, body AppsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaAppLocalizationsGetCollection request
	BetaAppLocalizationsGetCollection(ctx context.Context, params *BetaAppLocalizationsGetCollectionParams) (*http.Response, error)

	// BetaAppLocalizationsCreateInstance request  with any body
	BetaAppLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BetaAppLocalizationsCreateInstance(ctx context.Context, body BetaAppLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BetaAppLocalizationsDeleteInstance request
	BetaAppLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// BetaAppLocalizationsGetInstance request
	BetaAppLocalizationsGetInstance(ctx context.Context, id string, params *BetaAppLocalizationsGetInstanceParams) (*http.Response, error)

	// BetaAppLocalizationsUpdateInstance request  with any body
	BetaAppLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaAppLocalizationsUpdateInstance(ctx context.Context, id string, body BetaAppLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BetaAppLocalizationsAppGetToOneRelated request
	BetaAppLocalizationsAppGetToOneRelated(ctx context.Context, id string, params *BetaAppLocalizationsAppGetToOneRelatedParams) (*http.Response, error)

	// BetaAppReviewDetailsGetCollection request
	BetaAppReviewDetailsGetCollection(ctx context.Context, params *BetaAppReviewDetailsGetCollectionParams) (*http.Response, error)

	// BetaAppReviewDetailsGetInstance request
	BetaAppReviewDetailsGetInstance(ctx context.Context, id string, params *BetaAppReviewDetailsGetInstanceParams) (*http.Response, error)

	// BetaAppReviewDetailsUpdateInstance request  with any body
	BetaAppReviewDetailsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaAppReviewDetailsUpdateInstance(ctx context.Context, id string, body BetaAppReviewDetailsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BetaAppReviewDetailsAppGetToOneRelated request
	BetaAppReviewDetailsAppGetToOneRelated(ctx context.Context, id string, params *BetaAppReviewDetailsAppGetToOneRelatedParams) (*http.Response, error)

	// BetaAppReviewSubmissionsGetCollection request
	BetaAppReviewSubmissionsGetCollection(ctx context.Context, params *BetaAppReviewSubmissionsGetCollectionParams) (*http.Response, error)

	// BetaAppReviewSubmissionsCreateInstance request  with any body
	BetaAppReviewSubmissionsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BetaAppReviewSubmissionsCreateInstance(ctx context.Context, body BetaAppReviewSubmissionsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BetaAppReviewSubmissionsGetInstance request
	BetaAppReviewSubmissionsGetInstance(ctx context.Context, id string, params *BetaAppReviewSubmissionsGetInstanceParams) (*http.Response, error)

	// BetaAppReviewSubmissionsBuildGetToOneRelated request
	BetaAppReviewSubmissionsBuildGetToOneRelated(ctx context.Context, id string, params *BetaAppReviewSubmissionsBuildGetToOneRelatedParams) (*http.Response, error)

	// BetaBuildLocalizationsGetCollection request
	BetaBuildLocalizationsGetCollection(ctx context.Context, params *BetaBuildLocalizationsGetCollectionParams) (*http.Response, error)

	// BetaBuildLocalizationsCreateInstance request  with any body
	BetaBuildLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BetaBuildLocalizationsCreateInstance(ctx context.Context, body BetaBuildLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BetaBuildLocalizationsDeleteInstance request
	BetaBuildLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// BetaBuildLocalizationsGetInstance request
	BetaBuildLocalizationsGetInstance(ctx context.Context, id string, params *BetaBuildLocalizationsGetInstanceParams) (*http.Response, error)

	// BetaBuildLocalizationsUpdateInstance request  with any body
	BetaBuildLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaBuildLocalizationsUpdateInstance(ctx context.Context, id string, body BetaBuildLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BetaBuildLocalizationsBuildGetToOneRelated request
	BetaBuildLocalizationsBuildGetToOneRelated(ctx context.Context, id string, params *BetaBuildLocalizationsBuildGetToOneRelatedParams) (*http.Response, error)

	// BetaGroupsGetCollection request
	BetaGroupsGetCollection(ctx context.Context, params *BetaGroupsGetCollectionParams) (*http.Response, error)

	// BetaGroupsCreateInstance request  with any body
	BetaGroupsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BetaGroupsCreateInstance(ctx context.Context, body BetaGroupsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BetaGroupsDeleteInstance request
	BetaGroupsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// BetaGroupsGetInstance request
	BetaGroupsGetInstance(ctx context.Context, id string, params *BetaGroupsGetInstanceParams) (*http.Response, error)

	// BetaGroupsUpdateInstance request  with any body
	BetaGroupsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaGroupsUpdateInstance(ctx context.Context, id string, body BetaGroupsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BetaGroupsAppGetToOneRelated request
	BetaGroupsAppGetToOneRelated(ctx context.Context, id string, params *BetaGroupsAppGetToOneRelatedParams) (*http.Response, error)

	// BetaGroupsBetaTestersGetToManyRelated request
	BetaGroupsBetaTestersGetToManyRelated(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelatedParams) (*http.Response, error)

	// BetaGroupsBuildsGetToManyRelated request
	BetaGroupsBuildsGetToManyRelated(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelatedParams) (*http.Response, error)

	// BetaGroupsBetaTestersDeleteToManyRelationship request  with any body
	BetaGroupsBetaTestersDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaGroupsBetaTestersDeleteToManyRelationship(ctx context.Context, id string, body BetaGroupsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaGroupsBetaTestersGetToManyRelationship request
	BetaGroupsBetaTestersGetToManyRelationship(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelationshipParams) (*http.Response, error)

	// BetaGroupsBetaTestersCreateToManyRelationship request  with any body
	BetaGroupsBetaTestersCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaGroupsBetaTestersCreateToManyRelationship(ctx context.Context, id string, body BetaGroupsBetaTestersCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaGroupsBuildsDeleteToManyRelationship request  with any body
	BetaGroupsBuildsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaGroupsBuildsDeleteToManyRelationship(ctx context.Context, id string, body BetaGroupsBuildsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaGroupsBuildsGetToManyRelationship request
	BetaGroupsBuildsGetToManyRelationship(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelationshipParams) (*http.Response, error)

	// BetaGroupsBuildsCreateToManyRelationship request  with any body
	BetaGroupsBuildsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaGroupsBuildsCreateToManyRelationship(ctx context.Context, id string, body BetaGroupsBuildsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaLicenseAgreementsGetCollection request
	BetaLicenseAgreementsGetCollection(ctx context.Context, params *BetaLicenseAgreementsGetCollectionParams) (*http.Response, error)

	// BetaLicenseAgreementsGetInstance request
	BetaLicenseAgreementsGetInstance(ctx context.Context, id string, params *BetaLicenseAgreementsGetInstanceParams) (*http.Response, error)

	// BetaLicenseAgreementsUpdateInstance request  with any body
	BetaLicenseAgreementsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaLicenseAgreementsUpdateInstance(ctx context.Context, id string, body BetaLicenseAgreementsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BetaLicenseAgreementsAppGetToOneRelated request
	BetaLicenseAgreementsAppGetToOneRelated(ctx context.Context, id string, params *BetaLicenseAgreementsAppGetToOneRelatedParams) (*http.Response, error)

	// BetaTesterInvitationsCreateInstance request  with any body
	BetaTesterInvitationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BetaTesterInvitationsCreateInstance(ctx context.Context, body BetaTesterInvitationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BetaTestersGetCollection request
	BetaTestersGetCollection(ctx context.Context, params *BetaTestersGetCollectionParams) (*http.Response, error)

	// BetaTestersCreateInstance request  with any body
	BetaTestersCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BetaTestersCreateInstance(ctx context.Context, body BetaTestersCreateInstanceJSONRequestBody) (*http.Response, error)

	// BetaTestersDeleteInstance request
	BetaTestersDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// BetaTestersGetInstance request
	BetaTestersGetInstance(ctx context.Context, id string, params *BetaTestersGetInstanceParams) (*http.Response, error)

	// BetaTestersAppsGetToManyRelated request
	BetaTestersAppsGetToManyRelated(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelatedParams) (*http.Response, error)

	// BetaTestersBetaGroupsGetToManyRelated request
	BetaTestersBetaGroupsGetToManyRelated(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelatedParams) (*http.Response, error)

	// BetaTestersBuildsGetToManyRelated request
	BetaTestersBuildsGetToManyRelated(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelatedParams) (*http.Response, error)

	// BetaTestersAppsDeleteToManyRelationship request  with any body
	BetaTestersAppsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaTestersAppsDeleteToManyRelationship(ctx context.Context, id string, body BetaTestersAppsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaTestersAppsGetToManyRelationship request
	BetaTestersAppsGetToManyRelationship(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelationshipParams) (*http.Response, error)

	// BetaTestersBetaGroupsDeleteToManyRelationship request  with any body
	BetaTestersBetaGroupsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaTestersBetaGroupsDeleteToManyRelationship(ctx context.Context, id string, body BetaTestersBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaTestersBetaGroupsGetToManyRelationship request
	BetaTestersBetaGroupsGetToManyRelationship(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelationshipParams) (*http.Response, error)

	// BetaTestersBetaGroupsCreateToManyRelationship request  with any body
	BetaTestersBetaGroupsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaTestersBetaGroupsCreateToManyRelationship(ctx context.Context, id string, body BetaTestersBetaGroupsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaTestersBuildsDeleteToManyRelationship request  with any body
	BetaTestersBuildsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaTestersBuildsDeleteToManyRelationship(ctx context.Context, id string, body BetaTestersBuildsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BetaTestersBuildsGetToManyRelationship request
	BetaTestersBuildsGetToManyRelationship(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelationshipParams) (*http.Response, error)

	// BetaTestersBuildsCreateToManyRelationship request  with any body
	BetaTestersBuildsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BetaTestersBuildsCreateToManyRelationship(ctx context.Context, id string, body BetaTestersBuildsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BuildBetaDetailsGetCollection request
	BuildBetaDetailsGetCollection(ctx context.Context, params *BuildBetaDetailsGetCollectionParams) (*http.Response, error)

	// BuildBetaDetailsGetInstance request
	BuildBetaDetailsGetInstance(ctx context.Context, id string, params *BuildBetaDetailsGetInstanceParams) (*http.Response, error)

	// BuildBetaDetailsUpdateInstance request  with any body
	BuildBetaDetailsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildBetaDetailsUpdateInstance(ctx context.Context, id string, body BuildBetaDetailsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BuildBetaDetailsBuildGetToOneRelated request
	BuildBetaDetailsBuildGetToOneRelated(ctx context.Context, id string, params *BuildBetaDetailsBuildGetToOneRelatedParams) (*http.Response, error)

	// BuildBetaNotificationsCreateInstance request  with any body
	BuildBetaNotificationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BuildBetaNotificationsCreateInstance(ctx context.Context, body BuildBetaNotificationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BuildsGetCollection request
	BuildsGetCollection(ctx context.Context, params *BuildsGetCollectionParams) (*http.Response, error)

	// BuildsGetInstance request
	BuildsGetInstance(ctx context.Context, id string, params *BuildsGetInstanceParams) (*http.Response, error)

	// BuildsUpdateInstance request  with any body
	BuildsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildsUpdateInstance(ctx context.Context, id string, body BuildsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BuildsAppGetToOneRelated request
	BuildsAppGetToOneRelated(ctx context.Context, id string, params *BuildsAppGetToOneRelatedParams) (*http.Response, error)

	// BuildsAppEncryptionDeclarationGetToOneRelated request
	BuildsAppEncryptionDeclarationGetToOneRelated(ctx context.Context, id string, params *BuildsAppEncryptionDeclarationGetToOneRelatedParams) (*http.Response, error)

	// BuildsAppStoreVersionGetToOneRelated request
	BuildsAppStoreVersionGetToOneRelated(ctx context.Context, id string, params *BuildsAppStoreVersionGetToOneRelatedParams) (*http.Response, error)

	// BuildsBetaAppReviewSubmissionGetToOneRelated request
	BuildsBetaAppReviewSubmissionGetToOneRelated(ctx context.Context, id string, params *BuildsBetaAppReviewSubmissionGetToOneRelatedParams) (*http.Response, error)

	// BuildsBetaBuildLocalizationsGetToManyRelated request
	BuildsBetaBuildLocalizationsGetToManyRelated(ctx context.Context, id string, params *BuildsBetaBuildLocalizationsGetToManyRelatedParams) (*http.Response, error)

	// BuildsBuildBetaDetailGetToOneRelated request
	BuildsBuildBetaDetailGetToOneRelated(ctx context.Context, id string, params *BuildsBuildBetaDetailGetToOneRelatedParams) (*http.Response, error)

	// BuildsDiagnosticSignaturesGetToManyRelated request
	BuildsDiagnosticSignaturesGetToManyRelated(ctx context.Context, id string, params *BuildsDiagnosticSignaturesGetToManyRelatedParams) (*http.Response, error)

	// BuildsIconsGetToManyRelated request
	BuildsIconsGetToManyRelated(ctx context.Context, id string, params *BuildsIconsGetToManyRelatedParams) (*http.Response, error)

	// BuildsIndividualTestersGetToManyRelated request
	BuildsIndividualTestersGetToManyRelated(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelatedParams) (*http.Response, error)

	// BuildsPerfPowerMetricsGetToManyRelated request
	BuildsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string, params *BuildsPerfPowerMetricsGetToManyRelatedParams) (*http.Response, error)

	// BuildsPreReleaseVersionGetToOneRelated request
	BuildsPreReleaseVersionGetToOneRelated(ctx context.Context, id string, params *BuildsPreReleaseVersionGetToOneRelatedParams) (*http.Response, error)

	// BuildsAppEncryptionDeclarationGetToOneRelationship request
	BuildsAppEncryptionDeclarationGetToOneRelationship(ctx context.Context, id string) (*http.Response, error)

	// BuildsAppEncryptionDeclarationUpdateToOneRelationship request  with any body
	BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx context.Context, id string, body BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONRequestBody) (*http.Response, error)

	// BuildsBetaGroupsDeleteToManyRelationship request  with any body
	BuildsBetaGroupsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildsBetaGroupsDeleteToManyRelationship(ctx context.Context, id string, body BuildsBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BuildsBetaGroupsCreateToManyRelationship request  with any body
	BuildsBetaGroupsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildsBetaGroupsCreateToManyRelationship(ctx context.Context, id string, body BuildsBetaGroupsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BuildsIndividualTestersDeleteToManyRelationship request  with any body
	BuildsIndividualTestersDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildsIndividualTestersDeleteToManyRelationship(ctx context.Context, id string, body BuildsIndividualTestersDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BuildsIndividualTestersGetToManyRelationship request
	BuildsIndividualTestersGetToManyRelationship(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelationshipParams) (*http.Response, error)

	// BuildsIndividualTestersCreateToManyRelationship request  with any body
	BuildsIndividualTestersCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BuildsIndividualTestersCreateToManyRelationship(ctx context.Context, id string, body BuildsIndividualTestersCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// BundleIdCapabilitiesCreateInstance request  with any body
	BundleIdCapabilitiesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BundleIdCapabilitiesCreateInstance(ctx context.Context, body BundleIdCapabilitiesCreateInstanceJSONRequestBody) (*http.Response, error)

	// BundleIdCapabilitiesDeleteInstance request
	BundleIdCapabilitiesDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// BundleIdCapabilitiesUpdateInstance request  with any body
	BundleIdCapabilitiesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BundleIdCapabilitiesUpdateInstance(ctx context.Context, id string, body BundleIdCapabilitiesUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BundleIdsGetCollection request
	BundleIdsGetCollection(ctx context.Context, params *BundleIdsGetCollectionParams) (*http.Response, error)

	// BundleIdsCreateInstance request  with any body
	BundleIdsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	BundleIdsCreateInstance(ctx context.Context, body BundleIdsCreateInstanceJSONRequestBody) (*http.Response, error)

	// BundleIdsDeleteInstance request
	BundleIdsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// BundleIdsGetInstance request
	BundleIdsGetInstance(ctx context.Context, id string, params *BundleIdsGetInstanceParams) (*http.Response, error)

	// BundleIdsUpdateInstance request  with any body
	BundleIdsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	BundleIdsUpdateInstance(ctx context.Context, id string, body BundleIdsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// BundleIdsAppGetToOneRelated request
	BundleIdsAppGetToOneRelated(ctx context.Context, id string, params *BundleIdsAppGetToOneRelatedParams) (*http.Response, error)

	// BundleIdsBundleIdCapabilitiesGetToManyRelated request
	BundleIdsBundleIdCapabilitiesGetToManyRelated(ctx context.Context, id string, params *BundleIdsBundleIdCapabilitiesGetToManyRelatedParams) (*http.Response, error)

	// BundleIdsProfilesGetToManyRelated request
	BundleIdsProfilesGetToManyRelated(ctx context.Context, id string, params *BundleIdsProfilesGetToManyRelatedParams) (*http.Response, error)

	// CertificatesGetCollection request
	CertificatesGetCollection(ctx context.Context, params *CertificatesGetCollectionParams) (*http.Response, error)

	// CertificatesCreateInstance request  with any body
	CertificatesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CertificatesCreateInstance(ctx context.Context, body CertificatesCreateInstanceJSONRequestBody) (*http.Response, error)

	// CertificatesDeleteInstance request
	CertificatesDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// CertificatesGetInstance request
	CertificatesGetInstance(ctx context.Context, id string, params *CertificatesGetInstanceParams) (*http.Response, error)

	// DevicesGetCollection request
	DevicesGetCollection(ctx context.Context, params *DevicesGetCollectionParams) (*http.Response, error)

	// DevicesCreateInstance request  with any body
	DevicesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	DevicesCreateInstance(ctx context.Context, body DevicesCreateInstanceJSONRequestBody) (*http.Response, error)

	// DevicesGetInstance request
	DevicesGetInstance(ctx context.Context, id string, params *DevicesGetInstanceParams) (*http.Response, error)

	// DevicesUpdateInstance request  with any body
	DevicesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	DevicesUpdateInstance(ctx context.Context, id string, body DevicesUpdateInstanceJSONRequestBody) (*http.Response, error)

	// DiagnosticSignaturesLogsGetToManyRelated request
	DiagnosticSignaturesLogsGetToManyRelated(ctx context.Context, id string, params *DiagnosticSignaturesLogsGetToManyRelatedParams) (*http.Response, error)

	// EndUserLicenseAgreementsCreateInstance request  with any body
	EndUserLicenseAgreementsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	EndUserLicenseAgreementsCreateInstance(ctx context.Context, body EndUserLicenseAgreementsCreateInstanceJSONRequestBody) (*http.Response, error)

	// EndUserLicenseAgreementsDeleteInstance request
	EndUserLicenseAgreementsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// EndUserLicenseAgreementsGetInstance request
	EndUserLicenseAgreementsGetInstance(ctx context.Context, id string, params *EndUserLicenseAgreementsGetInstanceParams) (*http.Response, error)

	// EndUserLicenseAgreementsUpdateInstance request  with any body
	EndUserLicenseAgreementsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	EndUserLicenseAgreementsUpdateInstance(ctx context.Context, id string, body EndUserLicenseAgreementsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// EndUserLicenseAgreementsTerritoriesGetToManyRelated request
	EndUserLicenseAgreementsTerritoriesGetToManyRelated(ctx context.Context, id string, params *EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams) (*http.Response, error)

	// FinanceReportsGetCollection request
	FinanceReportsGetCollection(ctx context.Context, params *FinanceReportsGetCollectionParams) (*http.Response, error)

	// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated request
	GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams) (*http.Response, error)

	// GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship request  with any body
	GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship request
	GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams) (*http.Response, error)

	// GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship request  with any body
	GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error)

	// GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship request  with any body
	GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// IdfaDeclarationsCreateInstance request  with any body
	IdfaDeclarationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	IdfaDeclarationsCreateInstance(ctx context.Context, body IdfaDeclarationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// IdfaDeclarationsDeleteInstance request
	IdfaDeclarationsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// IdfaDeclarationsUpdateInstance request  with any body
	IdfaDeclarationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	IdfaDeclarationsUpdateInstance(ctx context.Context, id string, body IdfaDeclarationsUpdateInstanceJSONRequestBody) (*http.Response, error)

	// InAppPurchasesGetInstance request
	InAppPurchasesGetInstance(ctx context.Context, id string, params *InAppPurchasesGetInstanceParams) (*http.Response, error)

	// PreReleaseVersionsGetCollection request
	PreReleaseVersionsGetCollection(ctx context.Context, params *PreReleaseVersionsGetCollectionParams) (*http.Response, error)

	// PreReleaseVersionsGetInstance request
	PreReleaseVersionsGetInstance(ctx context.Context, id string, params *PreReleaseVersionsGetInstanceParams) (*http.Response, error)

	// PreReleaseVersionsAppGetToOneRelated request
	PreReleaseVersionsAppGetToOneRelated(ctx context.Context, id string, params *PreReleaseVersionsAppGetToOneRelatedParams) (*http.Response, error)

	// PreReleaseVersionsBuildsGetToManyRelated request
	PreReleaseVersionsBuildsGetToManyRelated(ctx context.Context, id string, params *PreReleaseVersionsBuildsGetToManyRelatedParams) (*http.Response, error)

	// ProfilesGetCollection request
	ProfilesGetCollection(ctx context.Context, params *ProfilesGetCollectionParams) (*http.Response, error)

	// ProfilesCreateInstance request  with any body
	ProfilesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	ProfilesCreateInstance(ctx context.Context, body ProfilesCreateInstanceJSONRequestBody) (*http.Response, error)

	// ProfilesDeleteInstance request
	ProfilesDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// ProfilesGetInstance request
	ProfilesGetInstance(ctx context.Context, id string, params *ProfilesGetInstanceParams) (*http.Response, error)

	// ProfilesBundleIdGetToOneRelated request
	ProfilesBundleIdGetToOneRelated(ctx context.Context, id string, params *ProfilesBundleIdGetToOneRelatedParams) (*http.Response, error)

	// ProfilesCertificatesGetToManyRelated request
	ProfilesCertificatesGetToManyRelated(ctx context.Context, id string, params *ProfilesCertificatesGetToManyRelatedParams) (*http.Response, error)

	// ProfilesDevicesGetToManyRelated request
	ProfilesDevicesGetToManyRelated(ctx context.Context, id string, params *ProfilesDevicesGetToManyRelatedParams) (*http.Response, error)

	// RoutingAppCoveragesCreateInstance request  with any body
	RoutingAppCoveragesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	RoutingAppCoveragesCreateInstance(ctx context.Context, body RoutingAppCoveragesCreateInstanceJSONRequestBody) (*http.Response, error)

	// RoutingAppCoveragesDeleteInstance request
	RoutingAppCoveragesDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// RoutingAppCoveragesGetInstance request
	RoutingAppCoveragesGetInstance(ctx context.Context, id string, params *RoutingAppCoveragesGetInstanceParams) (*http.Response, error)

	// RoutingAppCoveragesUpdateInstance request  with any body
	RoutingAppCoveragesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	RoutingAppCoveragesUpdateInstance(ctx context.Context, id string, body RoutingAppCoveragesUpdateInstanceJSONRequestBody) (*http.Response, error)

	// SalesReportsGetCollection request
	SalesReportsGetCollection(ctx context.Context, params *SalesReportsGetCollectionParams) (*http.Response, error)

	// TerritoriesGetCollection request
	TerritoriesGetCollection(ctx context.Context, params *TerritoriesGetCollectionParams) (*http.Response, error)

	// UserInvitationsGetCollection request
	UserInvitationsGetCollection(ctx context.Context, params *UserInvitationsGetCollectionParams) (*http.Response, error)

	// UserInvitationsCreateInstance request  with any body
	UserInvitationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	UserInvitationsCreateInstance(ctx context.Context, body UserInvitationsCreateInstanceJSONRequestBody) (*http.Response, error)

	// UserInvitationsDeleteInstance request
	UserInvitationsDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// UserInvitationsGetInstance request
	UserInvitationsGetInstance(ctx context.Context, id string, params *UserInvitationsGetInstanceParams) (*http.Response, error)

	// UserInvitationsVisibleAppsGetToManyRelated request
	UserInvitationsVisibleAppsGetToManyRelated(ctx context.Context, id string, params *UserInvitationsVisibleAppsGetToManyRelatedParams) (*http.Response, error)

	// UsersGetCollection request
	UsersGetCollection(ctx context.Context, params *UsersGetCollectionParams) (*http.Response, error)

	// UsersDeleteInstance request
	UsersDeleteInstance(ctx context.Context, id string) (*http.Response, error)

	// UsersGetInstance request
	UsersGetInstance(ctx context.Context, id string, params *UsersGetInstanceParams) (*http.Response, error)

	// UsersUpdateInstance request  with any body
	UsersUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	UsersUpdateInstance(ctx context.Context, id string, body UsersUpdateInstanceJSONRequestBody) (*http.Response, error)

	// UsersVisibleAppsDeleteToManyRelationship request  with any body
	UsersVisibleAppsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	UsersVisibleAppsDeleteToManyRelationship(ctx context.Context, id string, body UsersVisibleAppsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error)

	// UsersVisibleAppsGetToManyRelationship request
	UsersVisibleAppsGetToManyRelationship(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelationshipParams) (*http.Response, error)

	// UsersVisibleAppsReplaceToManyRelationship request  with any body
	UsersVisibleAppsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	UsersVisibleAppsReplaceToManyRelationship(ctx context.Context, id string, body UsersVisibleAppsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error)

	// UsersVisibleAppsCreateToManyRelationship request  with any body
	UsersVisibleAppsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	UsersVisibleAppsCreateToManyRelationship(ctx context.Context, id string, body UsersVisibleAppsCreateToManyRelationshipJSONRequestBody) (*http.Response, error)

	// UsersVisibleAppsGetToManyRelated request
	UsersVisibleAppsGetToManyRelated(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelatedParams) (*http.Response, error)
}

func (c *Client) AgeRatingDeclarationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAgeRatingDeclarationsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AgeRatingDeclarationsUpdateInstance(ctx context.Context, id string, body AgeRatingDeclarationsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAgeRatingDeclarationsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppCategoriesGetCollection(ctx context.Context, params *AppCategoriesGetCollectionParams) (*http.Response, error) {
	req, err := NewAppCategoriesGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppCategoriesGetInstance(ctx context.Context, id string, params *AppCategoriesGetInstanceParams) (*http.Response, error) {
	req, err := NewAppCategoriesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppCategoriesParentGetToOneRelated(ctx context.Context, id string, params *AppCategoriesParentGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppCategoriesParentGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppCategoriesSubcategoriesGetToManyRelated(ctx context.Context, id string, params *AppCategoriesSubcategoriesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppCategoriesSubcategoriesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppEncryptionDeclarationsGetCollection(ctx context.Context, params *AppEncryptionDeclarationsGetCollectionParams) (*http.Response, error) {
	req, err := NewAppEncryptionDeclarationsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppEncryptionDeclarationsGetInstance(ctx context.Context, id string, params *AppEncryptionDeclarationsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppEncryptionDeclarationsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppEncryptionDeclarationsAppGetToOneRelated(ctx context.Context, id string, params *AppEncryptionDeclarationsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppEncryptionDeclarationsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppEncryptionDeclarationsBuildsCreateToManyRelationship(ctx context.Context, id string, body AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfoLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppInfoLocalizationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfoLocalizationsCreateInstance(ctx context.Context, body AppInfoLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppInfoLocalizationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfoLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppInfoLocalizationsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfoLocalizationsGetInstance(ctx context.Context, id string, params *AppInfoLocalizationsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppInfoLocalizationsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfoLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppInfoLocalizationsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfoLocalizationsUpdateInstance(ctx context.Context, id string, body AppInfoLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppInfoLocalizationsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosGetInstance(ctx context.Context, id string, params *AppInfosGetInstanceParams) (*http.Response, error) {
	req, err := NewAppInfosGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppInfosUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosUpdateInstance(ctx context.Context, id string, body AppInfosUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppInfosUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosAppInfoLocalizationsGetToManyRelated(ctx context.Context, id string, params *AppInfosAppInfoLocalizationsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosAppInfoLocalizationsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosPrimaryCategoryGetToOneRelated(ctx context.Context, id string, params *AppInfosPrimaryCategoryGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosPrimaryCategoryGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosPrimarySubcategoryOneGetToOneRelated(ctx context.Context, id string, params *AppInfosPrimarySubcategoryOneGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosPrimarySubcategoryOneGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx context.Context, id string, params *AppInfosPrimarySubcategoryTwoGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosSecondaryCategoryGetToOneRelated(ctx context.Context, id string, params *AppInfosSecondaryCategoryGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosSecondaryCategoryGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosSecondarySubcategoryOneGetToOneRelated(ctx context.Context, id string, params *AppInfosSecondarySubcategoryOneGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosSecondarySubcategoryOneGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx context.Context, id string, params *AppInfosSecondarySubcategoryTwoGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreOrdersCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppPreOrdersCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreOrdersCreateInstance(ctx context.Context, body AppPreOrdersCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppPreOrdersCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreOrdersDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppPreOrdersDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreOrdersGetInstance(ctx context.Context, id string, params *AppPreOrdersGetInstanceParams) (*http.Response, error) {
	req, err := NewAppPreOrdersGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreOrdersUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppPreOrdersUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreOrdersUpdateInstance(ctx context.Context, id string, body AppPreOrdersUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppPreOrdersUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppPreviewSetsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsCreateInstance(ctx context.Context, body AppPreviewSetsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppPreviewSetsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppPreviewSetsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsGetInstance(ctx context.Context, id string, params *AppPreviewSetsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppPreviewSetsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsAppPreviewsGetToManyRelated(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppPreviewSetsAppPreviewsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsAppPreviewsGetToManyRelationship(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewAppPreviewSetsAppPreviewsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewSetsAppPreviewsReplaceToManyRelationship(ctx context.Context, id string, body AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppPreviewsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewsCreateInstance(ctx context.Context, body AppPreviewsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppPreviewsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppPreviewsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewsGetInstance(ctx context.Context, id string, params *AppPreviewsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppPreviewsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppPreviewsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPreviewsUpdateInstance(ctx context.Context, id string, body AppPreviewsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppPreviewsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPricePointsGetCollection(ctx context.Context, params *AppPricePointsGetCollectionParams) (*http.Response, error) {
	req, err := NewAppPricePointsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPricePointsGetInstance(ctx context.Context, id string, params *AppPricePointsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppPricePointsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPricePointsTerritoryGetToOneRelated(ctx context.Context, id string, params *AppPricePointsTerritoryGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppPricePointsTerritoryGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPriceTiersGetCollection(ctx context.Context, params *AppPriceTiersGetCollectionParams) (*http.Response, error) {
	req, err := NewAppPriceTiersGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPriceTiersGetInstance(ctx context.Context, id string, params *AppPriceTiersGetInstanceParams) (*http.Response, error) {
	req, err := NewAppPriceTiersGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPriceTiersPricePointsGetToManyRelated(ctx context.Context, id string, params *AppPriceTiersPricePointsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppPriceTiersPricePointsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppPricesGetInstance(ctx context.Context, id string, params *AppPricesGetInstanceParams) (*http.Response, error) {
	req, err := NewAppPricesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppScreenshotSetsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsCreateInstance(ctx context.Context, body AppScreenshotSetsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppScreenshotSetsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppScreenshotSetsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsGetInstance(ctx context.Context, id string, params *AppScreenshotSetsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppScreenshotSetsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsAppScreenshotsGetToManyRelated(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppScreenshotSetsAppScreenshotsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsAppScreenshotsGetToManyRelationship(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewAppScreenshotSetsAppScreenshotsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(ctx context.Context, id string, body AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppScreenshotsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotsCreateInstance(ctx context.Context, body AppScreenshotsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppScreenshotsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppScreenshotsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotsGetInstance(ctx context.Context, id string, params *AppScreenshotsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppScreenshotsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppScreenshotsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppScreenshotsUpdateInstance(ctx context.Context, id string, body AppScreenshotsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppScreenshotsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewAttachmentsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreReviewAttachmentsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewAttachmentsCreateInstance(ctx context.Context, body AppStoreReviewAttachmentsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreReviewAttachmentsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewAttachmentsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppStoreReviewAttachmentsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewAttachmentsGetInstance(ctx context.Context, id string, params *AppStoreReviewAttachmentsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppStoreReviewAttachmentsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewAttachmentsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreReviewAttachmentsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewAttachmentsUpdateInstance(ctx context.Context, id string, body AppStoreReviewAttachmentsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreReviewAttachmentsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewDetailsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreReviewDetailsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewDetailsCreateInstance(ctx context.Context, body AppStoreReviewDetailsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreReviewDetailsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewDetailsGetInstance(ctx context.Context, id string, params *AppStoreReviewDetailsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppStoreReviewDetailsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewDetailsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreReviewDetailsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewDetailsUpdateInstance(ctx context.Context, id string, body AppStoreReviewDetailsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreReviewDetailsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(ctx context.Context, id string, params *AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsCreateInstance(ctx context.Context, body AppStoreVersionLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsGetInstance(ctx context.Context, id string, params *AppStoreVersionLocalizationsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsUpdateInstance(ctx context.Context, id string, body AppStoreVersionLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionPhasedReleasesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionPhasedReleasesCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionPhasedReleasesCreateInstance(ctx context.Context, body AppStoreVersionPhasedReleasesCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionPhasedReleasesCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionPhasedReleasesDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppStoreVersionPhasedReleasesDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionPhasedReleasesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionPhasedReleasesUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionPhasedReleasesUpdateInstance(ctx context.Context, id string, body AppStoreVersionPhasedReleasesUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionPhasedReleasesUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionSubmissionsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionSubmissionsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionSubmissionsCreateInstance(ctx context.Context, body AppStoreVersionSubmissionsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionSubmissionsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionSubmissionsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppStoreVersionSubmissionsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsCreateInstance(ctx context.Context, body AppStoreVersionsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppStoreVersionsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsGetInstance(ctx context.Context, id string, params *AppStoreVersionsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsUpdateInstance(ctx context.Context, id string, body AppStoreVersionsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsBuildGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsBuildGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsBuildGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsIdfaDeclarationGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsBuildGetToOneRelationship(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewAppStoreVersionsBuildGetToOneRelationshipRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsBuildUpdateToOneRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppStoreVersionsBuildUpdateToOneRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsBuildUpdateToOneRelationship(ctx context.Context, id string, body AppStoreVersionsBuildUpdateToOneRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewAppStoreVersionsBuildUpdateToOneRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx context.Context, id string, params *AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsGetCollection(ctx context.Context, params *AppsGetCollectionParams) (*http.Response, error) {
	req, err := NewAppsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsGetInstance(ctx context.Context, id string, params *AppsGetInstanceParams) (*http.Response, error) {
	req, err := NewAppsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsUpdateInstance(ctx context.Context, id string, body AppsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewAppsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsAppInfosGetToManyRelated(ctx context.Context, id string, params *AppsAppInfosGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsAppInfosGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsAppStoreVersionsGetToManyRelated(ctx context.Context, id string, params *AppsAppStoreVersionsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsAppStoreVersionsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsAvailableTerritoriesGetToManyRelated(ctx context.Context, id string, params *AppsAvailableTerritoriesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsAvailableTerritoriesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBetaAppLocalizationsGetToManyRelated(ctx context.Context, id string, params *AppsBetaAppLocalizationsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsBetaAppLocalizationsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBetaAppReviewDetailGetToOneRelated(ctx context.Context, id string, params *AppsBetaAppReviewDetailGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppsBetaAppReviewDetailGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBetaGroupsGetToManyRelated(ctx context.Context, id string, params *AppsBetaGroupsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsBetaGroupsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBetaLicenseAgreementGetToOneRelated(ctx context.Context, id string, params *AppsBetaLicenseAgreementGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppsBetaLicenseAgreementGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBuildsGetToManyRelated(ctx context.Context, id string, params *AppsBuildsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsBuildsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsEndUserLicenseAgreementGetToOneRelated(ctx context.Context, id string, params *AppsEndUserLicenseAgreementGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppsEndUserLicenseAgreementGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsGameCenterEnabledVersionsGetToManyRelated(ctx context.Context, id string, params *AppsGameCenterEnabledVersionsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsGameCenterEnabledVersionsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsInAppPurchasesGetToManyRelated(ctx context.Context, id string, params *AppsInAppPurchasesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsInAppPurchasesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string, params *AppsPerfPowerMetricsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsPerfPowerMetricsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsPreOrderGetToOneRelated(ctx context.Context, id string, params *AppsPreOrderGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewAppsPreOrderGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsPreReleaseVersionsGetToManyRelated(ctx context.Context, id string, params *AppsPreReleaseVersionsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsPreReleaseVersionsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsPricesGetToManyRelated(ctx context.Context, id string, params *AppsPricesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewAppsPricesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBetaTestersDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewAppsBetaTestersDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) AppsBetaTestersDeleteToManyRelationship(ctx context.Context, id string, body AppsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewAppsBetaTestersDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsGetCollection(ctx context.Context, params *BetaAppLocalizationsGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsCreateInstance(ctx context.Context, body BetaAppLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsGetInstance(ctx context.Context, id string, params *BetaAppLocalizationsGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsUpdateInstance(ctx context.Context, id string, body BetaAppLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppLocalizationsAppGetToOneRelated(ctx context.Context, id string, params *BetaAppLocalizationsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBetaAppLocalizationsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewDetailsGetCollection(ctx context.Context, params *BetaAppReviewDetailsGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaAppReviewDetailsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewDetailsGetInstance(ctx context.Context, id string, params *BetaAppReviewDetailsGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaAppReviewDetailsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewDetailsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaAppReviewDetailsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewDetailsUpdateInstance(ctx context.Context, id string, body BetaAppReviewDetailsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaAppReviewDetailsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewDetailsAppGetToOneRelated(ctx context.Context, id string, params *BetaAppReviewDetailsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBetaAppReviewDetailsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewSubmissionsGetCollection(ctx context.Context, params *BetaAppReviewSubmissionsGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaAppReviewSubmissionsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewSubmissionsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaAppReviewSubmissionsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewSubmissionsCreateInstance(ctx context.Context, body BetaAppReviewSubmissionsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaAppReviewSubmissionsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewSubmissionsGetInstance(ctx context.Context, id string, params *BetaAppReviewSubmissionsGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaAppReviewSubmissionsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaAppReviewSubmissionsBuildGetToOneRelated(ctx context.Context, id string, params *BetaAppReviewSubmissionsBuildGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBetaAppReviewSubmissionsBuildGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsGetCollection(ctx context.Context, params *BetaBuildLocalizationsGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsCreateInstance(ctx context.Context, body BetaBuildLocalizationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsGetInstance(ctx context.Context, id string, params *BetaBuildLocalizationsGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsUpdateInstance(ctx context.Context, id string, body BetaBuildLocalizationsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaBuildLocalizationsBuildGetToOneRelated(ctx context.Context, id string, params *BetaBuildLocalizationsBuildGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBetaBuildLocalizationsBuildGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsGetCollection(ctx context.Context, params *BetaGroupsGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaGroupsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaGroupsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsCreateInstance(ctx context.Context, body BetaGroupsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaGroupsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBetaGroupsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsGetInstance(ctx context.Context, id string, params *BetaGroupsGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaGroupsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaGroupsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsUpdateInstance(ctx context.Context, id string, body BetaGroupsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaGroupsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsAppGetToOneRelated(ctx context.Context, id string, params *BetaGroupsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBetaGroupsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBetaTestersGetToManyRelated(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBetaGroupsBetaTestersGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBuildsGetToManyRelated(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBetaGroupsBuildsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBetaTestersDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaGroupsBetaTestersDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBetaTestersDeleteToManyRelationship(ctx context.Context, id string, body BetaGroupsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaGroupsBetaTestersDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBetaTestersGetToManyRelationship(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewBetaGroupsBetaTestersGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBetaTestersCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaGroupsBetaTestersCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBetaTestersCreateToManyRelationship(ctx context.Context, id string, body BetaGroupsBetaTestersCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaGroupsBetaTestersCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBuildsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaGroupsBuildsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBuildsDeleteToManyRelationship(ctx context.Context, id string, body BetaGroupsBuildsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaGroupsBuildsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBuildsGetToManyRelationship(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewBetaGroupsBuildsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBuildsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaGroupsBuildsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaGroupsBuildsCreateToManyRelationship(ctx context.Context, id string, body BetaGroupsBuildsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaGroupsBuildsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaLicenseAgreementsGetCollection(ctx context.Context, params *BetaLicenseAgreementsGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaLicenseAgreementsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaLicenseAgreementsGetInstance(ctx context.Context, id string, params *BetaLicenseAgreementsGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaLicenseAgreementsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaLicenseAgreementsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaLicenseAgreementsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaLicenseAgreementsUpdateInstance(ctx context.Context, id string, body BetaLicenseAgreementsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaLicenseAgreementsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaLicenseAgreementsAppGetToOneRelated(ctx context.Context, id string, params *BetaLicenseAgreementsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBetaLicenseAgreementsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTesterInvitationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTesterInvitationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTesterInvitationsCreateInstance(ctx context.Context, body BetaTesterInvitationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTesterInvitationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersGetCollection(ctx context.Context, params *BetaTestersGetCollectionParams) (*http.Response, error) {
	req, err := NewBetaTestersGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTestersCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersCreateInstance(ctx context.Context, body BetaTestersCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTestersCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBetaTestersDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersGetInstance(ctx context.Context, id string, params *BetaTestersGetInstanceParams) (*http.Response, error) {
	req, err := NewBetaTestersGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersAppsGetToManyRelated(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBetaTestersAppsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBetaGroupsGetToManyRelated(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBetaTestersBetaGroupsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBuildsGetToManyRelated(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBetaTestersBuildsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersAppsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTestersAppsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersAppsDeleteToManyRelationship(ctx context.Context, id string, body BetaTestersAppsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTestersAppsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersAppsGetToManyRelationship(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewBetaTestersAppsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBetaGroupsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTestersBetaGroupsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBetaGroupsDeleteToManyRelationship(ctx context.Context, id string, body BetaTestersBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTestersBetaGroupsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBetaGroupsGetToManyRelationship(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewBetaTestersBetaGroupsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBetaGroupsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTestersBetaGroupsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBetaGroupsCreateToManyRelationship(ctx context.Context, id string, body BetaTestersBetaGroupsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTestersBetaGroupsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBuildsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTestersBuildsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBuildsDeleteToManyRelationship(ctx context.Context, id string, body BetaTestersBuildsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTestersBuildsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBuildsGetToManyRelationship(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewBetaTestersBuildsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBuildsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBetaTestersBuildsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BetaTestersBuildsCreateToManyRelationship(ctx context.Context, id string, body BetaTestersBuildsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBetaTestersBuildsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaDetailsGetCollection(ctx context.Context, params *BuildBetaDetailsGetCollectionParams) (*http.Response, error) {
	req, err := NewBuildBetaDetailsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaDetailsGetInstance(ctx context.Context, id string, params *BuildBetaDetailsGetInstanceParams) (*http.Response, error) {
	req, err := NewBuildBetaDetailsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaDetailsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildBetaDetailsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaDetailsUpdateInstance(ctx context.Context, id string, body BuildBetaDetailsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildBetaDetailsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaDetailsBuildGetToOneRelated(ctx context.Context, id string, params *BuildBetaDetailsBuildGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildBetaDetailsBuildGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaNotificationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildBetaNotificationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildBetaNotificationsCreateInstance(ctx context.Context, body BuildBetaNotificationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildBetaNotificationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsGetCollection(ctx context.Context, params *BuildsGetCollectionParams) (*http.Response, error) {
	req, err := NewBuildsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsGetInstance(ctx context.Context, id string, params *BuildsGetInstanceParams) (*http.Response, error) {
	req, err := NewBuildsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsUpdateInstance(ctx context.Context, id string, body BuildsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsAppGetToOneRelated(ctx context.Context, id string, params *BuildsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsAppEncryptionDeclarationGetToOneRelated(ctx context.Context, id string, params *BuildsAppEncryptionDeclarationGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildsAppEncryptionDeclarationGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsAppStoreVersionGetToOneRelated(ctx context.Context, id string, params *BuildsAppStoreVersionGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildsAppStoreVersionGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBetaAppReviewSubmissionGetToOneRelated(ctx context.Context, id string, params *BuildsBetaAppReviewSubmissionGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildsBetaAppReviewSubmissionGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBetaBuildLocalizationsGetToManyRelated(ctx context.Context, id string, params *BuildsBetaBuildLocalizationsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBuildsBetaBuildLocalizationsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBuildBetaDetailGetToOneRelated(ctx context.Context, id string, params *BuildsBuildBetaDetailGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildsBuildBetaDetailGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsDiagnosticSignaturesGetToManyRelated(ctx context.Context, id string, params *BuildsDiagnosticSignaturesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBuildsDiagnosticSignaturesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIconsGetToManyRelated(ctx context.Context, id string, params *BuildsIconsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBuildsIconsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIndividualTestersGetToManyRelated(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBuildsIndividualTestersGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string, params *BuildsPerfPowerMetricsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBuildsPerfPowerMetricsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsPreReleaseVersionGetToOneRelated(ctx context.Context, id string, params *BuildsPreReleaseVersionGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBuildsPreReleaseVersionGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsAppEncryptionDeclarationGetToOneRelationship(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBuildsAppEncryptionDeclarationGetToOneRelationshipRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx context.Context, id string, body BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBetaGroupsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildsBetaGroupsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBetaGroupsDeleteToManyRelationship(ctx context.Context, id string, body BuildsBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildsBetaGroupsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBetaGroupsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildsBetaGroupsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsBetaGroupsCreateToManyRelationship(ctx context.Context, id string, body BuildsBetaGroupsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildsBetaGroupsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIndividualTestersDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildsIndividualTestersDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIndividualTestersDeleteToManyRelationship(ctx context.Context, id string, body BuildsIndividualTestersDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildsIndividualTestersDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIndividualTestersGetToManyRelationship(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewBuildsIndividualTestersGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIndividualTestersCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBuildsIndividualTestersCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BuildsIndividualTestersCreateToManyRelationship(ctx context.Context, id string, body BuildsIndividualTestersCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewBuildsIndividualTestersCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdCapabilitiesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBundleIdCapabilitiesCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdCapabilitiesCreateInstance(ctx context.Context, body BundleIdCapabilitiesCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBundleIdCapabilitiesCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdCapabilitiesDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBundleIdCapabilitiesDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdCapabilitiesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBundleIdCapabilitiesUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdCapabilitiesUpdateInstance(ctx context.Context, id string, body BundleIdCapabilitiesUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBundleIdCapabilitiesUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsGetCollection(ctx context.Context, params *BundleIdsGetCollectionParams) (*http.Response, error) {
	req, err := NewBundleIdsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBundleIdsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsCreateInstance(ctx context.Context, body BundleIdsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBundleIdsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewBundleIdsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsGetInstance(ctx context.Context, id string, params *BundleIdsGetInstanceParams) (*http.Response, error) {
	req, err := NewBundleIdsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewBundleIdsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsUpdateInstance(ctx context.Context, id string, body BundleIdsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewBundleIdsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsAppGetToOneRelated(ctx context.Context, id string, params *BundleIdsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewBundleIdsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsBundleIdCapabilitiesGetToManyRelated(ctx context.Context, id string, params *BundleIdsBundleIdCapabilitiesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBundleIdsBundleIdCapabilitiesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) BundleIdsProfilesGetToManyRelated(ctx context.Context, id string, params *BundleIdsProfilesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewBundleIdsProfilesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CertificatesGetCollection(ctx context.Context, params *CertificatesGetCollectionParams) (*http.Response, error) {
	req, err := NewCertificatesGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CertificatesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCertificatesCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CertificatesCreateInstance(ctx context.Context, body CertificatesCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewCertificatesCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CertificatesDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewCertificatesDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CertificatesGetInstance(ctx context.Context, id string, params *CertificatesGetInstanceParams) (*http.Response, error) {
	req, err := NewCertificatesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DevicesGetCollection(ctx context.Context, params *DevicesGetCollectionParams) (*http.Response, error) {
	req, err := NewDevicesGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DevicesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewDevicesCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DevicesCreateInstance(ctx context.Context, body DevicesCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewDevicesCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DevicesGetInstance(ctx context.Context, id string, params *DevicesGetInstanceParams) (*http.Response, error) {
	req, err := NewDevicesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DevicesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewDevicesUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DevicesUpdateInstance(ctx context.Context, id string, body DevicesUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewDevicesUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DiagnosticSignaturesLogsGetToManyRelated(ctx context.Context, id string, params *DiagnosticSignaturesLogsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewDiagnosticSignaturesLogsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsCreateInstance(ctx context.Context, body EndUserLicenseAgreementsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsGetInstance(ctx context.Context, id string, params *EndUserLicenseAgreementsGetInstanceParams) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsUpdateInstance(ctx context.Context, id string, body EndUserLicenseAgreementsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) EndUserLicenseAgreementsTerritoriesGetToManyRelated(ctx context.Context, id string, params *EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewEndUserLicenseAgreementsTerritoriesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) FinanceReportsGetCollection(ctx context.Context, params *FinanceReportsGetCollectionParams) (*http.Response, error) {
	req, err := NewFinanceReportsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IdfaDeclarationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewIdfaDeclarationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IdfaDeclarationsCreateInstance(ctx context.Context, body IdfaDeclarationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewIdfaDeclarationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IdfaDeclarationsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewIdfaDeclarationsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IdfaDeclarationsUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewIdfaDeclarationsUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) IdfaDeclarationsUpdateInstance(ctx context.Context, id string, body IdfaDeclarationsUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewIdfaDeclarationsUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) InAppPurchasesGetInstance(ctx context.Context, id string, params *InAppPurchasesGetInstanceParams) (*http.Response, error) {
	req, err := NewInAppPurchasesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PreReleaseVersionsGetCollection(ctx context.Context, params *PreReleaseVersionsGetCollectionParams) (*http.Response, error) {
	req, err := NewPreReleaseVersionsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PreReleaseVersionsGetInstance(ctx context.Context, id string, params *PreReleaseVersionsGetInstanceParams) (*http.Response, error) {
	req, err := NewPreReleaseVersionsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PreReleaseVersionsAppGetToOneRelated(ctx context.Context, id string, params *PreReleaseVersionsAppGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewPreReleaseVersionsAppGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PreReleaseVersionsBuildsGetToManyRelated(ctx context.Context, id string, params *PreReleaseVersionsBuildsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewPreReleaseVersionsBuildsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesGetCollection(ctx context.Context, params *ProfilesGetCollectionParams) (*http.Response, error) {
	req, err := NewProfilesGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewProfilesCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesCreateInstance(ctx context.Context, body ProfilesCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewProfilesCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewProfilesDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesGetInstance(ctx context.Context, id string, params *ProfilesGetInstanceParams) (*http.Response, error) {
	req, err := NewProfilesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesBundleIdGetToOneRelated(ctx context.Context, id string, params *ProfilesBundleIdGetToOneRelatedParams) (*http.Response, error) {
	req, err := NewProfilesBundleIdGetToOneRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesCertificatesGetToManyRelated(ctx context.Context, id string, params *ProfilesCertificatesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewProfilesCertificatesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ProfilesDevicesGetToManyRelated(ctx context.Context, id string, params *ProfilesDevicesGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewProfilesDevicesGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RoutingAppCoveragesCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewRoutingAppCoveragesCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RoutingAppCoveragesCreateInstance(ctx context.Context, body RoutingAppCoveragesCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewRoutingAppCoveragesCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RoutingAppCoveragesDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewRoutingAppCoveragesDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RoutingAppCoveragesGetInstance(ctx context.Context, id string, params *RoutingAppCoveragesGetInstanceParams) (*http.Response, error) {
	req, err := NewRoutingAppCoveragesGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RoutingAppCoveragesUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewRoutingAppCoveragesUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) RoutingAppCoveragesUpdateInstance(ctx context.Context, id string, body RoutingAppCoveragesUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewRoutingAppCoveragesUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SalesReportsGetCollection(ctx context.Context, params *SalesReportsGetCollectionParams) (*http.Response, error) {
	req, err := NewSalesReportsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) TerritoriesGetCollection(ctx context.Context, params *TerritoriesGetCollectionParams) (*http.Response, error) {
	req, err := NewTerritoriesGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UserInvitationsGetCollection(ctx context.Context, params *UserInvitationsGetCollectionParams) (*http.Response, error) {
	req, err := NewUserInvitationsGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UserInvitationsCreateInstanceWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUserInvitationsCreateInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UserInvitationsCreateInstance(ctx context.Context, body UserInvitationsCreateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewUserInvitationsCreateInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UserInvitationsDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewUserInvitationsDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UserInvitationsGetInstance(ctx context.Context, id string, params *UserInvitationsGetInstanceParams) (*http.Response, error) {
	req, err := NewUserInvitationsGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UserInvitationsVisibleAppsGetToManyRelated(ctx context.Context, id string, params *UserInvitationsVisibleAppsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewUserInvitationsVisibleAppsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGetCollection(ctx context.Context, params *UsersGetCollectionParams) (*http.Response, error) {
	req, err := NewUsersGetCollectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDeleteInstance(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewUsersDeleteInstanceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersGetInstance(ctx context.Context, id string, params *UsersGetInstanceParams) (*http.Response, error) {
	req, err := NewUsersGetInstanceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateInstanceWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUsersUpdateInstanceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdateInstance(ctx context.Context, id string, body UsersUpdateInstanceJSONRequestBody) (*http.Response, error) {
	req, err := NewUsersUpdateInstanceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsDeleteToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUsersVisibleAppsDeleteToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsDeleteToManyRelationship(ctx context.Context, id string, body UsersVisibleAppsDeleteToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewUsersVisibleAppsDeleteToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsGetToManyRelationship(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelationshipParams) (*http.Response, error) {
	req, err := NewUsersVisibleAppsGetToManyRelationshipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsReplaceToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUsersVisibleAppsReplaceToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsReplaceToManyRelationship(ctx context.Context, id string, body UsersVisibleAppsReplaceToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewUsersVisibleAppsReplaceToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsCreateToManyRelationshipWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUsersVisibleAppsCreateToManyRelationshipRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsCreateToManyRelationship(ctx context.Context, id string, body UsersVisibleAppsCreateToManyRelationshipJSONRequestBody) (*http.Response, error) {
	req, err := NewUsersVisibleAppsCreateToManyRelationshipRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UsersVisibleAppsGetToManyRelated(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelatedParams) (*http.Response, error) {
	req, err := NewUsersVisibleAppsGetToManyRelatedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewAgeRatingDeclarationsUpdateInstanceRequest calls the generic AgeRatingDeclarationsUpdateInstance builder with application/json body
func NewAgeRatingDeclarationsUpdateInstanceRequest(server string, id string, body AgeRatingDeclarationsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgeRatingDeclarationsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAgeRatingDeclarationsUpdateInstanceRequestWithBody generates requests for AgeRatingDeclarationsUpdateInstance with any type of body
func NewAgeRatingDeclarationsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/ageRatingDeclarations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppCategoriesGetCollectionRequest generates requests for AppCategoriesGetCollection
func NewAppCategoriesGetCollectionRequest(server string, params *AppCategoriesGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appCategories")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterPlatforms != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platforms]", *params.FilterPlatforms); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExistsParent != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "exists[parent]", *params.ExistsParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitSubcategories != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[subcategories]", *params.LimitSubcategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCategoriesGetInstanceRequest generates requests for AppCategoriesGetInstance
func NewAppCategoriesGetInstanceRequest(server string, id string, params *AppCategoriesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appCategories/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitSubcategories != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[subcategories]", *params.LimitSubcategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCategoriesParentGetToOneRelatedRequest generates requests for AppCategoriesParentGetToOneRelated
func NewAppCategoriesParentGetToOneRelatedRequest(server string, id string, params *AppCategoriesParentGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appCategories/%s/parent", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppCategoriesSubcategoriesGetToManyRelatedRequest generates requests for AppCategoriesSubcategoriesGetToManyRelated
func NewAppCategoriesSubcategoriesGetToManyRelatedRequest(server string, id string, params *AppCategoriesSubcategoriesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appCategories/%s/subcategories", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppEncryptionDeclarationsGetCollectionRequest generates requests for AppEncryptionDeclarationsGetCollection
func NewAppEncryptionDeclarationsGetCollectionRequest(server string, params *AppEncryptionDeclarationsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appEncryptionDeclarations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[builds]", *params.FilterBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppEncryptionDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appEncryptionDeclarations]", *params.FieldsAppEncryptionDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppEncryptionDeclarationsGetInstanceRequest generates requests for AppEncryptionDeclarationsGetInstance
func NewAppEncryptionDeclarationsGetInstanceRequest(server string, id string, params *AppEncryptionDeclarationsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appEncryptionDeclarations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppEncryptionDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appEncryptionDeclarations]", *params.FieldsAppEncryptionDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppEncryptionDeclarationsAppGetToOneRelatedRequest generates requests for AppEncryptionDeclarationsAppGetToOneRelated
func NewAppEncryptionDeclarationsAppGetToOneRelatedRequest(server string, id string, params *AppEncryptionDeclarationsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appEncryptionDeclarations/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequest calls the generic AppEncryptionDeclarationsBuildsCreateToManyRelationship builder with application/json body
func NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequest(server string, id string, body AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequestWithBody generates requests for AppEncryptionDeclarationsBuildsCreateToManyRelationship with any type of body
func NewAppEncryptionDeclarationsBuildsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appEncryptionDeclarations/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppInfoLocalizationsCreateInstanceRequest calls the generic AppInfoLocalizationsCreateInstance builder with application/json body
func NewAppInfoLocalizationsCreateInstanceRequest(server string, body AppInfoLocalizationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppInfoLocalizationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppInfoLocalizationsCreateInstanceRequestWithBody generates requests for AppInfoLocalizationsCreateInstance with any type of body
func NewAppInfoLocalizationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfoLocalizations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppInfoLocalizationsDeleteInstanceRequest generates requests for AppInfoLocalizationsDeleteInstance
func NewAppInfoLocalizationsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfoLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfoLocalizationsGetInstanceRequest generates requests for AppInfoLocalizationsGetInstance
func NewAppInfoLocalizationsGetInstanceRequest(server string, id string, params *AppInfoLocalizationsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfoLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppInfoLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfoLocalizations]", *params.FieldsAppInfoLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfoLocalizationsUpdateInstanceRequest calls the generic AppInfoLocalizationsUpdateInstance builder with application/json body
func NewAppInfoLocalizationsUpdateInstanceRequest(server string, id string, body AppInfoLocalizationsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppInfoLocalizationsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppInfoLocalizationsUpdateInstanceRequestWithBody generates requests for AppInfoLocalizationsUpdateInstance with any type of body
func NewAppInfoLocalizationsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfoLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppInfosGetInstanceRequest generates requests for AppInfosGetInstance
func NewAppInfosGetInstanceRequest(server string, id string, params *AppInfosGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfos]", *params.FieldsAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppInfoLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfoLocalizations]", *params.FieldsAppInfoLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppInfoLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appInfoLocalizations]", *params.LimitAppInfoLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosUpdateInstanceRequest calls the generic AppInfosUpdateInstance builder with application/json body
func NewAppInfosUpdateInstanceRequest(server string, id string, body AppInfosUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppInfosUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppInfosUpdateInstanceRequestWithBody generates requests for AppInfosUpdateInstance with any type of body
func NewAppInfosUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppInfosAppInfoLocalizationsGetToManyRelatedRequest generates requests for AppInfosAppInfoLocalizationsGetToManyRelated
func NewAppInfosAppInfoLocalizationsGetToManyRelatedRequest(server string, id string, params *AppInfosAppInfoLocalizationsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/appInfoLocalizations", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterLocale != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[locale]", *params.FilterLocale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfos]", *params.FieldsAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppInfoLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfoLocalizations]", *params.FieldsAppInfoLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosPrimaryCategoryGetToOneRelatedRequest generates requests for AppInfosPrimaryCategoryGetToOneRelated
func NewAppInfosPrimaryCategoryGetToOneRelatedRequest(server string, id string, params *AppInfosPrimaryCategoryGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/primaryCategory", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosPrimarySubcategoryOneGetToOneRelatedRequest generates requests for AppInfosPrimarySubcategoryOneGetToOneRelated
func NewAppInfosPrimarySubcategoryOneGetToOneRelatedRequest(server string, id string, params *AppInfosPrimarySubcategoryOneGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/primarySubcategoryOne", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest generates requests for AppInfosPrimarySubcategoryTwoGetToOneRelated
func NewAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest(server string, id string, params *AppInfosPrimarySubcategoryTwoGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/primarySubcategoryTwo", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosSecondaryCategoryGetToOneRelatedRequest generates requests for AppInfosSecondaryCategoryGetToOneRelated
func NewAppInfosSecondaryCategoryGetToOneRelatedRequest(server string, id string, params *AppInfosSecondaryCategoryGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/secondaryCategory", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosSecondarySubcategoryOneGetToOneRelatedRequest generates requests for AppInfosSecondarySubcategoryOneGetToOneRelated
func NewAppInfosSecondarySubcategoryOneGetToOneRelatedRequest(server string, id string, params *AppInfosSecondarySubcategoryOneGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/secondarySubcategoryOne", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest generates requests for AppInfosSecondarySubcategoryTwoGetToOneRelated
func NewAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest(server string, id string, params *AppInfosSecondarySubcategoryTwoGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appInfos/%s/secondarySubcategoryTwo", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreOrdersCreateInstanceRequest calls the generic AppPreOrdersCreateInstance builder with application/json body
func NewAppPreOrdersCreateInstanceRequest(server string, body AppPreOrdersCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppPreOrdersCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppPreOrdersCreateInstanceRequestWithBody generates requests for AppPreOrdersCreateInstance with any type of body
func NewAppPreOrdersCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreOrders")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppPreOrdersDeleteInstanceRequest generates requests for AppPreOrdersDeleteInstance
func NewAppPreOrdersDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreOrders/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreOrdersGetInstanceRequest generates requests for AppPreOrdersGetInstance
func NewAppPreOrdersGetInstanceRequest(server string, id string, params *AppPreOrdersGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreOrders/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPreOrders != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreOrders]", *params.FieldsAppPreOrders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreOrdersUpdateInstanceRequest calls the generic AppPreOrdersUpdateInstance builder with application/json body
func NewAppPreOrdersUpdateInstanceRequest(server string, id string, body AppPreOrdersUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppPreOrdersUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppPreOrdersUpdateInstanceRequestWithBody generates requests for AppPreOrdersUpdateInstance with any type of body
func NewAppPreOrdersUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreOrders/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppPreviewSetsCreateInstanceRequest calls the generic AppPreviewSetsCreateInstance builder with application/json body
func NewAppPreviewSetsCreateInstanceRequest(server string, body AppPreviewSetsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppPreviewSetsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppPreviewSetsCreateInstanceRequestWithBody generates requests for AppPreviewSetsCreateInstance with any type of body
func NewAppPreviewSetsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviewSets")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppPreviewSetsDeleteInstanceRequest generates requests for AppPreviewSetsDeleteInstance
func NewAppPreviewSetsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviewSets/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreviewSetsGetInstanceRequest generates requests for AppPreviewSetsGetInstance
func NewAppPreviewSetsGetInstanceRequest(server string, id string, params *AppPreviewSetsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviewSets/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPreviewSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviewSets]", *params.FieldsAppPreviewSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreviews != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviews]", *params.FieldsAppPreviews); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppPreviews != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appPreviews]", *params.LimitAppPreviews); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreviewSetsAppPreviewsGetToManyRelatedRequest generates requests for AppPreviewSetsAppPreviewsGetToManyRelated
func NewAppPreviewSetsAppPreviewsGetToManyRelatedRequest(server string, id string, params *AppPreviewSetsAppPreviewsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviewSets/%s/appPreviews", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPreviews != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviews]", *params.FieldsAppPreviews); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreviewSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviewSets]", *params.FieldsAppPreviewSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreviewSetsAppPreviewsGetToManyRelationshipRequest generates requests for AppPreviewSetsAppPreviewsGetToManyRelationship
func NewAppPreviewSetsAppPreviewsGetToManyRelationshipRequest(server string, id string, params *AppPreviewSetsAppPreviewsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviewSets/%s/relationships/appPreviews", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequest calls the generic AppPreviewSetsAppPreviewsReplaceToManyRelationship builder with application/json body
func NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequest(server string, id string, body AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequestWithBody generates requests for AppPreviewSetsAppPreviewsReplaceToManyRelationship with any type of body
func NewAppPreviewSetsAppPreviewsReplaceToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviewSets/%s/relationships/appPreviews", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppPreviewsCreateInstanceRequest calls the generic AppPreviewsCreateInstance builder with application/json body
func NewAppPreviewsCreateInstanceRequest(server string, body AppPreviewsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppPreviewsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppPreviewsCreateInstanceRequestWithBody generates requests for AppPreviewsCreateInstance with any type of body
func NewAppPreviewsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviews")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppPreviewsDeleteInstanceRequest generates requests for AppPreviewsDeleteInstance
func NewAppPreviewsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviews/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreviewsGetInstanceRequest generates requests for AppPreviewsGetInstance
func NewAppPreviewsGetInstanceRequest(server string, id string, params *AppPreviewsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviews/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPreviews != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviews]", *params.FieldsAppPreviews); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPreviewsUpdateInstanceRequest calls the generic AppPreviewsUpdateInstance builder with application/json body
func NewAppPreviewsUpdateInstanceRequest(server string, id string, body AppPreviewsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppPreviewsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppPreviewsUpdateInstanceRequestWithBody generates requests for AppPreviewsUpdateInstance with any type of body
func NewAppPreviewsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPreviews/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppPricePointsGetCollectionRequest generates requests for AppPricePointsGetCollection
func NewAppPricePointsGetCollectionRequest(server string, params *AppPricePointsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPricePoints")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterPriceTier != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[priceTier]", *params.FilterPriceTier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterTerritory != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[territory]", *params.FilterTerritory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPricePoints]", *params.FieldsAppPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPricePointsGetInstanceRequest generates requests for AppPricePointsGetInstance
func NewAppPricePointsGetInstanceRequest(server string, id string, params *AppPricePointsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPricePoints/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPricePoints]", *params.FieldsAppPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPricePointsTerritoryGetToOneRelatedRequest generates requests for AppPricePointsTerritoryGetToOneRelated
func NewAppPricePointsTerritoryGetToOneRelatedRequest(server string, id string, params *AppPricePointsTerritoryGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPricePoints/%s/territory", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPriceTiersGetCollectionRequest generates requests for AppPriceTiersGetCollection
func NewAppPriceTiersGetCollectionRequest(server string, params *AppPriceTiersGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPriceTiers")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPriceTiers != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPriceTiers]", *params.FieldsAppPriceTiers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPricePoints]", *params.FieldsAppPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[pricePoints]", *params.LimitPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPriceTiersGetInstanceRequest generates requests for AppPriceTiersGetInstance
func NewAppPriceTiersGetInstanceRequest(server string, id string, params *AppPriceTiersGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPriceTiers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPriceTiers != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPriceTiers]", *params.FieldsAppPriceTiers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPricePoints]", *params.FieldsAppPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[pricePoints]", *params.LimitPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPriceTiersPricePointsGetToManyRelatedRequest generates requests for AppPriceTiersPricePointsGetToManyRelated
func NewAppPriceTiersPricePointsGetToManyRelatedRequest(server string, id string, params *AppPriceTiersPricePointsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPriceTiers/%s/pricePoints", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPricePoints != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPricePoints]", *params.FieldsAppPricePoints); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppPricesGetInstanceRequest generates requests for AppPricesGetInstance
func NewAppPricesGetInstanceRequest(server string, id string, params *AppPricesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appPrices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPrices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPrices]", *params.FieldsAppPrices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotSetsCreateInstanceRequest calls the generic AppScreenshotSetsCreateInstance builder with application/json body
func NewAppScreenshotSetsCreateInstanceRequest(server string, body AppScreenshotSetsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppScreenshotSetsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppScreenshotSetsCreateInstanceRequestWithBody generates requests for AppScreenshotSetsCreateInstance with any type of body
func NewAppScreenshotSetsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshotSets")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppScreenshotSetsDeleteInstanceRequest generates requests for AppScreenshotSetsDeleteInstance
func NewAppScreenshotSetsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshotSets/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotSetsGetInstanceRequest generates requests for AppScreenshotSetsGetInstance
func NewAppScreenshotSetsGetInstanceRequest(server string, id string, params *AppScreenshotSetsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshotSets/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppScreenshotSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshotSets]", *params.FieldsAppScreenshotSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppScreenshots != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshots]", *params.FieldsAppScreenshots); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppScreenshots != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appScreenshots]", *params.LimitAppScreenshots); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotSetsAppScreenshotsGetToManyRelatedRequest generates requests for AppScreenshotSetsAppScreenshotsGetToManyRelated
func NewAppScreenshotSetsAppScreenshotsGetToManyRelatedRequest(server string, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshotSets/%s/appScreenshots", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppScreenshotSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshotSets]", *params.FieldsAppScreenshotSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppScreenshots != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshots]", *params.FieldsAppScreenshots); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotSetsAppScreenshotsGetToManyRelationshipRequest generates requests for AppScreenshotSetsAppScreenshotsGetToManyRelationship
func NewAppScreenshotSetsAppScreenshotsGetToManyRelationshipRequest(server string, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshotSets/%s/relationships/appScreenshots", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequest calls the generic AppScreenshotSetsAppScreenshotsReplaceToManyRelationship builder with application/json body
func NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequest(server string, id string, body AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequestWithBody generates requests for AppScreenshotSetsAppScreenshotsReplaceToManyRelationship with any type of body
func NewAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshotSets/%s/relationships/appScreenshots", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppScreenshotsCreateInstanceRequest calls the generic AppScreenshotsCreateInstance builder with application/json body
func NewAppScreenshotsCreateInstanceRequest(server string, body AppScreenshotsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppScreenshotsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppScreenshotsCreateInstanceRequestWithBody generates requests for AppScreenshotsCreateInstance with any type of body
func NewAppScreenshotsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshots")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppScreenshotsDeleteInstanceRequest generates requests for AppScreenshotsDeleteInstance
func NewAppScreenshotsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshots/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotsGetInstanceRequest generates requests for AppScreenshotsGetInstance
func NewAppScreenshotsGetInstanceRequest(server string, id string, params *AppScreenshotsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshots/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppScreenshots != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshots]", *params.FieldsAppScreenshots); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppScreenshotsUpdateInstanceRequest calls the generic AppScreenshotsUpdateInstance builder with application/json body
func NewAppScreenshotsUpdateInstanceRequest(server string, id string, body AppScreenshotsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppScreenshotsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppScreenshotsUpdateInstanceRequestWithBody generates requests for AppScreenshotsUpdateInstance with any type of body
func NewAppScreenshotsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appScreenshots/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreReviewAttachmentsCreateInstanceRequest calls the generic AppStoreReviewAttachmentsCreateInstance builder with application/json body
func NewAppStoreReviewAttachmentsCreateInstanceRequest(server string, body AppStoreReviewAttachmentsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreReviewAttachmentsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppStoreReviewAttachmentsCreateInstanceRequestWithBody generates requests for AppStoreReviewAttachmentsCreateInstance with any type of body
func NewAppStoreReviewAttachmentsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewAttachments")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreReviewAttachmentsDeleteInstanceRequest generates requests for AppStoreReviewAttachmentsDeleteInstance
func NewAppStoreReviewAttachmentsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewAttachments/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreReviewAttachmentsGetInstanceRequest generates requests for AppStoreReviewAttachmentsGetInstance
func NewAppStoreReviewAttachmentsGetInstanceRequest(server string, id string, params *AppStoreReviewAttachmentsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewAttachments/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreReviewAttachments != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewAttachments]", *params.FieldsAppStoreReviewAttachments); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreReviewAttachmentsUpdateInstanceRequest calls the generic AppStoreReviewAttachmentsUpdateInstance builder with application/json body
func NewAppStoreReviewAttachmentsUpdateInstanceRequest(server string, id string, body AppStoreReviewAttachmentsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreReviewAttachmentsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStoreReviewAttachmentsUpdateInstanceRequestWithBody generates requests for AppStoreReviewAttachmentsUpdateInstance with any type of body
func NewAppStoreReviewAttachmentsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewAttachments/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreReviewDetailsCreateInstanceRequest calls the generic AppStoreReviewDetailsCreateInstance builder with application/json body
func NewAppStoreReviewDetailsCreateInstanceRequest(server string, body AppStoreReviewDetailsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreReviewDetailsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppStoreReviewDetailsCreateInstanceRequestWithBody generates requests for AppStoreReviewDetailsCreateInstance with any type of body
func NewAppStoreReviewDetailsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewDetails")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreReviewDetailsGetInstanceRequest generates requests for AppStoreReviewDetailsGetInstance
func NewAppStoreReviewDetailsGetInstanceRequest(server string, id string, params *AppStoreReviewDetailsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewDetails/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewDetails]", *params.FieldsAppStoreReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreReviewAttachments != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewAttachments]", *params.FieldsAppStoreReviewAttachments); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppStoreReviewAttachments != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appStoreReviewAttachments]", *params.LimitAppStoreReviewAttachments); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreReviewDetailsUpdateInstanceRequest calls the generic AppStoreReviewDetailsUpdateInstance builder with application/json body
func NewAppStoreReviewDetailsUpdateInstanceRequest(server string, id string, body AppStoreReviewDetailsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreReviewDetailsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStoreReviewDetailsUpdateInstanceRequestWithBody generates requests for AppStoreReviewDetailsUpdateInstance with any type of body
func NewAppStoreReviewDetailsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewDetails/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedRequest generates requests for AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated
func NewAppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedRequest(server string, id string, params *AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreReviewDetails/%s/appStoreReviewAttachments", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewDetails]", *params.FieldsAppStoreReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreReviewAttachments != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewAttachments]", *params.FieldsAppStoreReviewAttachments); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionLocalizationsCreateInstanceRequest calls the generic AppStoreVersionLocalizationsCreateInstance builder with application/json body
func NewAppStoreVersionLocalizationsCreateInstanceRequest(server string, body AppStoreVersionLocalizationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionLocalizationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppStoreVersionLocalizationsCreateInstanceRequestWithBody generates requests for AppStoreVersionLocalizationsCreateInstance with any type of body
func NewAppStoreVersionLocalizationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionLocalizations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionLocalizationsDeleteInstanceRequest generates requests for AppStoreVersionLocalizationsDeleteInstance
func NewAppStoreVersionLocalizationsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionLocalizationsGetInstanceRequest generates requests for AppStoreVersionLocalizationsGetInstance
func NewAppStoreVersionLocalizationsGetInstanceRequest(server string, id string, params *AppStoreVersionLocalizationsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionLocalizations]", *params.FieldsAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppScreenshotSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshotSets]", *params.FieldsAppScreenshotSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreviewSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviewSets]", *params.FieldsAppPreviewSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppPreviewSets != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appPreviewSets]", *params.LimitAppPreviewSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppScreenshotSets != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appScreenshotSets]", *params.LimitAppScreenshotSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionLocalizationsUpdateInstanceRequest calls the generic AppStoreVersionLocalizationsUpdateInstance builder with application/json body
func NewAppStoreVersionLocalizationsUpdateInstanceRequest(server string, id string, body AppStoreVersionLocalizationsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionLocalizationsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStoreVersionLocalizationsUpdateInstanceRequestWithBody generates requests for AppStoreVersionLocalizationsUpdateInstance with any type of body
func NewAppStoreVersionLocalizationsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedRequest generates requests for AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated
func NewAppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedRequest(server string, id string, params *AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionLocalizations/%s/appPreviewSets", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterPreviewType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[previewType]", *params.FilterPreviewType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionLocalizations]", *params.FieldsAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreviews != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviews]", *params.FieldsAppPreviews); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreviewSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreviewSets]", *params.FieldsAppPreviewSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedRequest generates requests for AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated
func NewAppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedRequest(server string, id string, params *AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionLocalizations/%s/appScreenshotSets", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterScreenshotDisplayType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[screenshotDisplayType]", *params.FilterScreenshotDisplayType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionLocalizations]", *params.FieldsAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppScreenshotSets != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshotSets]", *params.FieldsAppScreenshotSets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppScreenshots != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appScreenshots]", *params.FieldsAppScreenshots); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionPhasedReleasesCreateInstanceRequest calls the generic AppStoreVersionPhasedReleasesCreateInstance builder with application/json body
func NewAppStoreVersionPhasedReleasesCreateInstanceRequest(server string, body AppStoreVersionPhasedReleasesCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionPhasedReleasesCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppStoreVersionPhasedReleasesCreateInstanceRequestWithBody generates requests for AppStoreVersionPhasedReleasesCreateInstance with any type of body
func NewAppStoreVersionPhasedReleasesCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionPhasedReleases")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionPhasedReleasesDeleteInstanceRequest generates requests for AppStoreVersionPhasedReleasesDeleteInstance
func NewAppStoreVersionPhasedReleasesDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionPhasedReleases/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionPhasedReleasesUpdateInstanceRequest calls the generic AppStoreVersionPhasedReleasesUpdateInstance builder with application/json body
func NewAppStoreVersionPhasedReleasesUpdateInstanceRequest(server string, id string, body AppStoreVersionPhasedReleasesUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionPhasedReleasesUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStoreVersionPhasedReleasesUpdateInstanceRequestWithBody generates requests for AppStoreVersionPhasedReleasesUpdateInstance with any type of body
func NewAppStoreVersionPhasedReleasesUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionPhasedReleases/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionSubmissionsCreateInstanceRequest calls the generic AppStoreVersionSubmissionsCreateInstance builder with application/json body
func NewAppStoreVersionSubmissionsCreateInstanceRequest(server string, body AppStoreVersionSubmissionsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionSubmissionsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppStoreVersionSubmissionsCreateInstanceRequestWithBody generates requests for AppStoreVersionSubmissionsCreateInstance with any type of body
func NewAppStoreVersionSubmissionsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionSubmissions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionSubmissionsDeleteInstanceRequest generates requests for AppStoreVersionSubmissionsDeleteInstance
func NewAppStoreVersionSubmissionsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersionSubmissions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsCreateInstanceRequest calls the generic AppStoreVersionsCreateInstance builder with application/json body
func NewAppStoreVersionsCreateInstanceRequest(server string, body AppStoreVersionsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewAppStoreVersionsCreateInstanceRequestWithBody generates requests for AppStoreVersionsCreateInstance with any type of body
func NewAppStoreVersionsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionsDeleteInstanceRequest generates requests for AppStoreVersionsDeleteInstance
func NewAppStoreVersionsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsGetInstanceRequest generates requests for AppStoreVersionsGetInstance
func NewAppStoreVersionsGetInstanceRequest(server string, id string, params *AppStoreVersionsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionLocalizations]", *params.FieldsAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsIdfaDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[idfaDeclarations]", *params.FieldsIdfaDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsRoutingAppCoverages != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[routingAppCoverages]", *params.FieldsRoutingAppCoverages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionPhasedReleases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionPhasedReleases]", *params.FieldsAppStoreVersionPhasedReleases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAgeRatingDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[ageRatingDeclarations]", *params.FieldsAgeRatingDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewDetails]", *params.FieldsAppStoreReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionSubmissions]", *params.FieldsAppStoreVersionSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appStoreVersionLocalizations]", *params.LimitAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsUpdateInstanceRequest calls the generic AppStoreVersionsUpdateInstance builder with application/json body
func NewAppStoreVersionsUpdateInstanceRequest(server string, id string, body AppStoreVersionsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStoreVersionsUpdateInstanceRequestWithBody generates requests for AppStoreVersionsUpdateInstance with any type of body
func NewAppStoreVersionsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest generates requests for AppStoreVersionsAgeRatingDeclarationGetToOneRelated
func NewAppStoreVersionsAgeRatingDeclarationGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/ageRatingDeclaration", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAgeRatingDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[ageRatingDeclarations]", *params.FieldsAgeRatingDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest generates requests for AppStoreVersionsAppStoreReviewDetailGetToOneRelated
func NewAppStoreVersionsAppStoreReviewDetailGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/appStoreReviewDetail", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewDetails]", *params.FieldsAppStoreReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreReviewAttachments != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewAttachments]", *params.FieldsAppStoreReviewAttachments); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest generates requests for AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated
func NewAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedRequest(server string, id string, params *AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/appStoreVersionLocalizations", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionLocalizations]", *params.FieldsAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest generates requests for AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated
func NewAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/appStoreVersionPhasedRelease", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreVersionPhasedReleases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionPhasedReleases]", *params.FieldsAppStoreVersionPhasedReleases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest generates requests for AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated
func NewAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/appStoreVersionSubmission", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionSubmissions]", *params.FieldsAppStoreVersionSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsBuildGetToOneRelatedRequest generates requests for AppStoreVersionsBuildGetToOneRelated
func NewAppStoreVersionsBuildGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsBuildGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/build", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest generates requests for AppStoreVersionsIdfaDeclarationGetToOneRelated
func NewAppStoreVersionsIdfaDeclarationGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsIdfaDeclarationGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/idfaDeclaration", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsIdfaDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[idfaDeclarations]", *params.FieldsIdfaDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsBuildGetToOneRelationshipRequest generates requests for AppStoreVersionsBuildGetToOneRelationship
func NewAppStoreVersionsBuildGetToOneRelationshipRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/relationships/build", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppStoreVersionsBuildUpdateToOneRelationshipRequest calls the generic AppStoreVersionsBuildUpdateToOneRelationship builder with application/json body
func NewAppStoreVersionsBuildUpdateToOneRelationshipRequest(server string, id string, body AppStoreVersionsBuildUpdateToOneRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppStoreVersionsBuildUpdateToOneRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppStoreVersionsBuildUpdateToOneRelationshipRequestWithBody generates requests for AppStoreVersionsBuildUpdateToOneRelationship with any type of body
func NewAppStoreVersionsBuildUpdateToOneRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/relationships/build", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest generates requests for AppStoreVersionsRoutingAppCoverageGetToOneRelated
func NewAppStoreVersionsRoutingAppCoverageGetToOneRelatedRequest(server string, id string, params *AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/appStoreVersions/%s/routingAppCoverage", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsRoutingAppCoverages != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[routingAppCoverages]", *params.FieldsRoutingAppCoverages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsGetCollectionRequest generates requests for AppsGetCollection
func NewAppsGetCollectionRequest(server string, params *AppsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterAppStoreVersionsAppStoreState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[appStoreVersions.appStoreState]", *params.FilterAppStoreVersionsAppStoreState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterAppStoreVersionsPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[appStoreVersions.platform]", *params.FilterAppStoreVersionsPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBundleId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[bundleId]", *params.FilterBundleId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[name]", *params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSku != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[sku]", *params.FilterSku); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[appStoreVersions]", *params.FilterAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExistsGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "exists[gameCenterEnabledVersions]", *params.ExistsGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPerfPowerMetrics != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[perfPowerMetrics]", *params.FieldsPerfPowerMetrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfos]", *params.FieldsAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreOrders != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreOrders]", *params.FieldsAppPreOrders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPrices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPrices]", *params.FieldsAppPrices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsInAppPurchases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[inAppPurchases]", *params.FieldsInAppPurchases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewDetails]", *params.FieldsBetaAppReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[gameCenterEnabledVersions]", *params.FieldsGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppLocalizations]", *params.FieldsBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaLicenseAgreements]", *params.FieldsBetaLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsEndUserLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[endUserLicenseAgreements]", *params.FieldsEndUserLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appInfos]", *params.LimitAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appStoreVersions]", *params.LimitAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAvailableTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[availableTerritories]", *params.LimitAvailableTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaAppLocalizations]", *params.LimitBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaGroups]", *params.LimitBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[gameCenterEnabledVersions]", *params.LimitGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitInAppPurchases != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[inAppPurchases]", *params.LimitInAppPurchases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[preReleaseVersions]", *params.LimitPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPrices != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[prices]", *params.LimitPrices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsGetInstanceRequest generates requests for AppsGetInstance
func NewAppsGetInstanceRequest(server string, id string, params *AppsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPerfPowerMetrics != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[perfPowerMetrics]", *params.FieldsPerfPowerMetrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfos]", *params.FieldsAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPreOrders != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreOrders]", *params.FieldsAppPreOrders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPrices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPrices]", *params.FieldsAppPrices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsInAppPurchases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[inAppPurchases]", *params.FieldsInAppPurchases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewDetails]", *params.FieldsBetaAppReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[gameCenterEnabledVersions]", *params.FieldsGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppLocalizations]", *params.FieldsBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaLicenseAgreements]", *params.FieldsBetaLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsEndUserLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[endUserLicenseAgreements]", *params.FieldsEndUserLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appInfos]", *params.LimitAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[appStoreVersions]", *params.LimitAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitAvailableTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[availableTerritories]", *params.LimitAvailableTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaAppLocalizations]", *params.LimitBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaGroups]", *params.LimitBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[gameCenterEnabledVersions]", *params.LimitGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitInAppPurchases != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[inAppPurchases]", *params.LimitInAppPurchases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[preReleaseVersions]", *params.LimitPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitPrices != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[prices]", *params.LimitPrices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsUpdateInstanceRequest calls the generic AppsUpdateInstance builder with application/json body
func NewAppsUpdateInstanceRequest(server string, id string, body AppsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppsUpdateInstanceRequestWithBody generates requests for AppsUpdateInstance with any type of body
func NewAppsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAppsAppInfosGetToManyRelatedRequest generates requests for AppsAppInfosGetToManyRelated
func NewAppsAppInfosGetToManyRelatedRequest(server string, id string, params *AppsAppInfosGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/appInfos", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppInfos != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfos]", *params.FieldsAppInfos); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppCategories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appCategories]", *params.FieldsAppCategories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppInfoLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appInfoLocalizations]", *params.FieldsAppInfoLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsAppStoreVersionsGetToManyRelatedRequest generates requests for AppsAppStoreVersionsGetToManyRelated
func NewAppsAppStoreVersionsGetToManyRelatedRequest(server string, id string, params *AppsAppStoreVersionsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/appStoreVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterAppStoreState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[appStoreState]", *params.FilterAppStoreState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVersionString != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[versionString]", *params.FilterVersionString); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsIdfaDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[idfaDeclarations]", *params.FieldsIdfaDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionLocalizations]", *params.FieldsAppStoreVersionLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsRoutingAppCoverages != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[routingAppCoverages]", *params.FieldsRoutingAppCoverages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionPhasedReleases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionPhasedReleases]", *params.FieldsAppStoreVersionPhasedReleases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAgeRatingDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[ageRatingDeclarations]", *params.FieldsAgeRatingDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreReviewDetails]", *params.FieldsAppStoreReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersionSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersionSubmissions]", *params.FieldsAppStoreVersionSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsAvailableTerritoriesGetToManyRelatedRequest generates requests for AppsAvailableTerritoriesGetToManyRelated
func NewAppsAvailableTerritoriesGetToManyRelatedRequest(server string, id string, params *AppsAvailableTerritoriesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/availableTerritories", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsBetaAppLocalizationsGetToManyRelatedRequest generates requests for AppsBetaAppLocalizationsGetToManyRelated
func NewAppsBetaAppLocalizationsGetToManyRelatedRequest(server string, id string, params *AppsBetaAppLocalizationsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/betaAppLocalizations", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppLocalizations]", *params.FieldsBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsBetaAppReviewDetailGetToOneRelatedRequest generates requests for AppsBetaAppReviewDetailGetToOneRelated
func NewAppsBetaAppReviewDetailGetToOneRelatedRequest(server string, id string, params *AppsBetaAppReviewDetailGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/betaAppReviewDetail", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaAppReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewDetails]", *params.FieldsBetaAppReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsBetaGroupsGetToManyRelatedRequest generates requests for AppsBetaGroupsGetToManyRelated
func NewAppsBetaGroupsGetToManyRelatedRequest(server string, id string, params *AppsBetaGroupsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsBetaLicenseAgreementGetToOneRelatedRequest generates requests for AppsBetaLicenseAgreementGetToOneRelated
func NewAppsBetaLicenseAgreementGetToOneRelatedRequest(server string, id string, params *AppsBetaLicenseAgreementGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/betaLicenseAgreement", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaLicenseAgreements]", *params.FieldsBetaLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsBuildsGetToManyRelatedRequest generates requests for AppsBuildsGetToManyRelated
func NewAppsBuildsGetToManyRelatedRequest(server string, id string, params *AppsBuildsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsEndUserLicenseAgreementGetToOneRelatedRequest generates requests for AppsEndUserLicenseAgreementGetToOneRelated
func NewAppsEndUserLicenseAgreementGetToOneRelatedRequest(server string, id string, params *AppsEndUserLicenseAgreementGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/endUserLicenseAgreement", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsEndUserLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[endUserLicenseAgreements]", *params.FieldsEndUserLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsGameCenterEnabledVersionsGetToManyRelatedRequest generates requests for AppsGameCenterEnabledVersionsGetToManyRelated
func NewAppsGameCenterEnabledVersionsGetToManyRelatedRequest(server string, id string, params *AppsGameCenterEnabledVersionsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/gameCenterEnabledVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVersionString != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[versionString]", *params.FilterVersionString); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[gameCenterEnabledVersions]", *params.FieldsGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsInAppPurchasesGetToManyRelatedRequest generates requests for AppsInAppPurchasesGetToManyRelated
func NewAppsInAppPurchasesGetToManyRelatedRequest(server string, id string, params *AppsInAppPurchasesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/inAppPurchases", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterInAppPurchaseType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[inAppPurchaseType]", *params.FilterInAppPurchaseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterCanBeSubmitted != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[canBeSubmitted]", *params.FilterCanBeSubmitted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsInAppPurchases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[inAppPurchases]", *params.FieldsInAppPurchases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsPerfPowerMetricsGetToManyRelatedRequest generates requests for AppsPerfPowerMetricsGetToManyRelated
func NewAppsPerfPowerMetricsGetToManyRelatedRequest(server string, id string, params *AppsPerfPowerMetricsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/perfPowerMetrics", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterDeviceType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[deviceType]", *params.FilterDeviceType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterMetricType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[metricType]", *params.FilterMetricType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsPreOrderGetToOneRelatedRequest generates requests for AppsPreOrderGetToOneRelated
func NewAppsPreOrderGetToOneRelatedRequest(server string, id string, params *AppsPreOrderGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/preOrder", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPreOrders != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPreOrders]", *params.FieldsAppPreOrders); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsPreReleaseVersionsGetToManyRelatedRequest generates requests for AppsPreReleaseVersionsGetToManyRelated
func NewAppsPreReleaseVersionsGetToManyRelatedRequest(server string, id string, params *AppsPreReleaseVersionsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/preReleaseVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsPricesGetToManyRelatedRequest generates requests for AppsPricesGetToManyRelated
func NewAppsPricesGetToManyRelatedRequest(server string, id string, params *AppsPricesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/prices", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppPrices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPrices]", *params.FieldsAppPrices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppPriceTiers != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appPriceTiers]", *params.FieldsAppPriceTiers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsBetaTestersDeleteToManyRelationshipRequest calls the generic AppsBetaTestersDeleteToManyRelationship builder with application/json body
func NewAppsBetaTestersDeleteToManyRelationshipRequest(server string, id string, body AppsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsBetaTestersDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAppsBetaTestersDeleteToManyRelationshipRequestWithBody generates requests for AppsBetaTestersDeleteToManyRelationship with any type of body
func NewAppsBetaTestersDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/apps/%s/relationships/betaTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaAppLocalizationsGetCollectionRequest generates requests for BetaAppLocalizationsGetCollection
func NewBetaAppLocalizationsGetCollectionRequest(server string, params *BetaAppLocalizationsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppLocalizations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterLocale != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[locale]", *params.FilterLocale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppLocalizations]", *params.FieldsBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppLocalizationsCreateInstanceRequest calls the generic BetaAppLocalizationsCreateInstance builder with application/json body
func NewBetaAppLocalizationsCreateInstanceRequest(server string, body BetaAppLocalizationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaAppLocalizationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBetaAppLocalizationsCreateInstanceRequestWithBody generates requests for BetaAppLocalizationsCreateInstance with any type of body
func NewBetaAppLocalizationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppLocalizations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaAppLocalizationsDeleteInstanceRequest generates requests for BetaAppLocalizationsDeleteInstance
func NewBetaAppLocalizationsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppLocalizationsGetInstanceRequest generates requests for BetaAppLocalizationsGetInstance
func NewBetaAppLocalizationsGetInstanceRequest(server string, id string, params *BetaAppLocalizationsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaAppLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppLocalizations]", *params.FieldsBetaAppLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppLocalizationsUpdateInstanceRequest calls the generic BetaAppLocalizationsUpdateInstance builder with application/json body
func NewBetaAppLocalizationsUpdateInstanceRequest(server string, id string, body BetaAppLocalizationsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaAppLocalizationsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaAppLocalizationsUpdateInstanceRequestWithBody generates requests for BetaAppLocalizationsUpdateInstance with any type of body
func NewBetaAppLocalizationsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaAppLocalizationsAppGetToOneRelatedRequest generates requests for BetaAppLocalizationsAppGetToOneRelated
func NewBetaAppLocalizationsAppGetToOneRelatedRequest(server string, id string, params *BetaAppLocalizationsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppLocalizations/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppReviewDetailsGetCollectionRequest generates requests for BetaAppReviewDetailsGetCollection
func NewBetaAppReviewDetailsGetCollectionRequest(server string, params *BetaAppReviewDetailsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewDetails")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", params.FilterApp); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.FieldsBetaAppReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewDetails]", *params.FieldsBetaAppReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppReviewDetailsGetInstanceRequest generates requests for BetaAppReviewDetailsGetInstance
func NewBetaAppReviewDetailsGetInstanceRequest(server string, id string, params *BetaAppReviewDetailsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewDetails/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaAppReviewDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewDetails]", *params.FieldsBetaAppReviewDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppReviewDetailsUpdateInstanceRequest calls the generic BetaAppReviewDetailsUpdateInstance builder with application/json body
func NewBetaAppReviewDetailsUpdateInstanceRequest(server string, id string, body BetaAppReviewDetailsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaAppReviewDetailsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaAppReviewDetailsUpdateInstanceRequestWithBody generates requests for BetaAppReviewDetailsUpdateInstance with any type of body
func NewBetaAppReviewDetailsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewDetails/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaAppReviewDetailsAppGetToOneRelatedRequest generates requests for BetaAppReviewDetailsAppGetToOneRelated
func NewBetaAppReviewDetailsAppGetToOneRelatedRequest(server string, id string, params *BetaAppReviewDetailsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewDetails/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppReviewSubmissionsGetCollectionRequest generates requests for BetaAppReviewSubmissionsGetCollection
func NewBetaAppReviewSubmissionsGetCollectionRequest(server string, params *BetaAppReviewSubmissionsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewSubmissions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterBetaReviewState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[betaReviewState]", *params.FilterBetaReviewState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[build]", params.FilterBuild); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.FieldsBetaAppReviewSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewSubmissions]", *params.FieldsBetaAppReviewSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppReviewSubmissionsCreateInstanceRequest calls the generic BetaAppReviewSubmissionsCreateInstance builder with application/json body
func NewBetaAppReviewSubmissionsCreateInstanceRequest(server string, body BetaAppReviewSubmissionsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaAppReviewSubmissionsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBetaAppReviewSubmissionsCreateInstanceRequestWithBody generates requests for BetaAppReviewSubmissionsCreateInstance with any type of body
func NewBetaAppReviewSubmissionsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewSubmissions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaAppReviewSubmissionsGetInstanceRequest generates requests for BetaAppReviewSubmissionsGetInstance
func NewBetaAppReviewSubmissionsGetInstanceRequest(server string, id string, params *BetaAppReviewSubmissionsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewSubmissions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaAppReviewSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewSubmissions]", *params.FieldsBetaAppReviewSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaAppReviewSubmissionsBuildGetToOneRelatedRequest generates requests for BetaAppReviewSubmissionsBuildGetToOneRelated
func NewBetaAppReviewSubmissionsBuildGetToOneRelatedRequest(server string, id string, params *BetaAppReviewSubmissionsBuildGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaAppReviewSubmissions/%s/build", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaBuildLocalizationsGetCollectionRequest generates requests for BetaBuildLocalizationsGetCollection
func NewBetaBuildLocalizationsGetCollectionRequest(server string, params *BetaBuildLocalizationsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaBuildLocalizations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterLocale != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[locale]", *params.FilterLocale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBuild != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[build]", *params.FilterBuild); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaBuildLocalizations]", *params.FieldsBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaBuildLocalizationsCreateInstanceRequest calls the generic BetaBuildLocalizationsCreateInstance builder with application/json body
func NewBetaBuildLocalizationsCreateInstanceRequest(server string, body BetaBuildLocalizationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaBuildLocalizationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBetaBuildLocalizationsCreateInstanceRequestWithBody generates requests for BetaBuildLocalizationsCreateInstance with any type of body
func NewBetaBuildLocalizationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaBuildLocalizations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaBuildLocalizationsDeleteInstanceRequest generates requests for BetaBuildLocalizationsDeleteInstance
func NewBetaBuildLocalizationsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaBuildLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaBuildLocalizationsGetInstanceRequest generates requests for BetaBuildLocalizationsGetInstance
func NewBetaBuildLocalizationsGetInstanceRequest(server string, id string, params *BetaBuildLocalizationsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaBuildLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaBuildLocalizations]", *params.FieldsBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaBuildLocalizationsUpdateInstanceRequest calls the generic BetaBuildLocalizationsUpdateInstance builder with application/json body
func NewBetaBuildLocalizationsUpdateInstanceRequest(server string, id string, body BetaBuildLocalizationsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaBuildLocalizationsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaBuildLocalizationsUpdateInstanceRequestWithBody generates requests for BetaBuildLocalizationsUpdateInstance with any type of body
func NewBetaBuildLocalizationsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaBuildLocalizations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaBuildLocalizationsBuildGetToOneRelatedRequest generates requests for BetaBuildLocalizationsBuildGetToOneRelated
func NewBetaBuildLocalizationsBuildGetToOneRelatedRequest(server string, id string, params *BetaBuildLocalizationsBuildGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaBuildLocalizations/%s/build", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsGetCollectionRequest generates requests for BetaGroupsGetCollection
func NewBetaGroupsGetCollectionRequest(server string, params *BetaGroupsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterIsInternalGroup != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[isInternalGroup]", *params.FilterIsInternalGroup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[name]", *params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPublicLink != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[publicLink]", *params.FilterPublicLink); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPublicLinkEnabled != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[publicLinkEnabled]", *params.FilterPublicLinkEnabled); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPublicLinkLimitEnabled != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[publicLinkLimitEnabled]", *params.FilterPublicLinkLimitEnabled); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[builds]", *params.FilterBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaTesters]", *params.LimitBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsCreateInstanceRequest calls the generic BetaGroupsCreateInstance builder with application/json body
func NewBetaGroupsCreateInstanceRequest(server string, body BetaGroupsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaGroupsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBetaGroupsCreateInstanceRequestWithBody generates requests for BetaGroupsCreateInstance with any type of body
func NewBetaGroupsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaGroupsDeleteInstanceRequest generates requests for BetaGroupsDeleteInstance
func NewBetaGroupsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsGetInstanceRequest generates requests for BetaGroupsGetInstance
func NewBetaGroupsGetInstanceRequest(server string, id string, params *BetaGroupsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaTesters]", *params.LimitBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsUpdateInstanceRequest calls the generic BetaGroupsUpdateInstance builder with application/json body
func NewBetaGroupsUpdateInstanceRequest(server string, id string, body BetaGroupsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaGroupsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaGroupsUpdateInstanceRequestWithBody generates requests for BetaGroupsUpdateInstance with any type of body
func NewBetaGroupsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaGroupsAppGetToOneRelatedRequest generates requests for BetaGroupsAppGetToOneRelated
func NewBetaGroupsAppGetToOneRelatedRequest(server string, id string, params *BetaGroupsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsBetaTestersGetToManyRelatedRequest generates requests for BetaGroupsBetaTestersGetToManyRelated
func NewBetaGroupsBetaTestersGetToManyRelatedRequest(server string, id string, params *BetaGroupsBetaTestersGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/betaTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsBuildsGetToManyRelatedRequest generates requests for BetaGroupsBuildsGetToManyRelated
func NewBetaGroupsBuildsGetToManyRelatedRequest(server string, id string, params *BetaGroupsBuildsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsBetaTestersDeleteToManyRelationshipRequest calls the generic BetaGroupsBetaTestersDeleteToManyRelationship builder with application/json body
func NewBetaGroupsBetaTestersDeleteToManyRelationshipRequest(server string, id string, body BetaGroupsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaGroupsBetaTestersDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaGroupsBetaTestersDeleteToManyRelationshipRequestWithBody generates requests for BetaGroupsBetaTestersDeleteToManyRelationship with any type of body
func NewBetaGroupsBetaTestersDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/relationships/betaTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaGroupsBetaTestersGetToManyRelationshipRequest generates requests for BetaGroupsBetaTestersGetToManyRelationship
func NewBetaGroupsBetaTestersGetToManyRelationshipRequest(server string, id string, params *BetaGroupsBetaTestersGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/relationships/betaTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsBetaTestersCreateToManyRelationshipRequest calls the generic BetaGroupsBetaTestersCreateToManyRelationship builder with application/json body
func NewBetaGroupsBetaTestersCreateToManyRelationshipRequest(server string, id string, body BetaGroupsBetaTestersCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaGroupsBetaTestersCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaGroupsBetaTestersCreateToManyRelationshipRequestWithBody generates requests for BetaGroupsBetaTestersCreateToManyRelationship with any type of body
func NewBetaGroupsBetaTestersCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/relationships/betaTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaGroupsBuildsDeleteToManyRelationshipRequest calls the generic BetaGroupsBuildsDeleteToManyRelationship builder with application/json body
func NewBetaGroupsBuildsDeleteToManyRelationshipRequest(server string, id string, body BetaGroupsBuildsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaGroupsBuildsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaGroupsBuildsDeleteToManyRelationshipRequestWithBody generates requests for BetaGroupsBuildsDeleteToManyRelationship with any type of body
func NewBetaGroupsBuildsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaGroupsBuildsGetToManyRelationshipRequest generates requests for BetaGroupsBuildsGetToManyRelationship
func NewBetaGroupsBuildsGetToManyRelationshipRequest(server string, id string, params *BetaGroupsBuildsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaGroupsBuildsCreateToManyRelationshipRequest calls the generic BetaGroupsBuildsCreateToManyRelationship builder with application/json body
func NewBetaGroupsBuildsCreateToManyRelationshipRequest(server string, id string, body BetaGroupsBuildsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaGroupsBuildsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaGroupsBuildsCreateToManyRelationshipRequestWithBody generates requests for BetaGroupsBuildsCreateToManyRelationship with any type of body
func NewBetaGroupsBuildsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaGroups/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaLicenseAgreementsGetCollectionRequest generates requests for BetaLicenseAgreementsGetCollection
func NewBetaLicenseAgreementsGetCollectionRequest(server string, params *BetaLicenseAgreementsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaLicenseAgreements")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaLicenseAgreements]", *params.FieldsBetaLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaLicenseAgreementsGetInstanceRequest generates requests for BetaLicenseAgreementsGetInstance
func NewBetaLicenseAgreementsGetInstanceRequest(server string, id string, params *BetaLicenseAgreementsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaLicenseAgreements/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaLicenseAgreements]", *params.FieldsBetaLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaLicenseAgreementsUpdateInstanceRequest calls the generic BetaLicenseAgreementsUpdateInstance builder with application/json body
func NewBetaLicenseAgreementsUpdateInstanceRequest(server string, id string, body BetaLicenseAgreementsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaLicenseAgreementsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaLicenseAgreementsUpdateInstanceRequestWithBody generates requests for BetaLicenseAgreementsUpdateInstance with any type of body
func NewBetaLicenseAgreementsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaLicenseAgreements/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaLicenseAgreementsAppGetToOneRelatedRequest generates requests for BetaLicenseAgreementsAppGetToOneRelated
func NewBetaLicenseAgreementsAppGetToOneRelatedRequest(server string, id string, params *BetaLicenseAgreementsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaLicenseAgreements/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTesterInvitationsCreateInstanceRequest calls the generic BetaTesterInvitationsCreateInstance builder with application/json body
func NewBetaTesterInvitationsCreateInstanceRequest(server string, body BetaTesterInvitationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTesterInvitationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBetaTesterInvitationsCreateInstanceRequestWithBody generates requests for BetaTesterInvitationsCreateInstance with any type of body
func NewBetaTesterInvitationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesterInvitations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaTestersGetCollectionRequest generates requests for BetaTestersGetCollection
func NewBetaTestersGetCollectionRequest(server string, params *BetaTestersGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterEmail != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[email]", *params.FilterEmail); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterFirstName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[firstName]", *params.FilterFirstName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterInviteType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[inviteType]", *params.FilterInviteType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterLastName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[lastName]", *params.FilterLastName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[apps]", *params.FilterApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[betaGroups]", *params.FilterBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[builds]", *params.FilterBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[apps]", *params.LimitApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaGroups]", *params.LimitBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersCreateInstanceRequest calls the generic BetaTestersCreateInstance builder with application/json body
func NewBetaTestersCreateInstanceRequest(server string, body BetaTestersCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTestersCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBetaTestersCreateInstanceRequestWithBody generates requests for BetaTestersCreateInstance with any type of body
func NewBetaTestersCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaTestersDeleteInstanceRequest generates requests for BetaTestersDeleteInstance
func NewBetaTestersDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersGetInstanceRequest generates requests for BetaTestersGetInstance
func NewBetaTestersGetInstanceRequest(server string, id string, params *BetaTestersGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[apps]", *params.LimitApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaGroups]", *params.LimitBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersAppsGetToManyRelatedRequest generates requests for BetaTestersAppsGetToManyRelated
func NewBetaTestersAppsGetToManyRelatedRequest(server string, id string, params *BetaTestersAppsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/apps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersBetaGroupsGetToManyRelatedRequest generates requests for BetaTestersBetaGroupsGetToManyRelated
func NewBetaTestersBetaGroupsGetToManyRelatedRequest(server string, id string, params *BetaTestersBetaGroupsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaGroups]", *params.FieldsBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersBuildsGetToManyRelatedRequest generates requests for BetaTestersBuildsGetToManyRelated
func NewBetaTestersBuildsGetToManyRelatedRequest(server string, id string, params *BetaTestersBuildsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersAppsDeleteToManyRelationshipRequest calls the generic BetaTestersAppsDeleteToManyRelationship builder with application/json body
func NewBetaTestersAppsDeleteToManyRelationshipRequest(server string, id string, body BetaTestersAppsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTestersAppsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaTestersAppsDeleteToManyRelationshipRequestWithBody generates requests for BetaTestersAppsDeleteToManyRelationship with any type of body
func NewBetaTestersAppsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/apps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaTestersAppsGetToManyRelationshipRequest generates requests for BetaTestersAppsGetToManyRelationship
func NewBetaTestersAppsGetToManyRelationshipRequest(server string, id string, params *BetaTestersAppsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/apps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersBetaGroupsDeleteToManyRelationshipRequest calls the generic BetaTestersBetaGroupsDeleteToManyRelationship builder with application/json body
func NewBetaTestersBetaGroupsDeleteToManyRelationshipRequest(server string, id string, body BetaTestersBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTestersBetaGroupsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaTestersBetaGroupsDeleteToManyRelationshipRequestWithBody generates requests for BetaTestersBetaGroupsDeleteToManyRelationship with any type of body
func NewBetaTestersBetaGroupsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaTestersBetaGroupsGetToManyRelationshipRequest generates requests for BetaTestersBetaGroupsGetToManyRelationship
func NewBetaTestersBetaGroupsGetToManyRelationshipRequest(server string, id string, params *BetaTestersBetaGroupsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersBetaGroupsCreateToManyRelationshipRequest calls the generic BetaTestersBetaGroupsCreateToManyRelationship builder with application/json body
func NewBetaTestersBetaGroupsCreateToManyRelationshipRequest(server string, id string, body BetaTestersBetaGroupsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTestersBetaGroupsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaTestersBetaGroupsCreateToManyRelationshipRequestWithBody generates requests for BetaTestersBetaGroupsCreateToManyRelationship with any type of body
func NewBetaTestersBetaGroupsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaTestersBuildsDeleteToManyRelationshipRequest calls the generic BetaTestersBuildsDeleteToManyRelationship builder with application/json body
func NewBetaTestersBuildsDeleteToManyRelationshipRequest(server string, id string, body BetaTestersBuildsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTestersBuildsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaTestersBuildsDeleteToManyRelationshipRequestWithBody generates requests for BetaTestersBuildsDeleteToManyRelationship with any type of body
func NewBetaTestersBuildsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBetaTestersBuildsGetToManyRelationshipRequest generates requests for BetaTestersBuildsGetToManyRelationship
func NewBetaTestersBuildsGetToManyRelationshipRequest(server string, id string, params *BetaTestersBuildsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBetaTestersBuildsCreateToManyRelationshipRequest calls the generic BetaTestersBuildsCreateToManyRelationship builder with application/json body
func NewBetaTestersBuildsCreateToManyRelationshipRequest(server string, id string, body BetaTestersBuildsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBetaTestersBuildsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBetaTestersBuildsCreateToManyRelationshipRequestWithBody generates requests for BetaTestersBuildsCreateToManyRelationship with any type of body
func NewBetaTestersBuildsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/betaTesters/%s/relationships/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildBetaDetailsGetCollectionRequest generates requests for BuildBetaDetailsGetCollection
func NewBuildBetaDetailsGetCollectionRequest(server string, params *BuildBetaDetailsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/buildBetaDetails")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterBuild != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[build]", *params.FilterBuild); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuildBetaDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildBetaDetails]", *params.FieldsBuildBetaDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildBetaDetailsGetInstanceRequest generates requests for BuildBetaDetailsGetInstance
func NewBuildBetaDetailsGetInstanceRequest(server string, id string, params *BuildBetaDetailsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/buildBetaDetails/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuildBetaDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildBetaDetails]", *params.FieldsBuildBetaDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildBetaDetailsUpdateInstanceRequest calls the generic BuildBetaDetailsUpdateInstance builder with application/json body
func NewBuildBetaDetailsUpdateInstanceRequest(server string, id string, body BuildBetaDetailsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildBetaDetailsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildBetaDetailsUpdateInstanceRequestWithBody generates requests for BuildBetaDetailsUpdateInstance with any type of body
func NewBuildBetaDetailsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/buildBetaDetails/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildBetaDetailsBuildGetToOneRelatedRequest generates requests for BuildBetaDetailsBuildGetToOneRelated
func NewBuildBetaDetailsBuildGetToOneRelatedRequest(server string, id string, params *BuildBetaDetailsBuildGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/buildBetaDetails/%s/build", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildBetaNotificationsCreateInstanceRequest calls the generic BuildBetaNotificationsCreateInstance builder with application/json body
func NewBuildBetaNotificationsCreateInstanceRequest(server string, body BuildBetaNotificationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildBetaNotificationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBuildBetaNotificationsCreateInstanceRequestWithBody generates requests for BuildBetaNotificationsCreateInstance with any type of body
func NewBuildBetaNotificationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/buildBetaNotifications")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildsGetCollectionRequest generates requests for BuildsGetCollection
func NewBuildsGetCollectionRequest(server string, params *BuildsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterBetaAppReviewSubmissionBetaReviewState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[betaAppReviewSubmission.betaReviewState]", *params.FilterBetaAppReviewSubmissionBetaReviewState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterExpired != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[expired]", *params.FilterExpired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPreReleaseVersionPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[preReleaseVersion.platform]", *params.FilterPreReleaseVersionPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPreReleaseVersionVersion != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[preReleaseVersion.version]", *params.FilterPreReleaseVersionVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterProcessingState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[processingState]", *params.FilterProcessingState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterUsesNonExemptEncryption != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[usesNonExemptEncryption]", *params.FilterUsesNonExemptEncryption); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVersion != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[version]", *params.FilterVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterAppStoreVersion != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[appStoreVersion]", *params.FilterAppStoreVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBetaGroups != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[betaGroups]", *params.FilterBetaGroups); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPreReleaseVersion != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[preReleaseVersion]", *params.FilterPreReleaseVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppEncryptionDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appEncryptionDeclarations]", *params.FieldsAppEncryptionDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppReviewSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewSubmissions]", *params.FieldsBetaAppReviewSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuildBetaDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildBetaDetails]", *params.FieldsBuildBetaDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuildIcons != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildIcons]", *params.FieldsBuildIcons); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPerfPowerMetrics != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[perfPowerMetrics]", *params.FieldsPerfPowerMetrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsDiagnosticSignatures != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[diagnosticSignatures]", *params.FieldsDiagnosticSignatures); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaBuildLocalizations]", *params.FieldsBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaBuildLocalizations]", *params.LimitBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitIcons != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[icons]", *params.LimitIcons); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitIndividualTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[individualTesters]", *params.LimitIndividualTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsGetInstanceRequest generates requests for BuildsGetInstance
func NewBuildsGetInstanceRequest(server string, id string, params *BuildsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppEncryptionDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appEncryptionDeclarations]", *params.FieldsAppEncryptionDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaAppReviewSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewSubmissions]", *params.FieldsBetaAppReviewSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuildBetaDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildBetaDetails]", *params.FieldsBuildBetaDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuildIcons != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildIcons]", *params.FieldsBuildIcons); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPerfPowerMetrics != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[perfPowerMetrics]", *params.FieldsPerfPowerMetrics); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsDiagnosticSignatures != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[diagnosticSignatures]", *params.FieldsDiagnosticSignatures); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaBuildLocalizations]", *params.FieldsBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[betaBuildLocalizations]", *params.LimitBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitIcons != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[icons]", *params.LimitIcons); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitIndividualTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[individualTesters]", *params.LimitIndividualTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsUpdateInstanceRequest calls the generic BuildsUpdateInstance builder with application/json body
func NewBuildsUpdateInstanceRequest(server string, id string, body BuildsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildsUpdateInstanceRequestWithBody generates requests for BuildsUpdateInstance with any type of body
func NewBuildsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildsAppGetToOneRelatedRequest generates requests for BuildsAppGetToOneRelated
func NewBuildsAppGetToOneRelatedRequest(server string, id string, params *BuildsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsAppEncryptionDeclarationGetToOneRelatedRequest generates requests for BuildsAppEncryptionDeclarationGetToOneRelated
func NewBuildsAppEncryptionDeclarationGetToOneRelatedRequest(server string, id string, params *BuildsAppEncryptionDeclarationGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/appEncryptionDeclaration", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppEncryptionDeclarations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appEncryptionDeclarations]", *params.FieldsAppEncryptionDeclarations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsAppStoreVersionGetToOneRelatedRequest generates requests for BuildsAppStoreVersionGetToOneRelated
func NewBuildsAppStoreVersionGetToOneRelatedRequest(server string, id string, params *BuildsAppStoreVersionGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/appStoreVersion", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsAppStoreVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[appStoreVersions]", *params.FieldsAppStoreVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsBetaAppReviewSubmissionGetToOneRelatedRequest generates requests for BuildsBetaAppReviewSubmissionGetToOneRelated
func NewBuildsBetaAppReviewSubmissionGetToOneRelatedRequest(server string, id string, params *BuildsBetaAppReviewSubmissionGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/betaAppReviewSubmission", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaAppReviewSubmissions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaAppReviewSubmissions]", *params.FieldsBetaAppReviewSubmissions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsBetaBuildLocalizationsGetToManyRelatedRequest generates requests for BuildsBetaBuildLocalizationsGetToManyRelated
func NewBuildsBetaBuildLocalizationsGetToManyRelatedRequest(server string, id string, params *BuildsBetaBuildLocalizationsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/betaBuildLocalizations", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaBuildLocalizations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaBuildLocalizations]", *params.FieldsBetaBuildLocalizations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsBuildBetaDetailGetToOneRelatedRequest generates requests for BuildsBuildBetaDetailGetToOneRelated
func NewBuildsBuildBetaDetailGetToOneRelatedRequest(server string, id string, params *BuildsBuildBetaDetailGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/buildBetaDetail", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuildBetaDetails != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildBetaDetails]", *params.FieldsBuildBetaDetails); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsDiagnosticSignaturesGetToManyRelatedRequest generates requests for BuildsDiagnosticSignaturesGetToManyRelated
func NewBuildsDiagnosticSignaturesGetToManyRelatedRequest(server string, id string, params *BuildsDiagnosticSignaturesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/diagnosticSignatures", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterDiagnosticType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[diagnosticType]", *params.FilterDiagnosticType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsDiagnosticSignatures != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[diagnosticSignatures]", *params.FieldsDiagnosticSignatures); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsIconsGetToManyRelatedRequest generates requests for BuildsIconsGetToManyRelated
func NewBuildsIconsGetToManyRelatedRequest(server string, id string, params *BuildsIconsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/icons", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuildIcons != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[buildIcons]", *params.FieldsBuildIcons); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsIndividualTestersGetToManyRelatedRequest generates requests for BuildsIndividualTestersGetToManyRelated
func NewBuildsIndividualTestersGetToManyRelatedRequest(server string, id string, params *BuildsIndividualTestersGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/individualTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBetaTesters != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[betaTesters]", *params.FieldsBetaTesters); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsPerfPowerMetricsGetToManyRelatedRequest generates requests for BuildsPerfPowerMetricsGetToManyRelated
func NewBuildsPerfPowerMetricsGetToManyRelatedRequest(server string, id string, params *BuildsPerfPowerMetricsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/perfPowerMetrics", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterDeviceType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[deviceType]", *params.FilterDeviceType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterMetricType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[metricType]", *params.FilterMetricType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsPreReleaseVersionGetToOneRelatedRequest generates requests for BuildsPreReleaseVersionGetToOneRelated
func NewBuildsPreReleaseVersionGetToOneRelatedRequest(server string, id string, params *BuildsPreReleaseVersionGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/preReleaseVersion", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsAppEncryptionDeclarationGetToOneRelationshipRequest generates requests for BuildsAppEncryptionDeclarationGetToOneRelationship
func NewBuildsAppEncryptionDeclarationGetToOneRelationshipRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/appEncryptionDeclaration", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequest calls the generic BuildsAppEncryptionDeclarationUpdateToOneRelationship builder with application/json body
func NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequest(server string, id string, body BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequestWithBody generates requests for BuildsAppEncryptionDeclarationUpdateToOneRelationship with any type of body
func NewBuildsAppEncryptionDeclarationUpdateToOneRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/appEncryptionDeclaration", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildsBetaGroupsDeleteToManyRelationshipRequest calls the generic BuildsBetaGroupsDeleteToManyRelationship builder with application/json body
func NewBuildsBetaGroupsDeleteToManyRelationshipRequest(server string, id string, body BuildsBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildsBetaGroupsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildsBetaGroupsDeleteToManyRelationshipRequestWithBody generates requests for BuildsBetaGroupsDeleteToManyRelationship with any type of body
func NewBuildsBetaGroupsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildsBetaGroupsCreateToManyRelationshipRequest calls the generic BuildsBetaGroupsCreateToManyRelationship builder with application/json body
func NewBuildsBetaGroupsCreateToManyRelationshipRequest(server string, id string, body BuildsBetaGroupsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildsBetaGroupsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildsBetaGroupsCreateToManyRelationshipRequestWithBody generates requests for BuildsBetaGroupsCreateToManyRelationship with any type of body
func NewBuildsBetaGroupsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/betaGroups", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildsIndividualTestersDeleteToManyRelationshipRequest calls the generic BuildsIndividualTestersDeleteToManyRelationship builder with application/json body
func NewBuildsIndividualTestersDeleteToManyRelationshipRequest(server string, id string, body BuildsIndividualTestersDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildsIndividualTestersDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildsIndividualTestersDeleteToManyRelationshipRequestWithBody generates requests for BuildsIndividualTestersDeleteToManyRelationship with any type of body
func NewBuildsIndividualTestersDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/individualTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBuildsIndividualTestersGetToManyRelationshipRequest generates requests for BuildsIndividualTestersGetToManyRelationship
func NewBuildsIndividualTestersGetToManyRelationshipRequest(server string, id string, params *BuildsIndividualTestersGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/individualTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBuildsIndividualTestersCreateToManyRelationshipRequest calls the generic BuildsIndividualTestersCreateToManyRelationship builder with application/json body
func NewBuildsIndividualTestersCreateToManyRelationshipRequest(server string, id string, body BuildsIndividualTestersCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBuildsIndividualTestersCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBuildsIndividualTestersCreateToManyRelationshipRequestWithBody generates requests for BuildsIndividualTestersCreateToManyRelationship with any type of body
func NewBuildsIndividualTestersCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/builds/%s/relationships/individualTesters", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBundleIdCapabilitiesCreateInstanceRequest calls the generic BundleIdCapabilitiesCreateInstance builder with application/json body
func NewBundleIdCapabilitiesCreateInstanceRequest(server string, body BundleIdCapabilitiesCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBundleIdCapabilitiesCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBundleIdCapabilitiesCreateInstanceRequestWithBody generates requests for BundleIdCapabilitiesCreateInstance with any type of body
func NewBundleIdCapabilitiesCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIdCapabilities")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBundleIdCapabilitiesDeleteInstanceRequest generates requests for BundleIdCapabilitiesDeleteInstance
func NewBundleIdCapabilitiesDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIdCapabilities/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBundleIdCapabilitiesUpdateInstanceRequest calls the generic BundleIdCapabilitiesUpdateInstance builder with application/json body
func NewBundleIdCapabilitiesUpdateInstanceRequest(server string, id string, body BundleIdCapabilitiesUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBundleIdCapabilitiesUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBundleIdCapabilitiesUpdateInstanceRequestWithBody generates requests for BundleIdCapabilitiesUpdateInstance with any type of body
func NewBundleIdCapabilitiesUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIdCapabilities/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBundleIdsGetCollectionRequest generates requests for BundleIdsGetCollection
func NewBundleIdsGetCollectionRequest(server string, params *BundleIdsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterIdentifier != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[identifier]", *params.FilterIdentifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[name]", *params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSeedId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[seedId]", *params.FilterSeedId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBundleIds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIds]", *params.FieldsBundleIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBundleIdCapabilities != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIdCapabilities]", *params.FieldsBundleIdCapabilities); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[profiles]", *params.FieldsProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBundleIdCapabilities != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[bundleIdCapabilities]", *params.LimitBundleIdCapabilities); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[profiles]", *params.LimitProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBundleIdsCreateInstanceRequest calls the generic BundleIdsCreateInstance builder with application/json body
func NewBundleIdsCreateInstanceRequest(server string, body BundleIdsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBundleIdsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewBundleIdsCreateInstanceRequestWithBody generates requests for BundleIdsCreateInstance with any type of body
func NewBundleIdsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBundleIdsDeleteInstanceRequest generates requests for BundleIdsDeleteInstance
func NewBundleIdsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBundleIdsGetInstanceRequest generates requests for BundleIdsGetInstance
func NewBundleIdsGetInstanceRequest(server string, id string, params *BundleIdsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBundleIds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIds]", *params.FieldsBundleIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBundleIdCapabilities != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIdCapabilities]", *params.FieldsBundleIdCapabilities); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[profiles]", *params.FieldsProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBundleIdCapabilities != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[bundleIdCapabilities]", *params.LimitBundleIdCapabilities); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[profiles]", *params.LimitProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBundleIdsUpdateInstanceRequest calls the generic BundleIdsUpdateInstance builder with application/json body
func NewBundleIdsUpdateInstanceRequest(server string, id string, body BundleIdsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBundleIdsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewBundleIdsUpdateInstanceRequestWithBody generates requests for BundleIdsUpdateInstance with any type of body
func NewBundleIdsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewBundleIdsAppGetToOneRelatedRequest generates requests for BundleIdsAppGetToOneRelated
func NewBundleIdsAppGetToOneRelatedRequest(server string, id string, params *BundleIdsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBundleIdsBundleIdCapabilitiesGetToManyRelatedRequest generates requests for BundleIdsBundleIdCapabilitiesGetToManyRelated
func NewBundleIdsBundleIdCapabilitiesGetToManyRelatedRequest(server string, id string, params *BundleIdsBundleIdCapabilitiesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds/%s/bundleIdCapabilities", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBundleIdCapabilities != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIdCapabilities]", *params.FieldsBundleIdCapabilities); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBundleIdsProfilesGetToManyRelatedRequest generates requests for BundleIdsProfilesGetToManyRelated
func NewBundleIdsProfilesGetToManyRelatedRequest(server string, id string, params *BundleIdsProfilesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/bundleIds/%s/profiles", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[profiles]", *params.FieldsProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertificatesGetCollectionRequest generates requests for CertificatesGetCollection
func NewCertificatesGetCollectionRequest(server string, params *CertificatesGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/certificates")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterCertificateType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[certificateType]", *params.FilterCertificateType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterDisplayName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[displayName]", *params.FilterDisplayName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSerialNumber != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[serialNumber]", *params.FilterSerialNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[certificates]", *params.FieldsCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertificatesCreateInstanceRequest calls the generic CertificatesCreateInstance builder with application/json body
func NewCertificatesCreateInstanceRequest(server string, body CertificatesCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCertificatesCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewCertificatesCreateInstanceRequestWithBody generates requests for CertificatesCreateInstance with any type of body
func NewCertificatesCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/certificates")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewCertificatesDeleteInstanceRequest generates requests for CertificatesDeleteInstance
func NewCertificatesDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/certificates/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertificatesGetInstanceRequest generates requests for CertificatesGetInstance
func NewCertificatesGetInstanceRequest(server string, id string, params *CertificatesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/certificates/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[certificates]", *params.FieldsCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevicesGetCollectionRequest generates requests for DevicesGetCollection
func NewDevicesGetCollectionRequest(server string, params *DevicesGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/devices")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[name]", *params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterStatus != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[status]", *params.FilterStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterUdid != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[udid]", *params.FilterUdid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[devices]", *params.FieldsDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevicesCreateInstanceRequest calls the generic DevicesCreateInstance builder with application/json body
func NewDevicesCreateInstanceRequest(server string, body DevicesCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevicesCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewDevicesCreateInstanceRequestWithBody generates requests for DevicesCreateInstance with any type of body
func NewDevicesCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/devices")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDevicesGetInstanceRequest generates requests for DevicesGetInstance
func NewDevicesGetInstanceRequest(server string, id string, params *DevicesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/devices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[devices]", *params.FieldsDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDevicesUpdateInstanceRequest calls the generic DevicesUpdateInstance builder with application/json body
func NewDevicesUpdateInstanceRequest(server string, id string, body DevicesUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDevicesUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewDevicesUpdateInstanceRequestWithBody generates requests for DevicesUpdateInstance with any type of body
func NewDevicesUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/devices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDiagnosticSignaturesLogsGetToManyRelatedRequest generates requests for DiagnosticSignaturesLogsGetToManyRelated
func NewDiagnosticSignaturesLogsGetToManyRelatedRequest(server string, id string, params *DiagnosticSignaturesLogsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/diagnosticSignatures/%s/logs", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndUserLicenseAgreementsCreateInstanceRequest calls the generic EndUserLicenseAgreementsCreateInstance builder with application/json body
func NewEndUserLicenseAgreementsCreateInstanceRequest(server string, body EndUserLicenseAgreementsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndUserLicenseAgreementsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewEndUserLicenseAgreementsCreateInstanceRequestWithBody generates requests for EndUserLicenseAgreementsCreateInstance with any type of body
func NewEndUserLicenseAgreementsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/endUserLicenseAgreements")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewEndUserLicenseAgreementsDeleteInstanceRequest generates requests for EndUserLicenseAgreementsDeleteInstance
func NewEndUserLicenseAgreementsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/endUserLicenseAgreements/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndUserLicenseAgreementsGetInstanceRequest generates requests for EndUserLicenseAgreementsGetInstance
func NewEndUserLicenseAgreementsGetInstanceRequest(server string, id string, params *EndUserLicenseAgreementsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/endUserLicenseAgreements/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsEndUserLicenseAgreements != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[endUserLicenseAgreements]", *params.FieldsEndUserLicenseAgreements); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[territories]", *params.LimitTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndUserLicenseAgreementsUpdateInstanceRequest calls the generic EndUserLicenseAgreementsUpdateInstance builder with application/json body
func NewEndUserLicenseAgreementsUpdateInstanceRequest(server string, id string, body EndUserLicenseAgreementsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndUserLicenseAgreementsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewEndUserLicenseAgreementsUpdateInstanceRequestWithBody generates requests for EndUserLicenseAgreementsUpdateInstance with any type of body
func NewEndUserLicenseAgreementsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/endUserLicenseAgreements/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewEndUserLicenseAgreementsTerritoriesGetToManyRelatedRequest generates requests for EndUserLicenseAgreementsTerritoriesGetToManyRelated
func NewEndUserLicenseAgreementsTerritoriesGetToManyRelatedRequest(server string, id string, params *EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/endUserLicenseAgreements/%s/territories", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFinanceReportsGetCollectionRequest generates requests for FinanceReportsGetCollection
func NewFinanceReportsGetCollectionRequest(server string, params *FinanceReportsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/financeReports")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", false, "filter[regionCode]", params.FilterRegionCode); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[reportDate]", params.FilterReportDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[reportType]", params.FilterReportType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[vendorNumber]", params.FilterVendorNumber); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedRequest generates requests for GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated
func NewGameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedRequest(server string, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/gameCenterEnabledVersions/%s/compatibleVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVersionString != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[versionString]", *params.FilterVersionString); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsGameCenterEnabledVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[gameCenterEnabledVersions]", *params.FieldsGameCenterEnabledVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequest calls the generic GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship builder with application/json body
func NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequest(server string, id string, body GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequestWithBody generates requests for GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship with any type of body
func NewGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/gameCenterEnabledVersions/%s/relationships/compatibleVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipRequest generates requests for GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship
func NewGameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipRequest(server string, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/gameCenterEnabledVersions/%s/relationships/compatibleVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequest calls the generic GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship builder with application/json body
func NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequest(server string, id string, body GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequestWithBody generates requests for GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship with any type of body
func NewGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/gameCenterEnabledVersions/%s/relationships/compatibleVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequest calls the generic GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship builder with application/json body
func NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequest(server string, id string, body GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequestWithBody generates requests for GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship with any type of body
func NewGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/gameCenterEnabledVersions/%s/relationships/compatibleVersions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewIdfaDeclarationsCreateInstanceRequest calls the generic IdfaDeclarationsCreateInstance builder with application/json body
func NewIdfaDeclarationsCreateInstanceRequest(server string, body IdfaDeclarationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdfaDeclarationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewIdfaDeclarationsCreateInstanceRequestWithBody generates requests for IdfaDeclarationsCreateInstance with any type of body
func NewIdfaDeclarationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/idfaDeclarations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewIdfaDeclarationsDeleteInstanceRequest generates requests for IdfaDeclarationsDeleteInstance
func NewIdfaDeclarationsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/idfaDeclarations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdfaDeclarationsUpdateInstanceRequest calls the generic IdfaDeclarationsUpdateInstance builder with application/json body
func NewIdfaDeclarationsUpdateInstanceRequest(server string, id string, body IdfaDeclarationsUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdfaDeclarationsUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewIdfaDeclarationsUpdateInstanceRequestWithBody generates requests for IdfaDeclarationsUpdateInstance with any type of body
func NewIdfaDeclarationsUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/idfaDeclarations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewInAppPurchasesGetInstanceRequest generates requests for InAppPurchasesGetInstance
func NewInAppPurchasesGetInstanceRequest(server string, id string, params *InAppPurchasesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/inAppPurchases/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsInAppPurchases != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[inAppPurchases]", *params.FieldsInAppPurchases); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[apps]", *params.LimitApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreReleaseVersionsGetCollectionRequest generates requests for PreReleaseVersionsGetCollection
func NewPreReleaseVersionsGetCollectionRequest(server string, params *PreReleaseVersionsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/preReleaseVersions")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterBuildsExpired != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[builds.expired]", *params.FilterBuildsExpired); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBuildsProcessingState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[builds.processingState]", *params.FilterBuildsProcessingState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterPlatform != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[platform]", *params.FilterPlatform); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVersion != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[version]", *params.FilterVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterApp != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[app]", *params.FilterApp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[builds]", *params.FilterBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreReleaseVersionsGetInstanceRequest generates requests for PreReleaseVersionsGetInstance
func NewPreReleaseVersionsGetInstanceRequest(server string, id string, params *PreReleaseVersionsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/preReleaseVersions/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsPreReleaseVersions != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[preReleaseVersions]", *params.FieldsPreReleaseVersions); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[builds]", *params.LimitBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreReleaseVersionsAppGetToOneRelatedRequest generates requests for PreReleaseVersionsAppGetToOneRelated
func NewPreReleaseVersionsAppGetToOneRelatedRequest(server string, id string, params *PreReleaseVersionsAppGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/preReleaseVersions/%s/app", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPreReleaseVersionsBuildsGetToManyRelatedRequest generates requests for PreReleaseVersionsBuildsGetToManyRelated
func NewPreReleaseVersionsBuildsGetToManyRelatedRequest(server string, id string, params *PreReleaseVersionsBuildsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/preReleaseVersions/%s/builds", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBuilds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[builds]", *params.FieldsBuilds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfilesGetCollectionRequest generates requests for ProfilesGetCollection
func NewProfilesGetCollectionRequest(server string, params *ProfilesGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterName != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[name]", *params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterProfileState != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[profileState]", *params.FilterProfileState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterProfileType != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[profileType]", *params.FilterProfileType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterId != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[id]", *params.FilterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[profiles]", *params.FieldsProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[certificates]", *params.FieldsCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[devices]", *params.FieldsDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBundleIds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIds]", *params.FieldsBundleIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[certificates]", *params.LimitCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[devices]", *params.LimitDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfilesCreateInstanceRequest calls the generic ProfilesCreateInstance builder with application/json body
func NewProfilesCreateInstanceRequest(server string, body ProfilesCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProfilesCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewProfilesCreateInstanceRequestWithBody generates requests for ProfilesCreateInstance with any type of body
func NewProfilesCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewProfilesDeleteInstanceRequest generates requests for ProfilesDeleteInstance
func NewProfilesDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfilesGetInstanceRequest generates requests for ProfilesGetInstance
func NewProfilesGetInstanceRequest(server string, id string, params *ProfilesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsProfiles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[profiles]", *params.FieldsProfiles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[certificates]", *params.FieldsCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[devices]", *params.FieldsDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsBundleIds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIds]", *params.FieldsBundleIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[certificates]", *params.LimitCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[devices]", *params.LimitDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfilesBundleIdGetToOneRelatedRequest generates requests for ProfilesBundleIdGetToOneRelated
func NewProfilesBundleIdGetToOneRelatedRequest(server string, id string, params *ProfilesBundleIdGetToOneRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles/%s/bundleId", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsBundleIds != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[bundleIds]", *params.FieldsBundleIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfilesCertificatesGetToManyRelatedRequest generates requests for ProfilesCertificatesGetToManyRelated
func NewProfilesCertificatesGetToManyRelatedRequest(server string, id string, params *ProfilesCertificatesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles/%s/certificates", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsCertificates != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[certificates]", *params.FieldsCertificates); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfilesDevicesGetToManyRelatedRequest generates requests for ProfilesDevicesGetToManyRelated
func NewProfilesDevicesGetToManyRelatedRequest(server string, id string, params *ProfilesDevicesGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/profiles/%s/devices", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsDevices != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[devices]", *params.FieldsDevices); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoutingAppCoveragesCreateInstanceRequest calls the generic RoutingAppCoveragesCreateInstance builder with application/json body
func NewRoutingAppCoveragesCreateInstanceRequest(server string, body RoutingAppCoveragesCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRoutingAppCoveragesCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewRoutingAppCoveragesCreateInstanceRequestWithBody generates requests for RoutingAppCoveragesCreateInstance with any type of body
func NewRoutingAppCoveragesCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/routingAppCoverages")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewRoutingAppCoveragesDeleteInstanceRequest generates requests for RoutingAppCoveragesDeleteInstance
func NewRoutingAppCoveragesDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/routingAppCoverages/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoutingAppCoveragesGetInstanceRequest generates requests for RoutingAppCoveragesGetInstance
func NewRoutingAppCoveragesGetInstanceRequest(server string, id string, params *RoutingAppCoveragesGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/routingAppCoverages/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsRoutingAppCoverages != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[routingAppCoverages]", *params.FieldsRoutingAppCoverages); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRoutingAppCoveragesUpdateInstanceRequest calls the generic RoutingAppCoveragesUpdateInstance builder with application/json body
func NewRoutingAppCoveragesUpdateInstanceRequest(server string, id string, body RoutingAppCoveragesUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRoutingAppCoveragesUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRoutingAppCoveragesUpdateInstanceRequestWithBody generates requests for RoutingAppCoveragesUpdateInstance with any type of body
func NewRoutingAppCoveragesUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/routingAppCoverages/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewSalesReportsGetCollectionRequest generates requests for SalesReportsGetCollection
func NewSalesReportsGetCollectionRequest(server string, params *SalesReportsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/salesReports")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", false, "filter[frequency]", params.FilterFrequency); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.FilterReportDate != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[reportDate]", *params.FilterReportDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[reportSubType]", params.FilterReportSubType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[reportType]", params.FilterReportType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParam("form", false, "filter[vendorNumber]", params.FilterVendorNumber); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.FilterVersion != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[version]", *params.FilterVersion); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTerritoriesGetCollectionRequest generates requests for TerritoriesGetCollection
func NewTerritoriesGetCollectionRequest(server string, params *TerritoriesGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/territories")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsTerritories != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[territories]", *params.FieldsTerritories); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserInvitationsGetCollectionRequest generates requests for UserInvitationsGetCollection
func NewUserInvitationsGetCollectionRequest(server string, params *UserInvitationsGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/userInvitations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterEmail != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[email]", *params.FilterEmail); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterRoles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[roles]", *params.FilterRoles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVisibleApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[visibleApps]", *params.FilterVisibleApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsUserInvitations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[userInvitations]", *params.FieldsUserInvitations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitVisibleApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[visibleApps]", *params.LimitVisibleApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserInvitationsCreateInstanceRequest calls the generic UserInvitationsCreateInstance builder with application/json body
func NewUserInvitationsCreateInstanceRequest(server string, body UserInvitationsCreateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserInvitationsCreateInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewUserInvitationsCreateInstanceRequestWithBody generates requests for UserInvitationsCreateInstance with any type of body
func NewUserInvitationsCreateInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/userInvitations")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUserInvitationsDeleteInstanceRequest generates requests for UserInvitationsDeleteInstance
func NewUserInvitationsDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/userInvitations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserInvitationsGetInstanceRequest generates requests for UserInvitationsGetInstance
func NewUserInvitationsGetInstanceRequest(server string, id string, params *UserInvitationsGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/userInvitations/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsUserInvitations != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[userInvitations]", *params.FieldsUserInvitations); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitVisibleApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[visibleApps]", *params.LimitVisibleApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserInvitationsVisibleAppsGetToManyRelatedRequest generates requests for UserInvitationsVisibleAppsGetToManyRelated
func NewUserInvitationsVisibleAppsGetToManyRelatedRequest(server string, id string, params *UserInvitationsVisibleAppsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/userInvitations/%s/visibleApps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersGetCollectionRequest generates requests for UsersGetCollection
func NewUsersGetCollectionRequest(server string, params *UsersGetCollectionParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FilterRoles != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[roles]", *params.FilterRoles); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterUsername != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[username]", *params.FilterUsername); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterVisibleApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "filter[visibleApps]", *params.FilterVisibleApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "sort", *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsUsers != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[users]", *params.FieldsUsers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitVisibleApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[visibleApps]", *params.LimitVisibleApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersDeleteInstanceRequest generates requests for UsersDeleteInstance
func NewUsersDeleteInstanceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersGetInstanceRequest generates requests for UsersGetInstance
func NewUsersGetInstanceRequest(server string, id string, params *UsersGetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsUsers != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[users]", *params.FieldsUsers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "include", *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LimitVisibleApps != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit[visibleApps]", *params.LimitVisibleApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersUpdateInstanceRequest calls the generic UsersUpdateInstance builder with application/json body
func NewUsersUpdateInstanceRequest(server string, id string, body UsersUpdateInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdateInstanceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersUpdateInstanceRequestWithBody generates requests for UsersUpdateInstance with any type of body
func NewUsersUpdateInstanceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUsersVisibleAppsDeleteToManyRelationshipRequest calls the generic UsersVisibleAppsDeleteToManyRelationship builder with application/json body
func NewUsersVisibleAppsDeleteToManyRelationshipRequest(server string, id string, body UsersVisibleAppsDeleteToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersVisibleAppsDeleteToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersVisibleAppsDeleteToManyRelationshipRequestWithBody generates requests for UsersVisibleAppsDeleteToManyRelationship with any type of body
func NewUsersVisibleAppsDeleteToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s/relationships/visibleApps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUsersVisibleAppsGetToManyRelationshipRequest generates requests for UsersVisibleAppsGetToManyRelationship
func NewUsersVisibleAppsGetToManyRelationshipRequest(server string, id string, params *UsersVisibleAppsGetToManyRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s/relationships/visibleApps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersVisibleAppsReplaceToManyRelationshipRequest calls the generic UsersVisibleAppsReplaceToManyRelationship builder with application/json body
func NewUsersVisibleAppsReplaceToManyRelationshipRequest(server string, id string, body UsersVisibleAppsReplaceToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersVisibleAppsReplaceToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersVisibleAppsReplaceToManyRelationshipRequestWithBody generates requests for UsersVisibleAppsReplaceToManyRelationship with any type of body
func NewUsersVisibleAppsReplaceToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s/relationships/visibleApps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUsersVisibleAppsCreateToManyRelationshipRequest calls the generic UsersVisibleAppsCreateToManyRelationship builder with application/json body
func NewUsersVisibleAppsCreateToManyRelationshipRequest(server string, id string, body UsersVisibleAppsCreateToManyRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersVisibleAppsCreateToManyRelationshipRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUsersVisibleAppsCreateToManyRelationshipRequestWithBody generates requests for UsersVisibleAppsCreateToManyRelationship with any type of body
func NewUsersVisibleAppsCreateToManyRelationshipRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s/relationships/visibleApps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUsersVisibleAppsGetToManyRelatedRequest generates requests for UsersVisibleAppsGetToManyRelated
func NewUsersVisibleAppsGetToManyRelatedRequest(server string, id string, params *UsersVisibleAppsGetToManyRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/v1/users/%s/visibleApps", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.FieldsApps != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "fields[apps]", *params.FieldsApps); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AgeRatingDeclarationsUpdateInstance request  with any body
	AgeRatingDeclarationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AgeRatingDeclarationsUpdateInstanceResponse, error)

	AgeRatingDeclarationsUpdateInstanceWithResponse(ctx context.Context, id string, body AgeRatingDeclarationsUpdateInstanceJSONRequestBody) (*AgeRatingDeclarationsUpdateInstanceResponse, error)

	// AppCategoriesGetCollection request
	AppCategoriesGetCollectionWithResponse(ctx context.Context, params *AppCategoriesGetCollectionParams) (*AppCategoriesGetCollectionResponse, error)

	// AppCategoriesGetInstance request
	AppCategoriesGetInstanceWithResponse(ctx context.Context, id string, params *AppCategoriesGetInstanceParams) (*AppCategoriesGetInstanceResponse, error)

	// AppCategoriesParentGetToOneRelated request
	AppCategoriesParentGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppCategoriesParentGetToOneRelatedParams) (*AppCategoriesParentGetToOneRelatedResponse, error)

	// AppCategoriesSubcategoriesGetToManyRelated request
	AppCategoriesSubcategoriesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppCategoriesSubcategoriesGetToManyRelatedParams) (*AppCategoriesSubcategoriesGetToManyRelatedResponse, error)

	// AppEncryptionDeclarationsGetCollection request
	AppEncryptionDeclarationsGetCollectionWithResponse(ctx context.Context, params *AppEncryptionDeclarationsGetCollectionParams) (*AppEncryptionDeclarationsGetCollectionResponse, error)

	// AppEncryptionDeclarationsGetInstance request
	AppEncryptionDeclarationsGetInstanceWithResponse(ctx context.Context, id string, params *AppEncryptionDeclarationsGetInstanceParams) (*AppEncryptionDeclarationsGetInstanceResponse, error)

	// AppEncryptionDeclarationsAppGetToOneRelated request
	AppEncryptionDeclarationsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppEncryptionDeclarationsAppGetToOneRelatedParams) (*AppEncryptionDeclarationsAppGetToOneRelatedResponse, error)

	// AppEncryptionDeclarationsBuildsCreateToManyRelationship request  with any body
	AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse, error)

	AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONRequestBody) (*AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse, error)

	// AppInfoLocalizationsCreateInstance request  with any body
	AppInfoLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppInfoLocalizationsCreateInstanceResponse, error)

	AppInfoLocalizationsCreateInstanceWithResponse(ctx context.Context, body AppInfoLocalizationsCreateInstanceJSONRequestBody) (*AppInfoLocalizationsCreateInstanceResponse, error)

	// AppInfoLocalizationsDeleteInstance request
	AppInfoLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppInfoLocalizationsDeleteInstanceResponse, error)

	// AppInfoLocalizationsGetInstance request
	AppInfoLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *AppInfoLocalizationsGetInstanceParams) (*AppInfoLocalizationsGetInstanceResponse, error)

	// AppInfoLocalizationsUpdateInstance request  with any body
	AppInfoLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppInfoLocalizationsUpdateInstanceResponse, error)

	AppInfoLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body AppInfoLocalizationsUpdateInstanceJSONRequestBody) (*AppInfoLocalizationsUpdateInstanceResponse, error)

	// AppInfosGetInstance request
	AppInfosGetInstanceWithResponse(ctx context.Context, id string, params *AppInfosGetInstanceParams) (*AppInfosGetInstanceResponse, error)

	// AppInfosUpdateInstance request  with any body
	AppInfosUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppInfosUpdateInstanceResponse, error)

	AppInfosUpdateInstanceWithResponse(ctx context.Context, id string, body AppInfosUpdateInstanceJSONRequestBody) (*AppInfosUpdateInstanceResponse, error)

	// AppInfosAppInfoLocalizationsGetToManyRelated request
	AppInfosAppInfoLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppInfosAppInfoLocalizationsGetToManyRelatedParams) (*AppInfosAppInfoLocalizationsGetToManyRelatedResponse, error)

	// AppInfosPrimaryCategoryGetToOneRelated request
	AppInfosPrimaryCategoryGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosPrimaryCategoryGetToOneRelatedParams) (*AppInfosPrimaryCategoryGetToOneRelatedResponse, error)

	// AppInfosPrimarySubcategoryOneGetToOneRelated request
	AppInfosPrimarySubcategoryOneGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosPrimarySubcategoryOneGetToOneRelatedParams) (*AppInfosPrimarySubcategoryOneGetToOneRelatedResponse, error)

	// AppInfosPrimarySubcategoryTwoGetToOneRelated request
	AppInfosPrimarySubcategoryTwoGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosPrimarySubcategoryTwoGetToOneRelatedParams) (*AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse, error)

	// AppInfosSecondaryCategoryGetToOneRelated request
	AppInfosSecondaryCategoryGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosSecondaryCategoryGetToOneRelatedParams) (*AppInfosSecondaryCategoryGetToOneRelatedResponse, error)

	// AppInfosSecondarySubcategoryOneGetToOneRelated request
	AppInfosSecondarySubcategoryOneGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosSecondarySubcategoryOneGetToOneRelatedParams) (*AppInfosSecondarySubcategoryOneGetToOneRelatedResponse, error)

	// AppInfosSecondarySubcategoryTwoGetToOneRelated request
	AppInfosSecondarySubcategoryTwoGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosSecondarySubcategoryTwoGetToOneRelatedParams) (*AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse, error)

	// AppPreOrdersCreateInstance request  with any body
	AppPreOrdersCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppPreOrdersCreateInstanceResponse, error)

	AppPreOrdersCreateInstanceWithResponse(ctx context.Context, body AppPreOrdersCreateInstanceJSONRequestBody) (*AppPreOrdersCreateInstanceResponse, error)

	// AppPreOrdersDeleteInstance request
	AppPreOrdersDeleteInstanceWithResponse(ctx context.Context, id string) (*AppPreOrdersDeleteInstanceResponse, error)

	// AppPreOrdersGetInstance request
	AppPreOrdersGetInstanceWithResponse(ctx context.Context, id string, params *AppPreOrdersGetInstanceParams) (*AppPreOrdersGetInstanceResponse, error)

	// AppPreOrdersUpdateInstance request  with any body
	AppPreOrdersUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppPreOrdersUpdateInstanceResponse, error)

	AppPreOrdersUpdateInstanceWithResponse(ctx context.Context, id string, body AppPreOrdersUpdateInstanceJSONRequestBody) (*AppPreOrdersUpdateInstanceResponse, error)

	// AppPreviewSetsCreateInstance request  with any body
	AppPreviewSetsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppPreviewSetsCreateInstanceResponse, error)

	AppPreviewSetsCreateInstanceWithResponse(ctx context.Context, body AppPreviewSetsCreateInstanceJSONRequestBody) (*AppPreviewSetsCreateInstanceResponse, error)

	// AppPreviewSetsDeleteInstance request
	AppPreviewSetsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppPreviewSetsDeleteInstanceResponse, error)

	// AppPreviewSetsGetInstance request
	AppPreviewSetsGetInstanceWithResponse(ctx context.Context, id string, params *AppPreviewSetsGetInstanceParams) (*AppPreviewSetsGetInstanceResponse, error)

	// AppPreviewSetsAppPreviewsGetToManyRelated request
	AppPreviewSetsAppPreviewsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelatedParams) (*AppPreviewSetsAppPreviewsGetToManyRelatedResponse, error)

	// AppPreviewSetsAppPreviewsGetToManyRelationship request
	AppPreviewSetsAppPreviewsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelationshipParams) (*AppPreviewSetsAppPreviewsGetToManyRelationshipResponse, error)

	// AppPreviewSetsAppPreviewsReplaceToManyRelationship request  with any body
	AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse, error)

	AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONRequestBody) (*AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse, error)

	// AppPreviewsCreateInstance request  with any body
	AppPreviewsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppPreviewsCreateInstanceResponse, error)

	AppPreviewsCreateInstanceWithResponse(ctx context.Context, body AppPreviewsCreateInstanceJSONRequestBody) (*AppPreviewsCreateInstanceResponse, error)

	// AppPreviewsDeleteInstance request
	AppPreviewsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppPreviewsDeleteInstanceResponse, error)

	// AppPreviewsGetInstance request
	AppPreviewsGetInstanceWithResponse(ctx context.Context, id string, params *AppPreviewsGetInstanceParams) (*AppPreviewsGetInstanceResponse, error)

	// AppPreviewsUpdateInstance request  with any body
	AppPreviewsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppPreviewsUpdateInstanceResponse, error)

	AppPreviewsUpdateInstanceWithResponse(ctx context.Context, id string, body AppPreviewsUpdateInstanceJSONRequestBody) (*AppPreviewsUpdateInstanceResponse, error)

	// AppPricePointsGetCollection request
	AppPricePointsGetCollectionWithResponse(ctx context.Context, params *AppPricePointsGetCollectionParams) (*AppPricePointsGetCollectionResponse, error)

	// AppPricePointsGetInstance request
	AppPricePointsGetInstanceWithResponse(ctx context.Context, id string, params *AppPricePointsGetInstanceParams) (*AppPricePointsGetInstanceResponse, error)

	// AppPricePointsTerritoryGetToOneRelated request
	AppPricePointsTerritoryGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppPricePointsTerritoryGetToOneRelatedParams) (*AppPricePointsTerritoryGetToOneRelatedResponse, error)

	// AppPriceTiersGetCollection request
	AppPriceTiersGetCollectionWithResponse(ctx context.Context, params *AppPriceTiersGetCollectionParams) (*AppPriceTiersGetCollectionResponse, error)

	// AppPriceTiersGetInstance request
	AppPriceTiersGetInstanceWithResponse(ctx context.Context, id string, params *AppPriceTiersGetInstanceParams) (*AppPriceTiersGetInstanceResponse, error)

	// AppPriceTiersPricePointsGetToManyRelated request
	AppPriceTiersPricePointsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppPriceTiersPricePointsGetToManyRelatedParams) (*AppPriceTiersPricePointsGetToManyRelatedResponse, error)

	// AppPricesGetInstance request
	AppPricesGetInstanceWithResponse(ctx context.Context, id string, params *AppPricesGetInstanceParams) (*AppPricesGetInstanceResponse, error)

	// AppScreenshotSetsCreateInstance request  with any body
	AppScreenshotSetsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppScreenshotSetsCreateInstanceResponse, error)

	AppScreenshotSetsCreateInstanceWithResponse(ctx context.Context, body AppScreenshotSetsCreateInstanceJSONRequestBody) (*AppScreenshotSetsCreateInstanceResponse, error)

	// AppScreenshotSetsDeleteInstance request
	AppScreenshotSetsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppScreenshotSetsDeleteInstanceResponse, error)

	// AppScreenshotSetsGetInstance request
	AppScreenshotSetsGetInstanceWithResponse(ctx context.Context, id string, params *AppScreenshotSetsGetInstanceParams) (*AppScreenshotSetsGetInstanceResponse, error)

	// AppScreenshotSetsAppScreenshotsGetToManyRelated request
	AppScreenshotSetsAppScreenshotsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelatedParams) (*AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse, error)

	// AppScreenshotSetsAppScreenshotsGetToManyRelationship request
	AppScreenshotSetsAppScreenshotsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams) (*AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse, error)

	// AppScreenshotSetsAppScreenshotsReplaceToManyRelationship request  with any body
	AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse, error)

	AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONRequestBody) (*AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse, error)

	// AppScreenshotsCreateInstance request  with any body
	AppScreenshotsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppScreenshotsCreateInstanceResponse, error)

	AppScreenshotsCreateInstanceWithResponse(ctx context.Context, body AppScreenshotsCreateInstanceJSONRequestBody) (*AppScreenshotsCreateInstanceResponse, error)

	// AppScreenshotsDeleteInstance request
	AppScreenshotsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppScreenshotsDeleteInstanceResponse, error)

	// AppScreenshotsGetInstance request
	AppScreenshotsGetInstanceWithResponse(ctx context.Context, id string, params *AppScreenshotsGetInstanceParams) (*AppScreenshotsGetInstanceResponse, error)

	// AppScreenshotsUpdateInstance request  with any body
	AppScreenshotsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppScreenshotsUpdateInstanceResponse, error)

	AppScreenshotsUpdateInstanceWithResponse(ctx context.Context, id string, body AppScreenshotsUpdateInstanceJSONRequestBody) (*AppScreenshotsUpdateInstanceResponse, error)

	// AppStoreReviewAttachmentsCreateInstance request  with any body
	AppStoreReviewAttachmentsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreReviewAttachmentsCreateInstanceResponse, error)

	AppStoreReviewAttachmentsCreateInstanceWithResponse(ctx context.Context, body AppStoreReviewAttachmentsCreateInstanceJSONRequestBody) (*AppStoreReviewAttachmentsCreateInstanceResponse, error)

	// AppStoreReviewAttachmentsDeleteInstance request
	AppStoreReviewAttachmentsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreReviewAttachmentsDeleteInstanceResponse, error)

	// AppStoreReviewAttachmentsGetInstance request
	AppStoreReviewAttachmentsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreReviewAttachmentsGetInstanceParams) (*AppStoreReviewAttachmentsGetInstanceResponse, error)

	// AppStoreReviewAttachmentsUpdateInstance request  with any body
	AppStoreReviewAttachmentsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreReviewAttachmentsUpdateInstanceResponse, error)

	AppStoreReviewAttachmentsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreReviewAttachmentsUpdateInstanceJSONRequestBody) (*AppStoreReviewAttachmentsUpdateInstanceResponse, error)

	// AppStoreReviewDetailsCreateInstance request  with any body
	AppStoreReviewDetailsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreReviewDetailsCreateInstanceResponse, error)

	AppStoreReviewDetailsCreateInstanceWithResponse(ctx context.Context, body AppStoreReviewDetailsCreateInstanceJSONRequestBody) (*AppStoreReviewDetailsCreateInstanceResponse, error)

	// AppStoreReviewDetailsGetInstance request
	AppStoreReviewDetailsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreReviewDetailsGetInstanceParams) (*AppStoreReviewDetailsGetInstanceResponse, error)

	// AppStoreReviewDetailsUpdateInstance request  with any body
	AppStoreReviewDetailsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreReviewDetailsUpdateInstanceResponse, error)

	AppStoreReviewDetailsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreReviewDetailsUpdateInstanceJSONRequestBody) (*AppStoreReviewDetailsUpdateInstanceResponse, error)

	// AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated request
	AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams) (*AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse, error)

	// AppStoreVersionLocalizationsCreateInstance request  with any body
	AppStoreVersionLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionLocalizationsCreateInstanceResponse, error)

	AppStoreVersionLocalizationsCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionLocalizationsCreateInstanceJSONRequestBody) (*AppStoreVersionLocalizationsCreateInstanceResponse, error)

	// AppStoreVersionLocalizationsDeleteInstance request
	AppStoreVersionLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionLocalizationsDeleteInstanceResponse, error)

	// AppStoreVersionLocalizationsGetInstance request
	AppStoreVersionLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreVersionLocalizationsGetInstanceParams) (*AppStoreVersionLocalizationsGetInstanceResponse, error)

	// AppStoreVersionLocalizationsUpdateInstance request  with any body
	AppStoreVersionLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionLocalizationsUpdateInstanceResponse, error)

	AppStoreVersionLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreVersionLocalizationsUpdateInstanceJSONRequestBody) (*AppStoreVersionLocalizationsUpdateInstanceResponse, error)

	// AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated request
	AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams) (*AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse, error)

	// AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated request
	AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams) (*AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse, error)

	// AppStoreVersionPhasedReleasesCreateInstance request  with any body
	AppStoreVersionPhasedReleasesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionPhasedReleasesCreateInstanceResponse, error)

	AppStoreVersionPhasedReleasesCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionPhasedReleasesCreateInstanceJSONRequestBody) (*AppStoreVersionPhasedReleasesCreateInstanceResponse, error)

	// AppStoreVersionPhasedReleasesDeleteInstance request
	AppStoreVersionPhasedReleasesDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionPhasedReleasesDeleteInstanceResponse, error)

	// AppStoreVersionPhasedReleasesUpdateInstance request  with any body
	AppStoreVersionPhasedReleasesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionPhasedReleasesUpdateInstanceResponse, error)

	AppStoreVersionPhasedReleasesUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreVersionPhasedReleasesUpdateInstanceJSONRequestBody) (*AppStoreVersionPhasedReleasesUpdateInstanceResponse, error)

	// AppStoreVersionSubmissionsCreateInstance request  with any body
	AppStoreVersionSubmissionsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionSubmissionsCreateInstanceResponse, error)

	AppStoreVersionSubmissionsCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionSubmissionsCreateInstanceJSONRequestBody) (*AppStoreVersionSubmissionsCreateInstanceResponse, error)

	// AppStoreVersionSubmissionsDeleteInstance request
	AppStoreVersionSubmissionsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionSubmissionsDeleteInstanceResponse, error)

	// AppStoreVersionsCreateInstance request  with any body
	AppStoreVersionsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionsCreateInstanceResponse, error)

	AppStoreVersionsCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionsCreateInstanceJSONRequestBody) (*AppStoreVersionsCreateInstanceResponse, error)

	// AppStoreVersionsDeleteInstance request
	AppStoreVersionsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionsDeleteInstanceResponse, error)

	// AppStoreVersionsGetInstance request
	AppStoreVersionsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreVersionsGetInstanceParams) (*AppStoreVersionsGetInstanceResponse, error)

	// AppStoreVersionsUpdateInstance request  with any body
	AppStoreVersionsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionsUpdateInstanceResponse, error)

	AppStoreVersionsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreVersionsUpdateInstanceJSONRequestBody) (*AppStoreVersionsUpdateInstanceResponse, error)

	// AppStoreVersionsAgeRatingDeclarationGetToOneRelated request
	AppStoreVersionsAgeRatingDeclarationGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams) (*AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse, error)

	// AppStoreVersionsAppStoreReviewDetailGetToOneRelated request
	AppStoreVersionsAppStoreReviewDetailGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams) (*AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse, error)

	// AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated request
	AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams) (*AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse, error)

	// AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated request
	AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams) (*AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse, error)

	// AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated request
	AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams) (*AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse, error)

	// AppStoreVersionsBuildGetToOneRelated request
	AppStoreVersionsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsBuildGetToOneRelatedParams) (*AppStoreVersionsBuildGetToOneRelatedResponse, error)

	// AppStoreVersionsIdfaDeclarationGetToOneRelated request
	AppStoreVersionsIdfaDeclarationGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsIdfaDeclarationGetToOneRelatedParams) (*AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse, error)

	// AppStoreVersionsBuildGetToOneRelationship request
	AppStoreVersionsBuildGetToOneRelationshipWithResponse(ctx context.Context, id string) (*AppStoreVersionsBuildGetToOneRelationshipResponse, error)

	// AppStoreVersionsBuildUpdateToOneRelationship request  with any body
	AppStoreVersionsBuildUpdateToOneRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionsBuildUpdateToOneRelationshipResponse, error)

	AppStoreVersionsBuildUpdateToOneRelationshipWithResponse(ctx context.Context, id string, body AppStoreVersionsBuildUpdateToOneRelationshipJSONRequestBody) (*AppStoreVersionsBuildUpdateToOneRelationshipResponse, error)

	// AppStoreVersionsRoutingAppCoverageGetToOneRelated request
	AppStoreVersionsRoutingAppCoverageGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams) (*AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse, error)

	// AppsGetCollection request
	AppsGetCollectionWithResponse(ctx context.Context, params *AppsGetCollectionParams) (*AppsGetCollectionResponse, error)

	// AppsGetInstance request
	AppsGetInstanceWithResponse(ctx context.Context, id string, params *AppsGetInstanceParams) (*AppsGetInstanceResponse, error)

	// AppsUpdateInstance request  with any body
	AppsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppsUpdateInstanceResponse, error)

	AppsUpdateInstanceWithResponse(ctx context.Context, id string, body AppsUpdateInstanceJSONRequestBody) (*AppsUpdateInstanceResponse, error)

	// AppsAppInfosGetToManyRelated request
	AppsAppInfosGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsAppInfosGetToManyRelatedParams) (*AppsAppInfosGetToManyRelatedResponse, error)

	// AppsAppStoreVersionsGetToManyRelated request
	AppsAppStoreVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsAppStoreVersionsGetToManyRelatedParams) (*AppsAppStoreVersionsGetToManyRelatedResponse, error)

	// AppsAvailableTerritoriesGetToManyRelated request
	AppsAvailableTerritoriesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsAvailableTerritoriesGetToManyRelatedParams) (*AppsAvailableTerritoriesGetToManyRelatedResponse, error)

	// AppsBetaAppLocalizationsGetToManyRelated request
	AppsBetaAppLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsBetaAppLocalizationsGetToManyRelatedParams) (*AppsBetaAppLocalizationsGetToManyRelatedResponse, error)

	// AppsBetaAppReviewDetailGetToOneRelated request
	AppsBetaAppReviewDetailGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsBetaAppReviewDetailGetToOneRelatedParams) (*AppsBetaAppReviewDetailGetToOneRelatedResponse, error)

	// AppsBetaGroupsGetToManyRelated request
	AppsBetaGroupsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsBetaGroupsGetToManyRelatedParams) (*AppsBetaGroupsGetToManyRelatedResponse, error)

	// AppsBetaLicenseAgreementGetToOneRelated request
	AppsBetaLicenseAgreementGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsBetaLicenseAgreementGetToOneRelatedParams) (*AppsBetaLicenseAgreementGetToOneRelatedResponse, error)

	// AppsBuildsGetToManyRelated request
	AppsBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsBuildsGetToManyRelatedParams) (*AppsBuildsGetToManyRelatedResponse, error)

	// AppsEndUserLicenseAgreementGetToOneRelated request
	AppsEndUserLicenseAgreementGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsEndUserLicenseAgreementGetToOneRelatedParams) (*AppsEndUserLicenseAgreementGetToOneRelatedResponse, error)

	// AppsGameCenterEnabledVersionsGetToManyRelated request
	AppsGameCenterEnabledVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsGameCenterEnabledVersionsGetToManyRelatedParams) (*AppsGameCenterEnabledVersionsGetToManyRelatedResponse, error)

	// AppsInAppPurchasesGetToManyRelated request
	AppsInAppPurchasesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsInAppPurchasesGetToManyRelatedParams) (*AppsInAppPurchasesGetToManyRelatedResponse, error)

	// AppsPerfPowerMetricsGetToManyRelated request
	AppsPerfPowerMetricsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsPerfPowerMetricsGetToManyRelatedParams) (*AppsPerfPowerMetricsGetToManyRelatedResponse, error)

	// AppsPreOrderGetToOneRelated request
	AppsPreOrderGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsPreOrderGetToOneRelatedParams) (*AppsPreOrderGetToOneRelatedResponse, error)

	// AppsPreReleaseVersionsGetToManyRelated request
	AppsPreReleaseVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsPreReleaseVersionsGetToManyRelatedParams) (*AppsPreReleaseVersionsGetToManyRelatedResponse, error)

	// AppsPricesGetToManyRelated request
	AppsPricesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsPricesGetToManyRelatedParams) (*AppsPricesGetToManyRelatedResponse, error)

	// AppsBetaTestersDeleteToManyRelationship request  with any body
	AppsBetaTestersDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppsBetaTestersDeleteToManyRelationshipResponse, error)

	AppsBetaTestersDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body AppsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*AppsBetaTestersDeleteToManyRelationshipResponse, error)

	// BetaAppLocalizationsGetCollection request
	BetaAppLocalizationsGetCollectionWithResponse(ctx context.Context, params *BetaAppLocalizationsGetCollectionParams) (*BetaAppLocalizationsGetCollectionResponse, error)

	// BetaAppLocalizationsCreateInstance request  with any body
	BetaAppLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaAppLocalizationsCreateInstanceResponse, error)

	BetaAppLocalizationsCreateInstanceWithResponse(ctx context.Context, body BetaAppLocalizationsCreateInstanceJSONRequestBody) (*BetaAppLocalizationsCreateInstanceResponse, error)

	// BetaAppLocalizationsDeleteInstance request
	BetaAppLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaAppLocalizationsDeleteInstanceResponse, error)

	// BetaAppLocalizationsGetInstance request
	BetaAppLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *BetaAppLocalizationsGetInstanceParams) (*BetaAppLocalizationsGetInstanceResponse, error)

	// BetaAppLocalizationsUpdateInstance request  with any body
	BetaAppLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaAppLocalizationsUpdateInstanceResponse, error)

	BetaAppLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaAppLocalizationsUpdateInstanceJSONRequestBody) (*BetaAppLocalizationsUpdateInstanceResponse, error)

	// BetaAppLocalizationsAppGetToOneRelated request
	BetaAppLocalizationsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaAppLocalizationsAppGetToOneRelatedParams) (*BetaAppLocalizationsAppGetToOneRelatedResponse, error)

	// BetaAppReviewDetailsGetCollection request
	BetaAppReviewDetailsGetCollectionWithResponse(ctx context.Context, params *BetaAppReviewDetailsGetCollectionParams) (*BetaAppReviewDetailsGetCollectionResponse, error)

	// BetaAppReviewDetailsGetInstance request
	BetaAppReviewDetailsGetInstanceWithResponse(ctx context.Context, id string, params *BetaAppReviewDetailsGetInstanceParams) (*BetaAppReviewDetailsGetInstanceResponse, error)

	// BetaAppReviewDetailsUpdateInstance request  with any body
	BetaAppReviewDetailsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaAppReviewDetailsUpdateInstanceResponse, error)

	BetaAppReviewDetailsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaAppReviewDetailsUpdateInstanceJSONRequestBody) (*BetaAppReviewDetailsUpdateInstanceResponse, error)

	// BetaAppReviewDetailsAppGetToOneRelated request
	BetaAppReviewDetailsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaAppReviewDetailsAppGetToOneRelatedParams) (*BetaAppReviewDetailsAppGetToOneRelatedResponse, error)

	// BetaAppReviewSubmissionsGetCollection request
	BetaAppReviewSubmissionsGetCollectionWithResponse(ctx context.Context, params *BetaAppReviewSubmissionsGetCollectionParams) (*BetaAppReviewSubmissionsGetCollectionResponse, error)

	// BetaAppReviewSubmissionsCreateInstance request  with any body
	BetaAppReviewSubmissionsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaAppReviewSubmissionsCreateInstanceResponse, error)

	BetaAppReviewSubmissionsCreateInstanceWithResponse(ctx context.Context, body BetaAppReviewSubmissionsCreateInstanceJSONRequestBody) (*BetaAppReviewSubmissionsCreateInstanceResponse, error)

	// BetaAppReviewSubmissionsGetInstance request
	BetaAppReviewSubmissionsGetInstanceWithResponse(ctx context.Context, id string, params *BetaAppReviewSubmissionsGetInstanceParams) (*BetaAppReviewSubmissionsGetInstanceResponse, error)

	// BetaAppReviewSubmissionsBuildGetToOneRelated request
	BetaAppReviewSubmissionsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaAppReviewSubmissionsBuildGetToOneRelatedParams) (*BetaAppReviewSubmissionsBuildGetToOneRelatedResponse, error)

	// BetaBuildLocalizationsGetCollection request
	BetaBuildLocalizationsGetCollectionWithResponse(ctx context.Context, params *BetaBuildLocalizationsGetCollectionParams) (*BetaBuildLocalizationsGetCollectionResponse, error)

	// BetaBuildLocalizationsCreateInstance request  with any body
	BetaBuildLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaBuildLocalizationsCreateInstanceResponse, error)

	BetaBuildLocalizationsCreateInstanceWithResponse(ctx context.Context, body BetaBuildLocalizationsCreateInstanceJSONRequestBody) (*BetaBuildLocalizationsCreateInstanceResponse, error)

	// BetaBuildLocalizationsDeleteInstance request
	BetaBuildLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaBuildLocalizationsDeleteInstanceResponse, error)

	// BetaBuildLocalizationsGetInstance request
	BetaBuildLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *BetaBuildLocalizationsGetInstanceParams) (*BetaBuildLocalizationsGetInstanceResponse, error)

	// BetaBuildLocalizationsUpdateInstance request  with any body
	BetaBuildLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaBuildLocalizationsUpdateInstanceResponse, error)

	BetaBuildLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaBuildLocalizationsUpdateInstanceJSONRequestBody) (*BetaBuildLocalizationsUpdateInstanceResponse, error)

	// BetaBuildLocalizationsBuildGetToOneRelated request
	BetaBuildLocalizationsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaBuildLocalizationsBuildGetToOneRelatedParams) (*BetaBuildLocalizationsBuildGetToOneRelatedResponse, error)

	// BetaGroupsGetCollection request
	BetaGroupsGetCollectionWithResponse(ctx context.Context, params *BetaGroupsGetCollectionParams) (*BetaGroupsGetCollectionResponse, error)

	// BetaGroupsCreateInstance request  with any body
	BetaGroupsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaGroupsCreateInstanceResponse, error)

	BetaGroupsCreateInstanceWithResponse(ctx context.Context, body BetaGroupsCreateInstanceJSONRequestBody) (*BetaGroupsCreateInstanceResponse, error)

	// BetaGroupsDeleteInstance request
	BetaGroupsDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaGroupsDeleteInstanceResponse, error)

	// BetaGroupsGetInstance request
	BetaGroupsGetInstanceWithResponse(ctx context.Context, id string, params *BetaGroupsGetInstanceParams) (*BetaGroupsGetInstanceResponse, error)

	// BetaGroupsUpdateInstance request  with any body
	BetaGroupsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsUpdateInstanceResponse, error)

	BetaGroupsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaGroupsUpdateInstanceJSONRequestBody) (*BetaGroupsUpdateInstanceResponse, error)

	// BetaGroupsAppGetToOneRelated request
	BetaGroupsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaGroupsAppGetToOneRelatedParams) (*BetaGroupsAppGetToOneRelatedResponse, error)

	// BetaGroupsBetaTestersGetToManyRelated request
	BetaGroupsBetaTestersGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelatedParams) (*BetaGroupsBetaTestersGetToManyRelatedResponse, error)

	// BetaGroupsBuildsGetToManyRelated request
	BetaGroupsBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelatedParams) (*BetaGroupsBuildsGetToManyRelatedResponse, error)

	// BetaGroupsBetaTestersDeleteToManyRelationship request  with any body
	BetaGroupsBetaTestersDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBetaTestersDeleteToManyRelationshipResponse, error)

	BetaGroupsBetaTestersDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*BetaGroupsBetaTestersDeleteToManyRelationshipResponse, error)

	// BetaGroupsBetaTestersGetToManyRelationship request
	BetaGroupsBetaTestersGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelationshipParams) (*BetaGroupsBetaTestersGetToManyRelationshipResponse, error)

	// BetaGroupsBetaTestersCreateToManyRelationship request  with any body
	BetaGroupsBetaTestersCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBetaTestersCreateToManyRelationshipResponse, error)

	BetaGroupsBetaTestersCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBetaTestersCreateToManyRelationshipJSONRequestBody) (*BetaGroupsBetaTestersCreateToManyRelationshipResponse, error)

	// BetaGroupsBuildsDeleteToManyRelationship request  with any body
	BetaGroupsBuildsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBuildsDeleteToManyRelationshipResponse, error)

	BetaGroupsBuildsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBuildsDeleteToManyRelationshipJSONRequestBody) (*BetaGroupsBuildsDeleteToManyRelationshipResponse, error)

	// BetaGroupsBuildsGetToManyRelationship request
	BetaGroupsBuildsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelationshipParams) (*BetaGroupsBuildsGetToManyRelationshipResponse, error)

	// BetaGroupsBuildsCreateToManyRelationship request  with any body
	BetaGroupsBuildsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBuildsCreateToManyRelationshipResponse, error)

	BetaGroupsBuildsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBuildsCreateToManyRelationshipJSONRequestBody) (*BetaGroupsBuildsCreateToManyRelationshipResponse, error)

	// BetaLicenseAgreementsGetCollection request
	BetaLicenseAgreementsGetCollectionWithResponse(ctx context.Context, params *BetaLicenseAgreementsGetCollectionParams) (*BetaLicenseAgreementsGetCollectionResponse, error)

	// BetaLicenseAgreementsGetInstance request
	BetaLicenseAgreementsGetInstanceWithResponse(ctx context.Context, id string, params *BetaLicenseAgreementsGetInstanceParams) (*BetaLicenseAgreementsGetInstanceResponse, error)

	// BetaLicenseAgreementsUpdateInstance request  with any body
	BetaLicenseAgreementsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaLicenseAgreementsUpdateInstanceResponse, error)

	BetaLicenseAgreementsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaLicenseAgreementsUpdateInstanceJSONRequestBody) (*BetaLicenseAgreementsUpdateInstanceResponse, error)

	// BetaLicenseAgreementsAppGetToOneRelated request
	BetaLicenseAgreementsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaLicenseAgreementsAppGetToOneRelatedParams) (*BetaLicenseAgreementsAppGetToOneRelatedResponse, error)

	// BetaTesterInvitationsCreateInstance request  with any body
	BetaTesterInvitationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaTesterInvitationsCreateInstanceResponse, error)

	BetaTesterInvitationsCreateInstanceWithResponse(ctx context.Context, body BetaTesterInvitationsCreateInstanceJSONRequestBody) (*BetaTesterInvitationsCreateInstanceResponse, error)

	// BetaTestersGetCollection request
	BetaTestersGetCollectionWithResponse(ctx context.Context, params *BetaTestersGetCollectionParams) (*BetaTestersGetCollectionResponse, error)

	// BetaTestersCreateInstance request  with any body
	BetaTestersCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaTestersCreateInstanceResponse, error)

	BetaTestersCreateInstanceWithResponse(ctx context.Context, body BetaTestersCreateInstanceJSONRequestBody) (*BetaTestersCreateInstanceResponse, error)

	// BetaTestersDeleteInstance request
	BetaTestersDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaTestersDeleteInstanceResponse, error)

	// BetaTestersGetInstance request
	BetaTestersGetInstanceWithResponse(ctx context.Context, id string, params *BetaTestersGetInstanceParams) (*BetaTestersGetInstanceResponse, error)

	// BetaTestersAppsGetToManyRelated request
	BetaTestersAppsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelatedParams) (*BetaTestersAppsGetToManyRelatedResponse, error)

	// BetaTestersBetaGroupsGetToManyRelated request
	BetaTestersBetaGroupsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelatedParams) (*BetaTestersBetaGroupsGetToManyRelatedResponse, error)

	// BetaTestersBuildsGetToManyRelated request
	BetaTestersBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelatedParams) (*BetaTestersBuildsGetToManyRelatedResponse, error)

	// BetaTestersAppsDeleteToManyRelationship request  with any body
	BetaTestersAppsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersAppsDeleteToManyRelationshipResponse, error)

	BetaTestersAppsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersAppsDeleteToManyRelationshipJSONRequestBody) (*BetaTestersAppsDeleteToManyRelationshipResponse, error)

	// BetaTestersAppsGetToManyRelationship request
	BetaTestersAppsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelationshipParams) (*BetaTestersAppsGetToManyRelationshipResponse, error)

	// BetaTestersBetaGroupsDeleteToManyRelationship request  with any body
	BetaTestersBetaGroupsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBetaGroupsDeleteToManyRelationshipResponse, error)

	BetaTestersBetaGroupsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*BetaTestersBetaGroupsDeleteToManyRelationshipResponse, error)

	// BetaTestersBetaGroupsGetToManyRelationship request
	BetaTestersBetaGroupsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelationshipParams) (*BetaTestersBetaGroupsGetToManyRelationshipResponse, error)

	// BetaTestersBetaGroupsCreateToManyRelationship request  with any body
	BetaTestersBetaGroupsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBetaGroupsCreateToManyRelationshipResponse, error)

	BetaTestersBetaGroupsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBetaGroupsCreateToManyRelationshipJSONRequestBody) (*BetaTestersBetaGroupsCreateToManyRelationshipResponse, error)

	// BetaTestersBuildsDeleteToManyRelationship request  with any body
	BetaTestersBuildsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBuildsDeleteToManyRelationshipResponse, error)

	BetaTestersBuildsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBuildsDeleteToManyRelationshipJSONRequestBody) (*BetaTestersBuildsDeleteToManyRelationshipResponse, error)

	// BetaTestersBuildsGetToManyRelationship request
	BetaTestersBuildsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelationshipParams) (*BetaTestersBuildsGetToManyRelationshipResponse, error)

	// BetaTestersBuildsCreateToManyRelationship request  with any body
	BetaTestersBuildsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBuildsCreateToManyRelationshipResponse, error)

	BetaTestersBuildsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBuildsCreateToManyRelationshipJSONRequestBody) (*BetaTestersBuildsCreateToManyRelationshipResponse, error)

	// BuildBetaDetailsGetCollection request
	BuildBetaDetailsGetCollectionWithResponse(ctx context.Context, params *BuildBetaDetailsGetCollectionParams) (*BuildBetaDetailsGetCollectionResponse, error)

	// BuildBetaDetailsGetInstance request
	BuildBetaDetailsGetInstanceWithResponse(ctx context.Context, id string, params *BuildBetaDetailsGetInstanceParams) (*BuildBetaDetailsGetInstanceResponse, error)

	// BuildBetaDetailsUpdateInstance request  with any body
	BuildBetaDetailsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildBetaDetailsUpdateInstanceResponse, error)

	BuildBetaDetailsUpdateInstanceWithResponse(ctx context.Context, id string, body BuildBetaDetailsUpdateInstanceJSONRequestBody) (*BuildBetaDetailsUpdateInstanceResponse, error)

	// BuildBetaDetailsBuildGetToOneRelated request
	BuildBetaDetailsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildBetaDetailsBuildGetToOneRelatedParams) (*BuildBetaDetailsBuildGetToOneRelatedResponse, error)

	// BuildBetaNotificationsCreateInstance request  with any body
	BuildBetaNotificationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BuildBetaNotificationsCreateInstanceResponse, error)

	BuildBetaNotificationsCreateInstanceWithResponse(ctx context.Context, body BuildBetaNotificationsCreateInstanceJSONRequestBody) (*BuildBetaNotificationsCreateInstanceResponse, error)

	// BuildsGetCollection request
	BuildsGetCollectionWithResponse(ctx context.Context, params *BuildsGetCollectionParams) (*BuildsGetCollectionResponse, error)

	// BuildsGetInstance request
	BuildsGetInstanceWithResponse(ctx context.Context, id string, params *BuildsGetInstanceParams) (*BuildsGetInstanceResponse, error)

	// BuildsUpdateInstance request  with any body
	BuildsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsUpdateInstanceResponse, error)

	BuildsUpdateInstanceWithResponse(ctx context.Context, id string, body BuildsUpdateInstanceJSONRequestBody) (*BuildsUpdateInstanceResponse, error)

	// BuildsAppGetToOneRelated request
	BuildsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsAppGetToOneRelatedParams) (*BuildsAppGetToOneRelatedResponse, error)

	// BuildsAppEncryptionDeclarationGetToOneRelated request
	BuildsAppEncryptionDeclarationGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsAppEncryptionDeclarationGetToOneRelatedParams) (*BuildsAppEncryptionDeclarationGetToOneRelatedResponse, error)

	// BuildsAppStoreVersionGetToOneRelated request
	BuildsAppStoreVersionGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsAppStoreVersionGetToOneRelatedParams) (*BuildsAppStoreVersionGetToOneRelatedResponse, error)

	// BuildsBetaAppReviewSubmissionGetToOneRelated request
	BuildsBetaAppReviewSubmissionGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsBetaAppReviewSubmissionGetToOneRelatedParams) (*BuildsBetaAppReviewSubmissionGetToOneRelatedResponse, error)

	// BuildsBetaBuildLocalizationsGetToManyRelated request
	BuildsBetaBuildLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsBetaBuildLocalizationsGetToManyRelatedParams) (*BuildsBetaBuildLocalizationsGetToManyRelatedResponse, error)

	// BuildsBuildBetaDetailGetToOneRelated request
	BuildsBuildBetaDetailGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsBuildBetaDetailGetToOneRelatedParams) (*BuildsBuildBetaDetailGetToOneRelatedResponse, error)

	// BuildsDiagnosticSignaturesGetToManyRelated request
	BuildsDiagnosticSignaturesGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsDiagnosticSignaturesGetToManyRelatedParams) (*BuildsDiagnosticSignaturesGetToManyRelatedResponse, error)

	// BuildsIconsGetToManyRelated request
	BuildsIconsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsIconsGetToManyRelatedParams) (*BuildsIconsGetToManyRelatedResponse, error)

	// BuildsIndividualTestersGetToManyRelated request
	BuildsIndividualTestersGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelatedParams) (*BuildsIndividualTestersGetToManyRelatedResponse, error)

	// BuildsPerfPowerMetricsGetToManyRelated request
	BuildsPerfPowerMetricsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsPerfPowerMetricsGetToManyRelatedParams) (*BuildsPerfPowerMetricsGetToManyRelatedResponse, error)

	// BuildsPreReleaseVersionGetToOneRelated request
	BuildsPreReleaseVersionGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsPreReleaseVersionGetToOneRelatedParams) (*BuildsPreReleaseVersionGetToOneRelatedResponse, error)

	// BuildsAppEncryptionDeclarationGetToOneRelationship request
	BuildsAppEncryptionDeclarationGetToOneRelationshipWithResponse(ctx context.Context, id string) (*BuildsAppEncryptionDeclarationGetToOneRelationshipResponse, error)

	// BuildsAppEncryptionDeclarationUpdateToOneRelationship request  with any body
	BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse, error)

	BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithResponse(ctx context.Context, id string, body BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONRequestBody) (*BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse, error)

	// BuildsBetaGroupsDeleteToManyRelationship request  with any body
	BuildsBetaGroupsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsBetaGroupsDeleteToManyRelationshipResponse, error)

	BuildsBetaGroupsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*BuildsBetaGroupsDeleteToManyRelationshipResponse, error)

	// BuildsBetaGroupsCreateToManyRelationship request  with any body
	BuildsBetaGroupsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsBetaGroupsCreateToManyRelationshipResponse, error)

	BuildsBetaGroupsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsBetaGroupsCreateToManyRelationshipJSONRequestBody) (*BuildsBetaGroupsCreateToManyRelationshipResponse, error)

	// BuildsIndividualTestersDeleteToManyRelationship request  with any body
	BuildsIndividualTestersDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsIndividualTestersDeleteToManyRelationshipResponse, error)

	BuildsIndividualTestersDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsIndividualTestersDeleteToManyRelationshipJSONRequestBody) (*BuildsIndividualTestersDeleteToManyRelationshipResponse, error)

	// BuildsIndividualTestersGetToManyRelationship request
	BuildsIndividualTestersGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelationshipParams) (*BuildsIndividualTestersGetToManyRelationshipResponse, error)

	// BuildsIndividualTestersCreateToManyRelationship request  with any body
	BuildsIndividualTestersCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsIndividualTestersCreateToManyRelationshipResponse, error)

	BuildsIndividualTestersCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsIndividualTestersCreateToManyRelationshipJSONRequestBody) (*BuildsIndividualTestersCreateToManyRelationshipResponse, error)

	// BundleIdCapabilitiesCreateInstance request  with any body
	BundleIdCapabilitiesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BundleIdCapabilitiesCreateInstanceResponse, error)

	BundleIdCapabilitiesCreateInstanceWithResponse(ctx context.Context, body BundleIdCapabilitiesCreateInstanceJSONRequestBody) (*BundleIdCapabilitiesCreateInstanceResponse, error)

	// BundleIdCapabilitiesDeleteInstance request
	BundleIdCapabilitiesDeleteInstanceWithResponse(ctx context.Context, id string) (*BundleIdCapabilitiesDeleteInstanceResponse, error)

	// BundleIdCapabilitiesUpdateInstance request  with any body
	BundleIdCapabilitiesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BundleIdCapabilitiesUpdateInstanceResponse, error)

	BundleIdCapabilitiesUpdateInstanceWithResponse(ctx context.Context, id string, body BundleIdCapabilitiesUpdateInstanceJSONRequestBody) (*BundleIdCapabilitiesUpdateInstanceResponse, error)

	// BundleIdsGetCollection request
	BundleIdsGetCollectionWithResponse(ctx context.Context, params *BundleIdsGetCollectionParams) (*BundleIdsGetCollectionResponse, error)

	// BundleIdsCreateInstance request  with any body
	BundleIdsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BundleIdsCreateInstanceResponse, error)

	BundleIdsCreateInstanceWithResponse(ctx context.Context, body BundleIdsCreateInstanceJSONRequestBody) (*BundleIdsCreateInstanceResponse, error)

	// BundleIdsDeleteInstance request
	BundleIdsDeleteInstanceWithResponse(ctx context.Context, id string) (*BundleIdsDeleteInstanceResponse, error)

	// BundleIdsGetInstance request
	BundleIdsGetInstanceWithResponse(ctx context.Context, id string, params *BundleIdsGetInstanceParams) (*BundleIdsGetInstanceResponse, error)

	// BundleIdsUpdateInstance request  with any body
	BundleIdsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BundleIdsUpdateInstanceResponse, error)

	BundleIdsUpdateInstanceWithResponse(ctx context.Context, id string, body BundleIdsUpdateInstanceJSONRequestBody) (*BundleIdsUpdateInstanceResponse, error)

	// BundleIdsAppGetToOneRelated request
	BundleIdsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BundleIdsAppGetToOneRelatedParams) (*BundleIdsAppGetToOneRelatedResponse, error)

	// BundleIdsBundleIdCapabilitiesGetToManyRelated request
	BundleIdsBundleIdCapabilitiesGetToManyRelatedWithResponse(ctx context.Context, id string, params *BundleIdsBundleIdCapabilitiesGetToManyRelatedParams) (*BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse, error)

	// BundleIdsProfilesGetToManyRelated request
	BundleIdsProfilesGetToManyRelatedWithResponse(ctx context.Context, id string, params *BundleIdsProfilesGetToManyRelatedParams) (*BundleIdsProfilesGetToManyRelatedResponse, error)

	// CertificatesGetCollection request
	CertificatesGetCollectionWithResponse(ctx context.Context, params *CertificatesGetCollectionParams) (*CertificatesGetCollectionResponse, error)

	// CertificatesCreateInstance request  with any body
	CertificatesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CertificatesCreateInstanceResponse, error)

	CertificatesCreateInstanceWithResponse(ctx context.Context, body CertificatesCreateInstanceJSONRequestBody) (*CertificatesCreateInstanceResponse, error)

	// CertificatesDeleteInstance request
	CertificatesDeleteInstanceWithResponse(ctx context.Context, id string) (*CertificatesDeleteInstanceResponse, error)

	// CertificatesGetInstance request
	CertificatesGetInstanceWithResponse(ctx context.Context, id string, params *CertificatesGetInstanceParams) (*CertificatesGetInstanceResponse, error)

	// DevicesGetCollection request
	DevicesGetCollectionWithResponse(ctx context.Context, params *DevicesGetCollectionParams) (*DevicesGetCollectionResponse, error)

	// DevicesCreateInstance request  with any body
	DevicesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*DevicesCreateInstanceResponse, error)

	DevicesCreateInstanceWithResponse(ctx context.Context, body DevicesCreateInstanceJSONRequestBody) (*DevicesCreateInstanceResponse, error)

	// DevicesGetInstance request
	DevicesGetInstanceWithResponse(ctx context.Context, id string, params *DevicesGetInstanceParams) (*DevicesGetInstanceResponse, error)

	// DevicesUpdateInstance request  with any body
	DevicesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*DevicesUpdateInstanceResponse, error)

	DevicesUpdateInstanceWithResponse(ctx context.Context, id string, body DevicesUpdateInstanceJSONRequestBody) (*DevicesUpdateInstanceResponse, error)

	// DiagnosticSignaturesLogsGetToManyRelated request
	DiagnosticSignaturesLogsGetToManyRelatedWithResponse(ctx context.Context, id string, params *DiagnosticSignaturesLogsGetToManyRelatedParams) (*DiagnosticSignaturesLogsGetToManyRelatedResponse, error)

	// EndUserLicenseAgreementsCreateInstance request  with any body
	EndUserLicenseAgreementsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*EndUserLicenseAgreementsCreateInstanceResponse, error)

	EndUserLicenseAgreementsCreateInstanceWithResponse(ctx context.Context, body EndUserLicenseAgreementsCreateInstanceJSONRequestBody) (*EndUserLicenseAgreementsCreateInstanceResponse, error)

	// EndUserLicenseAgreementsDeleteInstance request
	EndUserLicenseAgreementsDeleteInstanceWithResponse(ctx context.Context, id string) (*EndUserLicenseAgreementsDeleteInstanceResponse, error)

	// EndUserLicenseAgreementsGetInstance request
	EndUserLicenseAgreementsGetInstanceWithResponse(ctx context.Context, id string, params *EndUserLicenseAgreementsGetInstanceParams) (*EndUserLicenseAgreementsGetInstanceResponse, error)

	// EndUserLicenseAgreementsUpdateInstance request  with any body
	EndUserLicenseAgreementsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*EndUserLicenseAgreementsUpdateInstanceResponse, error)

	EndUserLicenseAgreementsUpdateInstanceWithResponse(ctx context.Context, id string, body EndUserLicenseAgreementsUpdateInstanceJSONRequestBody) (*EndUserLicenseAgreementsUpdateInstanceResponse, error)

	// EndUserLicenseAgreementsTerritoriesGetToManyRelated request
	EndUserLicenseAgreementsTerritoriesGetToManyRelatedWithResponse(ctx context.Context, id string, params *EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams) (*EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse, error)

	// FinanceReportsGetCollection request
	FinanceReportsGetCollectionWithResponse(ctx context.Context, params *FinanceReportsGetCollectionParams) (*FinanceReportsGetCollectionResponse, error)

	// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated request
	GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams) (*GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse, error)

	// GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship request  with any body
	GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse, error)

	GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONRequestBody) (*GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse, error)

	// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship request
	GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams) (*GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse, error)

	// GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship request  with any body
	GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse, error)

	GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONRequestBody) (*GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse, error)

	// GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship request  with any body
	GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse, error)

	GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONRequestBody) (*GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse, error)

	// IdfaDeclarationsCreateInstance request  with any body
	IdfaDeclarationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*IdfaDeclarationsCreateInstanceResponse, error)

	IdfaDeclarationsCreateInstanceWithResponse(ctx context.Context, body IdfaDeclarationsCreateInstanceJSONRequestBody) (*IdfaDeclarationsCreateInstanceResponse, error)

	// IdfaDeclarationsDeleteInstance request
	IdfaDeclarationsDeleteInstanceWithResponse(ctx context.Context, id string) (*IdfaDeclarationsDeleteInstanceResponse, error)

	// IdfaDeclarationsUpdateInstance request  with any body
	IdfaDeclarationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*IdfaDeclarationsUpdateInstanceResponse, error)

	IdfaDeclarationsUpdateInstanceWithResponse(ctx context.Context, id string, body IdfaDeclarationsUpdateInstanceJSONRequestBody) (*IdfaDeclarationsUpdateInstanceResponse, error)

	// InAppPurchasesGetInstance request
	InAppPurchasesGetInstanceWithResponse(ctx context.Context, id string, params *InAppPurchasesGetInstanceParams) (*InAppPurchasesGetInstanceResponse, error)

	// PreReleaseVersionsGetCollection request
	PreReleaseVersionsGetCollectionWithResponse(ctx context.Context, params *PreReleaseVersionsGetCollectionParams) (*PreReleaseVersionsGetCollectionResponse, error)

	// PreReleaseVersionsGetInstance request
	PreReleaseVersionsGetInstanceWithResponse(ctx context.Context, id string, params *PreReleaseVersionsGetInstanceParams) (*PreReleaseVersionsGetInstanceResponse, error)

	// PreReleaseVersionsAppGetToOneRelated request
	PreReleaseVersionsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *PreReleaseVersionsAppGetToOneRelatedParams) (*PreReleaseVersionsAppGetToOneRelatedResponse, error)

	// PreReleaseVersionsBuildsGetToManyRelated request
	PreReleaseVersionsBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *PreReleaseVersionsBuildsGetToManyRelatedParams) (*PreReleaseVersionsBuildsGetToManyRelatedResponse, error)

	// ProfilesGetCollection request
	ProfilesGetCollectionWithResponse(ctx context.Context, params *ProfilesGetCollectionParams) (*ProfilesGetCollectionResponse, error)

	// ProfilesCreateInstance request  with any body
	ProfilesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ProfilesCreateInstanceResponse, error)

	ProfilesCreateInstanceWithResponse(ctx context.Context, body ProfilesCreateInstanceJSONRequestBody) (*ProfilesCreateInstanceResponse, error)

	// ProfilesDeleteInstance request
	ProfilesDeleteInstanceWithResponse(ctx context.Context, id string) (*ProfilesDeleteInstanceResponse, error)

	// ProfilesGetInstance request
	ProfilesGetInstanceWithResponse(ctx context.Context, id string, params *ProfilesGetInstanceParams) (*ProfilesGetInstanceResponse, error)

	// ProfilesBundleIdGetToOneRelated request
	ProfilesBundleIdGetToOneRelatedWithResponse(ctx context.Context, id string, params *ProfilesBundleIdGetToOneRelatedParams) (*ProfilesBundleIdGetToOneRelatedResponse, error)

	// ProfilesCertificatesGetToManyRelated request
	ProfilesCertificatesGetToManyRelatedWithResponse(ctx context.Context, id string, params *ProfilesCertificatesGetToManyRelatedParams) (*ProfilesCertificatesGetToManyRelatedResponse, error)

	// ProfilesDevicesGetToManyRelated request
	ProfilesDevicesGetToManyRelatedWithResponse(ctx context.Context, id string, params *ProfilesDevicesGetToManyRelatedParams) (*ProfilesDevicesGetToManyRelatedResponse, error)

	// RoutingAppCoveragesCreateInstance request  with any body
	RoutingAppCoveragesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*RoutingAppCoveragesCreateInstanceResponse, error)

	RoutingAppCoveragesCreateInstanceWithResponse(ctx context.Context, body RoutingAppCoveragesCreateInstanceJSONRequestBody) (*RoutingAppCoveragesCreateInstanceResponse, error)

	// RoutingAppCoveragesDeleteInstance request
	RoutingAppCoveragesDeleteInstanceWithResponse(ctx context.Context, id string) (*RoutingAppCoveragesDeleteInstanceResponse, error)

	// RoutingAppCoveragesGetInstance request
	RoutingAppCoveragesGetInstanceWithResponse(ctx context.Context, id string, params *RoutingAppCoveragesGetInstanceParams) (*RoutingAppCoveragesGetInstanceResponse, error)

	// RoutingAppCoveragesUpdateInstance request  with any body
	RoutingAppCoveragesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*RoutingAppCoveragesUpdateInstanceResponse, error)

	RoutingAppCoveragesUpdateInstanceWithResponse(ctx context.Context, id string, body RoutingAppCoveragesUpdateInstanceJSONRequestBody) (*RoutingAppCoveragesUpdateInstanceResponse, error)

	// SalesReportsGetCollection request
	SalesReportsGetCollectionWithResponse(ctx context.Context, params *SalesReportsGetCollectionParams) (*SalesReportsGetCollectionResponse, error)

	// TerritoriesGetCollection request
	TerritoriesGetCollectionWithResponse(ctx context.Context, params *TerritoriesGetCollectionParams) (*TerritoriesGetCollectionResponse, error)

	// UserInvitationsGetCollection request
	UserInvitationsGetCollectionWithResponse(ctx context.Context, params *UserInvitationsGetCollectionParams) (*UserInvitationsGetCollectionResponse, error)

	// UserInvitationsCreateInstance request  with any body
	UserInvitationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*UserInvitationsCreateInstanceResponse, error)

	UserInvitationsCreateInstanceWithResponse(ctx context.Context, body UserInvitationsCreateInstanceJSONRequestBody) (*UserInvitationsCreateInstanceResponse, error)

	// UserInvitationsDeleteInstance request
	UserInvitationsDeleteInstanceWithResponse(ctx context.Context, id string) (*UserInvitationsDeleteInstanceResponse, error)

	// UserInvitationsGetInstance request
	UserInvitationsGetInstanceWithResponse(ctx context.Context, id string, params *UserInvitationsGetInstanceParams) (*UserInvitationsGetInstanceResponse, error)

	// UserInvitationsVisibleAppsGetToManyRelated request
	UserInvitationsVisibleAppsGetToManyRelatedWithResponse(ctx context.Context, id string, params *UserInvitationsVisibleAppsGetToManyRelatedParams) (*UserInvitationsVisibleAppsGetToManyRelatedResponse, error)

	// UsersGetCollection request
	UsersGetCollectionWithResponse(ctx context.Context, params *UsersGetCollectionParams) (*UsersGetCollectionResponse, error)

	// UsersDeleteInstance request
	UsersDeleteInstanceWithResponse(ctx context.Context, id string) (*UsersDeleteInstanceResponse, error)

	// UsersGetInstance request
	UsersGetInstanceWithResponse(ctx context.Context, id string, params *UsersGetInstanceParams) (*UsersGetInstanceResponse, error)

	// UsersUpdateInstance request  with any body
	UsersUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersUpdateInstanceResponse, error)

	UsersUpdateInstanceWithResponse(ctx context.Context, id string, body UsersUpdateInstanceJSONRequestBody) (*UsersUpdateInstanceResponse, error)

	// UsersVisibleAppsDeleteToManyRelationship request  with any body
	UsersVisibleAppsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersVisibleAppsDeleteToManyRelationshipResponse, error)

	UsersVisibleAppsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body UsersVisibleAppsDeleteToManyRelationshipJSONRequestBody) (*UsersVisibleAppsDeleteToManyRelationshipResponse, error)

	// UsersVisibleAppsGetToManyRelationship request
	UsersVisibleAppsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelationshipParams) (*UsersVisibleAppsGetToManyRelationshipResponse, error)

	// UsersVisibleAppsReplaceToManyRelationship request  with any body
	UsersVisibleAppsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersVisibleAppsReplaceToManyRelationshipResponse, error)

	UsersVisibleAppsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body UsersVisibleAppsReplaceToManyRelationshipJSONRequestBody) (*UsersVisibleAppsReplaceToManyRelationshipResponse, error)

	// UsersVisibleAppsCreateToManyRelationship request  with any body
	UsersVisibleAppsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersVisibleAppsCreateToManyRelationshipResponse, error)

	UsersVisibleAppsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body UsersVisibleAppsCreateToManyRelationshipJSONRequestBody) (*UsersVisibleAppsCreateToManyRelationshipResponse, error)

	// UsersVisibleAppsGetToManyRelated request
	UsersVisibleAppsGetToManyRelatedWithResponse(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelatedParams) (*UsersVisibleAppsGetToManyRelatedResponse, error)
}

type AgeRatingDeclarationsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgeRatingDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AgeRatingDeclarationsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgeRatingDeclarationsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCategoriesGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoriesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppCategoriesGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCategoriesGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCategoriesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppCategoriesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCategoriesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCategoriesParentGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppCategoriesParentGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCategoriesParentGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppCategoriesSubcategoriesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoriesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppCategoriesSubcategoriesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppCategoriesSubcategoriesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppEncryptionDeclarationsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppEncryptionDeclarationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppEncryptionDeclarationsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppEncryptionDeclarationsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppEncryptionDeclarationsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppEncryptionDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppEncryptionDeclarationsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppEncryptionDeclarationsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppEncryptionDeclarationsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppEncryptionDeclarationsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppEncryptionDeclarationsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfoLocalizationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppInfoLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfoLocalizationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfoLocalizationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfoLocalizationsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfoLocalizationsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfoLocalizationsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfoLocalizationsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppInfoLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfoLocalizationsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfoLocalizationsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfoLocalizationsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppInfoLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfoLocalizationsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfoLocalizationsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppInfoResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppInfoResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosAppInfoLocalizationsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppInfoLocalizationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosAppInfoLocalizationsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosAppInfoLocalizationsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosPrimaryCategoryGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosPrimaryCategoryGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosPrimaryCategoryGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosPrimarySubcategoryOneGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosPrimarySubcategoryOneGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosPrimarySubcategoryOneGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosSecondaryCategoryGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosSecondaryCategoryGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosSecondaryCategoryGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosSecondarySubcategoryOneGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosSecondarySubcategoryOneGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosSecondarySubcategoryOneGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCategoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreOrdersCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppPreOrderResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreOrdersCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreOrdersCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreOrdersDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreOrdersDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreOrdersDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreOrdersGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreOrderResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreOrdersGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreOrdersGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreOrdersUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreOrderResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreOrdersUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreOrdersUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewSetsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppPreviewSetResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewSetsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewSetsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewSetsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewSetsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewSetsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewSetsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreviewSetResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewSetsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewSetsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewSetsAppPreviewsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreviewsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewSetsAppPreviewsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewSetsAppPreviewsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewSetsAppPreviewsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreviewSetAppPreviewsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewSetsAppPreviewsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewSetsAppPreviewsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppPreviewResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreviewResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPreviewsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreviewResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPreviewsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPreviewsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPricePointsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPricePointsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPricePointsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPricePointsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPricePointsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPricePointResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPricePointsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPricePointsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPricePointsTerritoryGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TerritoryResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPricePointsTerritoryGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPricePointsTerritoryGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPriceTiersGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPriceTiersResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPriceTiersGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPriceTiersGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPriceTiersGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPriceTierResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPriceTiersGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPriceTiersGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPriceTiersPricePointsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPricePointsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPriceTiersPricePointsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPriceTiersPricePointsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppPricesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPriceResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppPricesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppPricesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotSetsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppScreenshotSetResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotSetsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotSetsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotSetsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotSetsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotSetsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotSetsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppScreenshotSetResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotSetsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotSetsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppScreenshotsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppScreenshotSetAppScreenshotsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppScreenshotResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppScreenshotResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppScreenshotsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppScreenshotResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppScreenshotsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppScreenshotsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewAttachmentsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppStoreReviewAttachmentResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewAttachmentsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewAttachmentsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewAttachmentsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewAttachmentsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewAttachmentsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewAttachmentsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreReviewAttachmentResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewAttachmentsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewAttachmentsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewAttachmentsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreReviewAttachmentResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewAttachmentsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewAttachmentsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewDetailsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppStoreReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewDetailsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewDetailsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewDetailsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewDetailsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewDetailsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewDetailsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewDetailsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewDetailsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreReviewAttachmentsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionLocalizationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppStoreVersionLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionLocalizationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionLocalizationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionLocalizationsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionLocalizationsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionLocalizationsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionLocalizationsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionLocalizationsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionLocalizationsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionLocalizationsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionLocalizationsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionLocalizationsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreviewSetsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppScreenshotSetsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionPhasedReleasesCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppStoreVersionPhasedReleaseResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionPhasedReleasesCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionPhasedReleasesCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionPhasedReleasesDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionPhasedReleasesDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionPhasedReleasesDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionPhasedReleasesUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionPhasedReleaseResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionPhasedReleasesUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionPhasedReleasesUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionSubmissionsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppStoreVersionSubmissionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionSubmissionsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionSubmissionsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionSubmissionsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionSubmissionsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionSubmissionsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppStoreVersionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgeRatingDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionLocalizationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionPhasedReleaseResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionSubmissionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsBuildGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsBuildGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsBuildGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdfaDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsBuildGetToOneRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionBuildLinkageResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsBuildGetToOneRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsBuildGetToOneRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsBuildUpdateToOneRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsBuildUpdateToOneRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsBuildUpdateToOneRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoutingAppCoverageResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsAppInfosGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppInfosResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsAppInfosGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsAppInfosGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsAppStoreVersionsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsAppStoreVersionsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsAppStoreVersionsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsAvailableTerritoriesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TerritoriesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsAvailableTerritoriesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsAvailableTerritoriesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsBetaAppLocalizationsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppLocalizationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsBetaAppLocalizationsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsBetaAppLocalizationsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsBetaAppReviewDetailGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsBetaAppReviewDetailGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsBetaAppReviewDetailGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsBetaGroupsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsBetaGroupsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsBetaGroupsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsBetaLicenseAgreementGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsBetaLicenseAgreementGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsBetaLicenseAgreementGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsBuildsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsBuildsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsBuildsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsEndUserLicenseAgreementGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsEndUserLicenseAgreementGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsEndUserLicenseAgreementGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsGameCenterEnabledVersionsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameCenterEnabledVersionsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsGameCenterEnabledVersionsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsGameCenterEnabledVersionsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsInAppPurchasesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InAppPurchasesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsInAppPurchasesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsInAppPurchasesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsPerfPowerMetricsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PerfPowerMetricsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsPerfPowerMetricsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsPerfPowerMetricsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsPreOrderGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPreOrderResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsPreOrderGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsPreOrderGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsPreReleaseVersionsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreReleaseVersionsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsPreReleaseVersionsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsPreReleaseVersionsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsPricesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppPricesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsPricesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsPricesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsBetaTestersDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsBetaTestersDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsBetaTestersDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppLocalizationsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppLocalizationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppLocalizationsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppLocalizationsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppLocalizationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BetaAppLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppLocalizationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppLocalizationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppLocalizationsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppLocalizationsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppLocalizationsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppLocalizationsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppLocalizationsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppLocalizationsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppLocalizationsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppLocalizationsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppLocalizationsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppLocalizationsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppLocalizationsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppLocalizationsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewDetailsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewDetailsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewDetailsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewDetailsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewDetailsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewDetailsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewDetailsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewDetailsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewDetailsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewDetailsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewDetailsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewDetailsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewDetailsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewSubmissionsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewSubmissionsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewSubmissionsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewSubmissionsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewSubmissionsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BetaAppReviewSubmissionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewSubmissionsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewSubmissionsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewSubmissionsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewSubmissionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewSubmissionsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewSubmissionsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaAppReviewSubmissionsBuildGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaAppReviewSubmissionsBuildGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaAppReviewSubmissionsBuildGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaBuildLocalizationsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaBuildLocalizationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaBuildLocalizationsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaBuildLocalizationsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaBuildLocalizationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BetaBuildLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaBuildLocalizationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaBuildLocalizationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaBuildLocalizationsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaBuildLocalizationsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaBuildLocalizationsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaBuildLocalizationsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaBuildLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaBuildLocalizationsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaBuildLocalizationsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaBuildLocalizationsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaBuildLocalizationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaBuildLocalizationsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaBuildLocalizationsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaBuildLocalizationsBuildGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaBuildLocalizationsBuildGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaBuildLocalizationsBuildGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BetaGroupResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBetaTestersGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTestersResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBetaTestersGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBetaTestersGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBuildsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBuildsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBuildsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBetaTestersDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBetaTestersDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBetaTestersDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBetaTestersGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupBetaTestersLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBetaTestersGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBetaTestersGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBetaTestersCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBetaTestersCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBetaTestersCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBuildsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBuildsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBuildsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBuildsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupBuildsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBuildsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBuildsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaGroupsBuildsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaGroupsBuildsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaGroupsBuildsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaLicenseAgreementsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaLicenseAgreementsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaLicenseAgreementsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaLicenseAgreementsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaLicenseAgreementsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaLicenseAgreementsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaLicenseAgreementsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaLicenseAgreementsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaLicenseAgreementsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaLicenseAgreementsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaLicenseAgreementsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaLicenseAgreementsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaLicenseAgreementsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTesterInvitationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BetaTesterInvitationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTesterInvitationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTesterInvitationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTestersResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BetaTesterResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTesterResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersAppsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersAppsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersAppsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBetaGroupsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaGroupsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBetaGroupsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBetaGroupsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBuildsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBuildsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBuildsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersAppsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersAppsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersAppsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersAppsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTesterAppsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersAppsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersAppsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBetaGroupsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBetaGroupsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBetaGroupsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBetaGroupsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTesterBetaGroupsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBetaGroupsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBetaGroupsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBetaGroupsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBetaGroupsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBetaGroupsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBuildsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBuildsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBuildsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBuildsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTesterBuildsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBuildsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBuildsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BetaTestersBuildsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BetaTestersBuildsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BetaTestersBuildsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildBetaDetailsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildBetaDetailsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildBetaDetailsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildBetaDetailsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildBetaDetailsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildBetaDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildBetaDetailsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildBetaDetailsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildBetaDetailsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildBetaDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildBetaDetailsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildBetaDetailsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildBetaDetailsBuildGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildBetaDetailsBuildGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildBetaDetailsBuildGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildBetaNotificationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BuildBetaNotificationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildBetaNotificationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildBetaNotificationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsAppEncryptionDeclarationGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppEncryptionDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsAppEncryptionDeclarationGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsAppEncryptionDeclarationGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsAppStoreVersionGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreVersionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsAppStoreVersionGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsAppStoreVersionGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsBetaAppReviewSubmissionGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaAppReviewSubmissionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsBetaAppReviewSubmissionGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsBetaAppReviewSubmissionGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsBetaBuildLocalizationsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaBuildLocalizationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsBetaBuildLocalizationsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsBetaBuildLocalizationsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsBuildBetaDetailGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildBetaDetailResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsBuildBetaDetailGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsBuildBetaDetailGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsDiagnosticSignaturesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiagnosticSignaturesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsDiagnosticSignaturesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsDiagnosticSignaturesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsIconsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildIconsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsIconsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsIconsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsIndividualTestersGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BetaTestersResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsIndividualTestersGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsIndividualTestersGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsPerfPowerMetricsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PerfPowerMetricsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsPerfPowerMetricsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsPerfPowerMetricsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsPreReleaseVersionGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrereleaseVersionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsPreReleaseVersionGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsPreReleaseVersionGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsAppEncryptionDeclarationGetToOneRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildAppEncryptionDeclarationLinkageResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsAppEncryptionDeclarationGetToOneRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsAppEncryptionDeclarationGetToOneRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsBetaGroupsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsBetaGroupsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsBetaGroupsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsBetaGroupsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsBetaGroupsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsBetaGroupsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsIndividualTestersDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsIndividualTestersDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsIndividualTestersDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsIndividualTestersGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildIndividualTestersLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsIndividualTestersGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsIndividualTestersGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BuildsIndividualTestersCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BuildsIndividualTestersCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BuildsIndividualTestersCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdCapabilitiesCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BundleIdCapabilityResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdCapabilitiesCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdCapabilitiesCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdCapabilitiesDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdCapabilitiesDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdCapabilitiesDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdCapabilitiesUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleIdCapabilityResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdCapabilitiesUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdCapabilitiesUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleIdsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BundleIdResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleIdResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleIdResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleIdCapabilitiesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BundleIdsProfilesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfilesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BundleIdsProfilesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BundleIdsProfilesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertificatesGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificatesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CertificatesGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertificatesGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertificatesCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CertificateResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CertificatesCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertificatesCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertificatesDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CertificatesDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertificatesDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertificatesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CertificatesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertificatesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevicesGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevicesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DevicesGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevicesGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevicesCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DeviceResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DevicesCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevicesCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevicesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DevicesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevicesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DevicesUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeviceResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DevicesUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DevicesUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiagnosticSignaturesLogsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiagnosticLogsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DiagnosticSignaturesLogsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiagnosticSignaturesLogsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndUserLicenseAgreementsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndUserLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EndUserLicenseAgreementsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndUserLicenseAgreementsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndUserLicenseAgreementsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EndUserLicenseAgreementsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndUserLicenseAgreementsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndUserLicenseAgreementsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EndUserLicenseAgreementsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndUserLicenseAgreementsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndUserLicenseAgreementsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndUserLicenseAgreementResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EndUserLicenseAgreementsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndUserLicenseAgreementsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TerritoriesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FinanceReportsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r FinanceReportsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FinanceReportsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameCenterEnabledVersionsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameCenterEnabledVersionCompatibleVersionsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdfaDeclarationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IdfaDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdfaDeclarationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdfaDeclarationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdfaDeclarationsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdfaDeclarationsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdfaDeclarationsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdfaDeclarationsUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdfaDeclarationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IdfaDeclarationsUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdfaDeclarationsUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InAppPurchasesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InAppPurchaseResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InAppPurchasesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InAppPurchasesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreReleaseVersionsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreReleaseVersionsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PreReleaseVersionsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreReleaseVersionsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreReleaseVersionsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrereleaseVersionResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PreReleaseVersionsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreReleaseVersionsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreReleaseVersionsAppGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PreReleaseVersionsAppGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreReleaseVersionsAppGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreReleaseVersionsBuildsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PreReleaseVersionsBuildsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreReleaseVersionsBuildsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfilesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProfileResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesBundleIdGetToOneRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BundleIdResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesBundleIdGetToOneRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesBundleIdGetToOneRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesCertificatesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificatesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesCertificatesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesCertificatesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfilesDevicesGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DevicesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfilesDevicesGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfilesDevicesGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutingAppCoveragesCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RoutingAppCoverageResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RoutingAppCoveragesCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutingAppCoveragesCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutingAppCoveragesDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RoutingAppCoveragesDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutingAppCoveragesDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutingAppCoveragesGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoutingAppCoverageResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RoutingAppCoveragesGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutingAppCoveragesGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RoutingAppCoveragesUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoutingAppCoverageResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r RoutingAppCoveragesUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RoutingAppCoveragesUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SalesReportsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SalesReportsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SalesReportsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TerritoriesGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TerritoriesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TerritoriesGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TerritoriesGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserInvitationsGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserInvitationsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserInvitationsGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserInvitationsGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserInvitationsCreateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UserInvitationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserInvitationsCreateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserInvitationsCreateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserInvitationsDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserInvitationsDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserInvitationsDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserInvitationsGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserInvitationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserInvitationsGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserInvitationsGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserInvitationsVisibleAppsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UserInvitationsVisibleAppsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserInvitationsVisibleAppsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersGetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersDeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersGetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersGetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersGetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdateInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersUpdateInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdateInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersVisibleAppsDeleteToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersVisibleAppsDeleteToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersVisibleAppsDeleteToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersVisibleAppsGetToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserVisibleAppsLinkagesResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersVisibleAppsGetToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersVisibleAppsGetToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersVisibleAppsReplaceToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersVisibleAppsReplaceToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersVisibleAppsReplaceToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersVisibleAppsCreateToManyRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersVisibleAppsCreateToManyRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersVisibleAppsCreateToManyRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersVisibleAppsGetToManyRelatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppsResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UsersVisibleAppsGetToManyRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersVisibleAppsGetToManyRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AgeRatingDeclarationsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AgeRatingDeclarationsUpdateInstanceResponse
func (c *ClientWithResponses) AgeRatingDeclarationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AgeRatingDeclarationsUpdateInstanceResponse, error) {
	rsp, err := c.AgeRatingDeclarationsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAgeRatingDeclarationsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AgeRatingDeclarationsUpdateInstanceWithResponse(ctx context.Context, id string, body AgeRatingDeclarationsUpdateInstanceJSONRequestBody) (*AgeRatingDeclarationsUpdateInstanceResponse, error) {
	rsp, err := c.AgeRatingDeclarationsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAgeRatingDeclarationsUpdateInstanceResponse(rsp)
}

// AppCategoriesGetCollectionWithResponse request returning *AppCategoriesGetCollectionResponse
func (c *ClientWithResponses) AppCategoriesGetCollectionWithResponse(ctx context.Context, params *AppCategoriesGetCollectionParams) (*AppCategoriesGetCollectionResponse, error) {
	rsp, err := c.AppCategoriesGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseAppCategoriesGetCollectionResponse(rsp)
}

// AppCategoriesGetInstanceWithResponse request returning *AppCategoriesGetInstanceResponse
func (c *ClientWithResponses) AppCategoriesGetInstanceWithResponse(ctx context.Context, id string, params *AppCategoriesGetInstanceParams) (*AppCategoriesGetInstanceResponse, error) {
	rsp, err := c.AppCategoriesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppCategoriesGetInstanceResponse(rsp)
}

// AppCategoriesParentGetToOneRelatedWithResponse request returning *AppCategoriesParentGetToOneRelatedResponse
func (c *ClientWithResponses) AppCategoriesParentGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppCategoriesParentGetToOneRelatedParams) (*AppCategoriesParentGetToOneRelatedResponse, error) {
	rsp, err := c.AppCategoriesParentGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppCategoriesParentGetToOneRelatedResponse(rsp)
}

// AppCategoriesSubcategoriesGetToManyRelatedWithResponse request returning *AppCategoriesSubcategoriesGetToManyRelatedResponse
func (c *ClientWithResponses) AppCategoriesSubcategoriesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppCategoriesSubcategoriesGetToManyRelatedParams) (*AppCategoriesSubcategoriesGetToManyRelatedResponse, error) {
	rsp, err := c.AppCategoriesSubcategoriesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppCategoriesSubcategoriesGetToManyRelatedResponse(rsp)
}

// AppEncryptionDeclarationsGetCollectionWithResponse request returning *AppEncryptionDeclarationsGetCollectionResponse
func (c *ClientWithResponses) AppEncryptionDeclarationsGetCollectionWithResponse(ctx context.Context, params *AppEncryptionDeclarationsGetCollectionParams) (*AppEncryptionDeclarationsGetCollectionResponse, error) {
	rsp, err := c.AppEncryptionDeclarationsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseAppEncryptionDeclarationsGetCollectionResponse(rsp)
}

// AppEncryptionDeclarationsGetInstanceWithResponse request returning *AppEncryptionDeclarationsGetInstanceResponse
func (c *ClientWithResponses) AppEncryptionDeclarationsGetInstanceWithResponse(ctx context.Context, id string, params *AppEncryptionDeclarationsGetInstanceParams) (*AppEncryptionDeclarationsGetInstanceResponse, error) {
	rsp, err := c.AppEncryptionDeclarationsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppEncryptionDeclarationsGetInstanceResponse(rsp)
}

// AppEncryptionDeclarationsAppGetToOneRelatedWithResponse request returning *AppEncryptionDeclarationsAppGetToOneRelatedResponse
func (c *ClientWithResponses) AppEncryptionDeclarationsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppEncryptionDeclarationsAppGetToOneRelatedParams) (*AppEncryptionDeclarationsAppGetToOneRelatedResponse, error) {
	rsp, err := c.AppEncryptionDeclarationsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppEncryptionDeclarationsAppGetToOneRelatedResponse(rsp)
}

// AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse
func (c *ClientWithResponses) AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse, error) {
	rsp, err := c.AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body AppEncryptionDeclarationsBuildsCreateToManyRelationshipJSONRequestBody) (*AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse, error) {
	rsp, err := c.AppEncryptionDeclarationsBuildsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse(rsp)
}

// AppInfoLocalizationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppInfoLocalizationsCreateInstanceResponse
func (c *ClientWithResponses) AppInfoLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppInfoLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.AppInfoLocalizationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppInfoLocalizationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppInfoLocalizationsCreateInstanceWithResponse(ctx context.Context, body AppInfoLocalizationsCreateInstanceJSONRequestBody) (*AppInfoLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.AppInfoLocalizationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppInfoLocalizationsCreateInstanceResponse(rsp)
}

// AppInfoLocalizationsDeleteInstanceWithResponse request returning *AppInfoLocalizationsDeleteInstanceResponse
func (c *ClientWithResponses) AppInfoLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppInfoLocalizationsDeleteInstanceResponse, error) {
	rsp, err := c.AppInfoLocalizationsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppInfoLocalizationsDeleteInstanceResponse(rsp)
}

// AppInfoLocalizationsGetInstanceWithResponse request returning *AppInfoLocalizationsGetInstanceResponse
func (c *ClientWithResponses) AppInfoLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *AppInfoLocalizationsGetInstanceParams) (*AppInfoLocalizationsGetInstanceResponse, error) {
	rsp, err := c.AppInfoLocalizationsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfoLocalizationsGetInstanceResponse(rsp)
}

// AppInfoLocalizationsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppInfoLocalizationsUpdateInstanceResponse
func (c *ClientWithResponses) AppInfoLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppInfoLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.AppInfoLocalizationsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppInfoLocalizationsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppInfoLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body AppInfoLocalizationsUpdateInstanceJSONRequestBody) (*AppInfoLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.AppInfoLocalizationsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppInfoLocalizationsUpdateInstanceResponse(rsp)
}

// AppInfosGetInstanceWithResponse request returning *AppInfosGetInstanceResponse
func (c *ClientWithResponses) AppInfosGetInstanceWithResponse(ctx context.Context, id string, params *AppInfosGetInstanceParams) (*AppInfosGetInstanceResponse, error) {
	rsp, err := c.AppInfosGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosGetInstanceResponse(rsp)
}

// AppInfosUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppInfosUpdateInstanceResponse
func (c *ClientWithResponses) AppInfosUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppInfosUpdateInstanceResponse, error) {
	rsp, err := c.AppInfosUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppInfosUpdateInstanceWithResponse(ctx context.Context, id string, body AppInfosUpdateInstanceJSONRequestBody) (*AppInfosUpdateInstanceResponse, error) {
	rsp, err := c.AppInfosUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosUpdateInstanceResponse(rsp)
}

// AppInfosAppInfoLocalizationsGetToManyRelatedWithResponse request returning *AppInfosAppInfoLocalizationsGetToManyRelatedResponse
func (c *ClientWithResponses) AppInfosAppInfoLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppInfosAppInfoLocalizationsGetToManyRelatedParams) (*AppInfosAppInfoLocalizationsGetToManyRelatedResponse, error) {
	rsp, err := c.AppInfosAppInfoLocalizationsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosAppInfoLocalizationsGetToManyRelatedResponse(rsp)
}

// AppInfosPrimaryCategoryGetToOneRelatedWithResponse request returning *AppInfosPrimaryCategoryGetToOneRelatedResponse
func (c *ClientWithResponses) AppInfosPrimaryCategoryGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosPrimaryCategoryGetToOneRelatedParams) (*AppInfosPrimaryCategoryGetToOneRelatedResponse, error) {
	rsp, err := c.AppInfosPrimaryCategoryGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosPrimaryCategoryGetToOneRelatedResponse(rsp)
}

// AppInfosPrimarySubcategoryOneGetToOneRelatedWithResponse request returning *AppInfosPrimarySubcategoryOneGetToOneRelatedResponse
func (c *ClientWithResponses) AppInfosPrimarySubcategoryOneGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosPrimarySubcategoryOneGetToOneRelatedParams) (*AppInfosPrimarySubcategoryOneGetToOneRelatedResponse, error) {
	rsp, err := c.AppInfosPrimarySubcategoryOneGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosPrimarySubcategoryOneGetToOneRelatedResponse(rsp)
}

// AppInfosPrimarySubcategoryTwoGetToOneRelatedWithResponse request returning *AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse
func (c *ClientWithResponses) AppInfosPrimarySubcategoryTwoGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosPrimarySubcategoryTwoGetToOneRelatedParams) (*AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse, error) {
	rsp, err := c.AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosPrimarySubcategoryTwoGetToOneRelatedResponse(rsp)
}

// AppInfosSecondaryCategoryGetToOneRelatedWithResponse request returning *AppInfosSecondaryCategoryGetToOneRelatedResponse
func (c *ClientWithResponses) AppInfosSecondaryCategoryGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosSecondaryCategoryGetToOneRelatedParams) (*AppInfosSecondaryCategoryGetToOneRelatedResponse, error) {
	rsp, err := c.AppInfosSecondaryCategoryGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosSecondaryCategoryGetToOneRelatedResponse(rsp)
}

// AppInfosSecondarySubcategoryOneGetToOneRelatedWithResponse request returning *AppInfosSecondarySubcategoryOneGetToOneRelatedResponse
func (c *ClientWithResponses) AppInfosSecondarySubcategoryOneGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosSecondarySubcategoryOneGetToOneRelatedParams) (*AppInfosSecondarySubcategoryOneGetToOneRelatedResponse, error) {
	rsp, err := c.AppInfosSecondarySubcategoryOneGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosSecondarySubcategoryOneGetToOneRelatedResponse(rsp)
}

// AppInfosSecondarySubcategoryTwoGetToOneRelatedWithResponse request returning *AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse
func (c *ClientWithResponses) AppInfosSecondarySubcategoryTwoGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppInfosSecondarySubcategoryTwoGetToOneRelatedParams) (*AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse, error) {
	rsp, err := c.AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppInfosSecondarySubcategoryTwoGetToOneRelatedResponse(rsp)
}

// AppPreOrdersCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppPreOrdersCreateInstanceResponse
func (c *ClientWithResponses) AppPreOrdersCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppPreOrdersCreateInstanceResponse, error) {
	rsp, err := c.AppPreOrdersCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreOrdersCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppPreOrdersCreateInstanceWithResponse(ctx context.Context, body AppPreOrdersCreateInstanceJSONRequestBody) (*AppPreOrdersCreateInstanceResponse, error) {
	rsp, err := c.AppPreOrdersCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreOrdersCreateInstanceResponse(rsp)
}

// AppPreOrdersDeleteInstanceWithResponse request returning *AppPreOrdersDeleteInstanceResponse
func (c *ClientWithResponses) AppPreOrdersDeleteInstanceWithResponse(ctx context.Context, id string) (*AppPreOrdersDeleteInstanceResponse, error) {
	rsp, err := c.AppPreOrdersDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppPreOrdersDeleteInstanceResponse(rsp)
}

// AppPreOrdersGetInstanceWithResponse request returning *AppPreOrdersGetInstanceResponse
func (c *ClientWithResponses) AppPreOrdersGetInstanceWithResponse(ctx context.Context, id string, params *AppPreOrdersGetInstanceParams) (*AppPreOrdersGetInstanceResponse, error) {
	rsp, err := c.AppPreOrdersGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPreOrdersGetInstanceResponse(rsp)
}

// AppPreOrdersUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppPreOrdersUpdateInstanceResponse
func (c *ClientWithResponses) AppPreOrdersUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppPreOrdersUpdateInstanceResponse, error) {
	rsp, err := c.AppPreOrdersUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreOrdersUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppPreOrdersUpdateInstanceWithResponse(ctx context.Context, id string, body AppPreOrdersUpdateInstanceJSONRequestBody) (*AppPreOrdersUpdateInstanceResponse, error) {
	rsp, err := c.AppPreOrdersUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreOrdersUpdateInstanceResponse(rsp)
}

// AppPreviewSetsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppPreviewSetsCreateInstanceResponse
func (c *ClientWithResponses) AppPreviewSetsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppPreviewSetsCreateInstanceResponse, error) {
	rsp, err := c.AppPreviewSetsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppPreviewSetsCreateInstanceWithResponse(ctx context.Context, body AppPreviewSetsCreateInstanceJSONRequestBody) (*AppPreviewSetsCreateInstanceResponse, error) {
	rsp, err := c.AppPreviewSetsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsCreateInstanceResponse(rsp)
}

// AppPreviewSetsDeleteInstanceWithResponse request returning *AppPreviewSetsDeleteInstanceResponse
func (c *ClientWithResponses) AppPreviewSetsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppPreviewSetsDeleteInstanceResponse, error) {
	rsp, err := c.AppPreviewSetsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsDeleteInstanceResponse(rsp)
}

// AppPreviewSetsGetInstanceWithResponse request returning *AppPreviewSetsGetInstanceResponse
func (c *ClientWithResponses) AppPreviewSetsGetInstanceWithResponse(ctx context.Context, id string, params *AppPreviewSetsGetInstanceParams) (*AppPreviewSetsGetInstanceResponse, error) {
	rsp, err := c.AppPreviewSetsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsGetInstanceResponse(rsp)
}

// AppPreviewSetsAppPreviewsGetToManyRelatedWithResponse request returning *AppPreviewSetsAppPreviewsGetToManyRelatedResponse
func (c *ClientWithResponses) AppPreviewSetsAppPreviewsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelatedParams) (*AppPreviewSetsAppPreviewsGetToManyRelatedResponse, error) {
	rsp, err := c.AppPreviewSetsAppPreviewsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsAppPreviewsGetToManyRelatedResponse(rsp)
}

// AppPreviewSetsAppPreviewsGetToManyRelationshipWithResponse request returning *AppPreviewSetsAppPreviewsGetToManyRelationshipResponse
func (c *ClientWithResponses) AppPreviewSetsAppPreviewsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *AppPreviewSetsAppPreviewsGetToManyRelationshipParams) (*AppPreviewSetsAppPreviewsGetToManyRelationshipResponse, error) {
	rsp, err := c.AppPreviewSetsAppPreviewsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsAppPreviewsGetToManyRelationshipResponse(rsp)
}

// AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithBodyWithResponse request with arbitrary body returning *AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse
func (c *ClientWithResponses) AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body AppPreviewSetsAppPreviewsReplaceToManyRelationshipJSONRequestBody) (*AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.AppPreviewSetsAppPreviewsReplaceToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse(rsp)
}

// AppPreviewsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppPreviewsCreateInstanceResponse
func (c *ClientWithResponses) AppPreviewsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppPreviewsCreateInstanceResponse, error) {
	rsp, err := c.AppPreviewsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppPreviewsCreateInstanceWithResponse(ctx context.Context, body AppPreviewsCreateInstanceJSONRequestBody) (*AppPreviewsCreateInstanceResponse, error) {
	rsp, err := c.AppPreviewsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewsCreateInstanceResponse(rsp)
}

// AppPreviewsDeleteInstanceWithResponse request returning *AppPreviewsDeleteInstanceResponse
func (c *ClientWithResponses) AppPreviewsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppPreviewsDeleteInstanceResponse, error) {
	rsp, err := c.AppPreviewsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewsDeleteInstanceResponse(rsp)
}

// AppPreviewsGetInstanceWithResponse request returning *AppPreviewsGetInstanceResponse
func (c *ClientWithResponses) AppPreviewsGetInstanceWithResponse(ctx context.Context, id string, params *AppPreviewsGetInstanceParams) (*AppPreviewsGetInstanceResponse, error) {
	rsp, err := c.AppPreviewsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewsGetInstanceResponse(rsp)
}

// AppPreviewsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppPreviewsUpdateInstanceResponse
func (c *ClientWithResponses) AppPreviewsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppPreviewsUpdateInstanceResponse, error) {
	rsp, err := c.AppPreviewsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppPreviewsUpdateInstanceWithResponse(ctx context.Context, id string, body AppPreviewsUpdateInstanceJSONRequestBody) (*AppPreviewsUpdateInstanceResponse, error) {
	rsp, err := c.AppPreviewsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppPreviewsUpdateInstanceResponse(rsp)
}

// AppPricePointsGetCollectionWithResponse request returning *AppPricePointsGetCollectionResponse
func (c *ClientWithResponses) AppPricePointsGetCollectionWithResponse(ctx context.Context, params *AppPricePointsGetCollectionParams) (*AppPricePointsGetCollectionResponse, error) {
	rsp, err := c.AppPricePointsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPricePointsGetCollectionResponse(rsp)
}

// AppPricePointsGetInstanceWithResponse request returning *AppPricePointsGetInstanceResponse
func (c *ClientWithResponses) AppPricePointsGetInstanceWithResponse(ctx context.Context, id string, params *AppPricePointsGetInstanceParams) (*AppPricePointsGetInstanceResponse, error) {
	rsp, err := c.AppPricePointsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPricePointsGetInstanceResponse(rsp)
}

// AppPricePointsTerritoryGetToOneRelatedWithResponse request returning *AppPricePointsTerritoryGetToOneRelatedResponse
func (c *ClientWithResponses) AppPricePointsTerritoryGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppPricePointsTerritoryGetToOneRelatedParams) (*AppPricePointsTerritoryGetToOneRelatedResponse, error) {
	rsp, err := c.AppPricePointsTerritoryGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPricePointsTerritoryGetToOneRelatedResponse(rsp)
}

// AppPriceTiersGetCollectionWithResponse request returning *AppPriceTiersGetCollectionResponse
func (c *ClientWithResponses) AppPriceTiersGetCollectionWithResponse(ctx context.Context, params *AppPriceTiersGetCollectionParams) (*AppPriceTiersGetCollectionResponse, error) {
	rsp, err := c.AppPriceTiersGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPriceTiersGetCollectionResponse(rsp)
}

// AppPriceTiersGetInstanceWithResponse request returning *AppPriceTiersGetInstanceResponse
func (c *ClientWithResponses) AppPriceTiersGetInstanceWithResponse(ctx context.Context, id string, params *AppPriceTiersGetInstanceParams) (*AppPriceTiersGetInstanceResponse, error) {
	rsp, err := c.AppPriceTiersGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPriceTiersGetInstanceResponse(rsp)
}

// AppPriceTiersPricePointsGetToManyRelatedWithResponse request returning *AppPriceTiersPricePointsGetToManyRelatedResponse
func (c *ClientWithResponses) AppPriceTiersPricePointsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppPriceTiersPricePointsGetToManyRelatedParams) (*AppPriceTiersPricePointsGetToManyRelatedResponse, error) {
	rsp, err := c.AppPriceTiersPricePointsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPriceTiersPricePointsGetToManyRelatedResponse(rsp)
}

// AppPricesGetInstanceWithResponse request returning *AppPricesGetInstanceResponse
func (c *ClientWithResponses) AppPricesGetInstanceWithResponse(ctx context.Context, id string, params *AppPricesGetInstanceParams) (*AppPricesGetInstanceResponse, error) {
	rsp, err := c.AppPricesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppPricesGetInstanceResponse(rsp)
}

// AppScreenshotSetsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppScreenshotSetsCreateInstanceResponse
func (c *ClientWithResponses) AppScreenshotSetsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppScreenshotSetsCreateInstanceResponse, error) {
	rsp, err := c.AppScreenshotSetsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppScreenshotSetsCreateInstanceWithResponse(ctx context.Context, body AppScreenshotSetsCreateInstanceJSONRequestBody) (*AppScreenshotSetsCreateInstanceResponse, error) {
	rsp, err := c.AppScreenshotSetsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsCreateInstanceResponse(rsp)
}

// AppScreenshotSetsDeleteInstanceWithResponse request returning *AppScreenshotSetsDeleteInstanceResponse
func (c *ClientWithResponses) AppScreenshotSetsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppScreenshotSetsDeleteInstanceResponse, error) {
	rsp, err := c.AppScreenshotSetsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsDeleteInstanceResponse(rsp)
}

// AppScreenshotSetsGetInstanceWithResponse request returning *AppScreenshotSetsGetInstanceResponse
func (c *ClientWithResponses) AppScreenshotSetsGetInstanceWithResponse(ctx context.Context, id string, params *AppScreenshotSetsGetInstanceParams) (*AppScreenshotSetsGetInstanceResponse, error) {
	rsp, err := c.AppScreenshotSetsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsGetInstanceResponse(rsp)
}

// AppScreenshotSetsAppScreenshotsGetToManyRelatedWithResponse request returning *AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse
func (c *ClientWithResponses) AppScreenshotSetsAppScreenshotsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelatedParams) (*AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse, error) {
	rsp, err := c.AppScreenshotSetsAppScreenshotsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsAppScreenshotsGetToManyRelatedResponse(rsp)
}

// AppScreenshotSetsAppScreenshotsGetToManyRelationshipWithResponse request returning *AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse
func (c *ClientWithResponses) AppScreenshotSetsAppScreenshotsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams) (*AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse, error) {
	rsp, err := c.AppScreenshotSetsAppScreenshotsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse(rsp)
}

// AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithBodyWithResponse request with arbitrary body returning *AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse
func (c *ClientWithResponses) AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipJSONRequestBody) (*AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse(rsp)
}

// AppScreenshotsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppScreenshotsCreateInstanceResponse
func (c *ClientWithResponses) AppScreenshotsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppScreenshotsCreateInstanceResponse, error) {
	rsp, err := c.AppScreenshotsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppScreenshotsCreateInstanceWithResponse(ctx context.Context, body AppScreenshotsCreateInstanceJSONRequestBody) (*AppScreenshotsCreateInstanceResponse, error) {
	rsp, err := c.AppScreenshotsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotsCreateInstanceResponse(rsp)
}

// AppScreenshotsDeleteInstanceWithResponse request returning *AppScreenshotsDeleteInstanceResponse
func (c *ClientWithResponses) AppScreenshotsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppScreenshotsDeleteInstanceResponse, error) {
	rsp, err := c.AppScreenshotsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotsDeleteInstanceResponse(rsp)
}

// AppScreenshotsGetInstanceWithResponse request returning *AppScreenshotsGetInstanceResponse
func (c *ClientWithResponses) AppScreenshotsGetInstanceWithResponse(ctx context.Context, id string, params *AppScreenshotsGetInstanceParams) (*AppScreenshotsGetInstanceResponse, error) {
	rsp, err := c.AppScreenshotsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotsGetInstanceResponse(rsp)
}

// AppScreenshotsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppScreenshotsUpdateInstanceResponse
func (c *ClientWithResponses) AppScreenshotsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppScreenshotsUpdateInstanceResponse, error) {
	rsp, err := c.AppScreenshotsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppScreenshotsUpdateInstanceWithResponse(ctx context.Context, id string, body AppScreenshotsUpdateInstanceJSONRequestBody) (*AppScreenshotsUpdateInstanceResponse, error) {
	rsp, err := c.AppScreenshotsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppScreenshotsUpdateInstanceResponse(rsp)
}

// AppStoreReviewAttachmentsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreReviewAttachmentsCreateInstanceResponse
func (c *ClientWithResponses) AppStoreReviewAttachmentsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreReviewAttachmentsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewAttachmentsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewAttachmentsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreReviewAttachmentsCreateInstanceWithResponse(ctx context.Context, body AppStoreReviewAttachmentsCreateInstanceJSONRequestBody) (*AppStoreReviewAttachmentsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewAttachmentsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewAttachmentsCreateInstanceResponse(rsp)
}

// AppStoreReviewAttachmentsDeleteInstanceWithResponse request returning *AppStoreReviewAttachmentsDeleteInstanceResponse
func (c *ClientWithResponses) AppStoreReviewAttachmentsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreReviewAttachmentsDeleteInstanceResponse, error) {
	rsp, err := c.AppStoreReviewAttachmentsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewAttachmentsDeleteInstanceResponse(rsp)
}

// AppStoreReviewAttachmentsGetInstanceWithResponse request returning *AppStoreReviewAttachmentsGetInstanceResponse
func (c *ClientWithResponses) AppStoreReviewAttachmentsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreReviewAttachmentsGetInstanceParams) (*AppStoreReviewAttachmentsGetInstanceResponse, error) {
	rsp, err := c.AppStoreReviewAttachmentsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewAttachmentsGetInstanceResponse(rsp)
}

// AppStoreReviewAttachmentsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreReviewAttachmentsUpdateInstanceResponse
func (c *ClientWithResponses) AppStoreReviewAttachmentsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreReviewAttachmentsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewAttachmentsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewAttachmentsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreReviewAttachmentsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreReviewAttachmentsUpdateInstanceJSONRequestBody) (*AppStoreReviewAttachmentsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewAttachmentsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewAttachmentsUpdateInstanceResponse(rsp)
}

// AppStoreReviewDetailsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreReviewDetailsCreateInstanceResponse
func (c *ClientWithResponses) AppStoreReviewDetailsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreReviewDetailsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewDetailsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewDetailsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreReviewDetailsCreateInstanceWithResponse(ctx context.Context, body AppStoreReviewDetailsCreateInstanceJSONRequestBody) (*AppStoreReviewDetailsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewDetailsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewDetailsCreateInstanceResponse(rsp)
}

// AppStoreReviewDetailsGetInstanceWithResponse request returning *AppStoreReviewDetailsGetInstanceResponse
func (c *ClientWithResponses) AppStoreReviewDetailsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreReviewDetailsGetInstanceParams) (*AppStoreReviewDetailsGetInstanceResponse, error) {
	rsp, err := c.AppStoreReviewDetailsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewDetailsGetInstanceResponse(rsp)
}

// AppStoreReviewDetailsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreReviewDetailsUpdateInstanceResponse
func (c *ClientWithResponses) AppStoreReviewDetailsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreReviewDetailsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewDetailsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewDetailsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreReviewDetailsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreReviewDetailsUpdateInstanceJSONRequestBody) (*AppStoreReviewDetailsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreReviewDetailsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewDetailsUpdateInstanceResponse(rsp)
}

// AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithResponse request returning *AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse
func (c *ClientWithResponses) AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams) (*AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse, error) {
	rsp, err := c.AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse(rsp)
}

// AppStoreVersionLocalizationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionLocalizationsCreateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionLocalizationsCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionLocalizationsCreateInstanceJSONRequestBody) (*AppStoreVersionLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsCreateInstanceResponse(rsp)
}

// AppStoreVersionLocalizationsDeleteInstanceWithResponse request returning *AppStoreVersionLocalizationsDeleteInstanceResponse
func (c *ClientWithResponses) AppStoreVersionLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionLocalizationsDeleteInstanceResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsDeleteInstanceResponse(rsp)
}

// AppStoreVersionLocalizationsGetInstanceWithResponse request returning *AppStoreVersionLocalizationsGetInstanceResponse
func (c *ClientWithResponses) AppStoreVersionLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreVersionLocalizationsGetInstanceParams) (*AppStoreVersionLocalizationsGetInstanceResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsGetInstanceResponse(rsp)
}

// AppStoreVersionLocalizationsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionLocalizationsUpdateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreVersionLocalizationsUpdateInstanceJSONRequestBody) (*AppStoreVersionLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsUpdateInstanceResponse(rsp)
}

// AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithResponse request returning *AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse
func (c *ClientWithResponses) AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams) (*AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse(rsp)
}

// AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithResponse request returning *AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse
func (c *ClientWithResponses) AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams) (*AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse, error) {
	rsp, err := c.AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse(rsp)
}

// AppStoreVersionPhasedReleasesCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionPhasedReleasesCreateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionPhasedReleasesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionPhasedReleasesCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionPhasedReleasesCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionPhasedReleasesCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionPhasedReleasesCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionPhasedReleasesCreateInstanceJSONRequestBody) (*AppStoreVersionPhasedReleasesCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionPhasedReleasesCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionPhasedReleasesCreateInstanceResponse(rsp)
}

// AppStoreVersionPhasedReleasesDeleteInstanceWithResponse request returning *AppStoreVersionPhasedReleasesDeleteInstanceResponse
func (c *ClientWithResponses) AppStoreVersionPhasedReleasesDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionPhasedReleasesDeleteInstanceResponse, error) {
	rsp, err := c.AppStoreVersionPhasedReleasesDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionPhasedReleasesDeleteInstanceResponse(rsp)
}

// AppStoreVersionPhasedReleasesUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionPhasedReleasesUpdateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionPhasedReleasesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionPhasedReleasesUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionPhasedReleasesUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionPhasedReleasesUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionPhasedReleasesUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreVersionPhasedReleasesUpdateInstanceJSONRequestBody) (*AppStoreVersionPhasedReleasesUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionPhasedReleasesUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionPhasedReleasesUpdateInstanceResponse(rsp)
}

// AppStoreVersionSubmissionsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionSubmissionsCreateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionSubmissionsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionSubmissionsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionSubmissionsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionSubmissionsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionSubmissionsCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionSubmissionsCreateInstanceJSONRequestBody) (*AppStoreVersionSubmissionsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionSubmissionsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionSubmissionsCreateInstanceResponse(rsp)
}

// AppStoreVersionSubmissionsDeleteInstanceWithResponse request returning *AppStoreVersionSubmissionsDeleteInstanceResponse
func (c *ClientWithResponses) AppStoreVersionSubmissionsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionSubmissionsDeleteInstanceResponse, error) {
	rsp, err := c.AppStoreVersionSubmissionsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionSubmissionsDeleteInstanceResponse(rsp)
}

// AppStoreVersionsCreateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionsCreateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*AppStoreVersionsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionsCreateInstanceWithResponse(ctx context.Context, body AppStoreVersionsCreateInstanceJSONRequestBody) (*AppStoreVersionsCreateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsCreateInstanceResponse(rsp)
}

// AppStoreVersionsDeleteInstanceWithResponse request returning *AppStoreVersionsDeleteInstanceResponse
func (c *ClientWithResponses) AppStoreVersionsDeleteInstanceWithResponse(ctx context.Context, id string) (*AppStoreVersionsDeleteInstanceResponse, error) {
	rsp, err := c.AppStoreVersionsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsDeleteInstanceResponse(rsp)
}

// AppStoreVersionsGetInstanceWithResponse request returning *AppStoreVersionsGetInstanceResponse
func (c *ClientWithResponses) AppStoreVersionsGetInstanceWithResponse(ctx context.Context, id string, params *AppStoreVersionsGetInstanceParams) (*AppStoreVersionsGetInstanceResponse, error) {
	rsp, err := c.AppStoreVersionsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsGetInstanceResponse(rsp)
}

// AppStoreVersionsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppStoreVersionsUpdateInstanceResponse
func (c *ClientWithResponses) AppStoreVersionsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionsUpdateInstanceWithResponse(ctx context.Context, id string, body AppStoreVersionsUpdateInstanceJSONRequestBody) (*AppStoreVersionsUpdateInstanceResponse, error) {
	rsp, err := c.AppStoreVersionsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsUpdateInstanceResponse(rsp)
}

// AppStoreVersionsAgeRatingDeclarationGetToOneRelatedWithResponse request returning *AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsAgeRatingDeclarationGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams) (*AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse(rsp)
}

// AppStoreVersionsAppStoreReviewDetailGetToOneRelatedWithResponse request returning *AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsAppStoreReviewDetailGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams) (*AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse(rsp)
}

// AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithResponse request returning *AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams) (*AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse(rsp)
}

// AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithResponse request returning *AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams) (*AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse(rsp)
}

// AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithResponse request returning *AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams) (*AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse(rsp)
}

// AppStoreVersionsBuildGetToOneRelatedWithResponse request returning *AppStoreVersionsBuildGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsBuildGetToOneRelatedParams) (*AppStoreVersionsBuildGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsBuildGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsBuildGetToOneRelatedResponse(rsp)
}

// AppStoreVersionsIdfaDeclarationGetToOneRelatedWithResponse request returning *AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsIdfaDeclarationGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsIdfaDeclarationGetToOneRelatedParams) (*AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsIdfaDeclarationGetToOneRelatedResponse(rsp)
}

// AppStoreVersionsBuildGetToOneRelationshipWithResponse request returning *AppStoreVersionsBuildGetToOneRelationshipResponse
func (c *ClientWithResponses) AppStoreVersionsBuildGetToOneRelationshipWithResponse(ctx context.Context, id string) (*AppStoreVersionsBuildGetToOneRelationshipResponse, error) {
	rsp, err := c.AppStoreVersionsBuildGetToOneRelationship(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsBuildGetToOneRelationshipResponse(rsp)
}

// AppStoreVersionsBuildUpdateToOneRelationshipWithBodyWithResponse request with arbitrary body returning *AppStoreVersionsBuildUpdateToOneRelationshipResponse
func (c *ClientWithResponses) AppStoreVersionsBuildUpdateToOneRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppStoreVersionsBuildUpdateToOneRelationshipResponse, error) {
	rsp, err := c.AppStoreVersionsBuildUpdateToOneRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsBuildUpdateToOneRelationshipResponse(rsp)
}

func (c *ClientWithResponses) AppStoreVersionsBuildUpdateToOneRelationshipWithResponse(ctx context.Context, id string, body AppStoreVersionsBuildUpdateToOneRelationshipJSONRequestBody) (*AppStoreVersionsBuildUpdateToOneRelationshipResponse, error) {
	rsp, err := c.AppStoreVersionsBuildUpdateToOneRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsBuildUpdateToOneRelationshipResponse(rsp)
}

// AppStoreVersionsRoutingAppCoverageGetToOneRelatedWithResponse request returning *AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse
func (c *ClientWithResponses) AppStoreVersionsRoutingAppCoverageGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams) (*AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse, error) {
	rsp, err := c.AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse(rsp)
}

// AppsGetCollectionWithResponse request returning *AppsGetCollectionResponse
func (c *ClientWithResponses) AppsGetCollectionWithResponse(ctx context.Context, params *AppsGetCollectionParams) (*AppsGetCollectionResponse, error) {
	rsp, err := c.AppsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsGetCollectionResponse(rsp)
}

// AppsGetInstanceWithResponse request returning *AppsGetInstanceResponse
func (c *ClientWithResponses) AppsGetInstanceWithResponse(ctx context.Context, id string, params *AppsGetInstanceParams) (*AppsGetInstanceResponse, error) {
	rsp, err := c.AppsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsGetInstanceResponse(rsp)
}

// AppsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *AppsUpdateInstanceResponse
func (c *ClientWithResponses) AppsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppsUpdateInstanceResponse, error) {
	rsp, err := c.AppsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) AppsUpdateInstanceWithResponse(ctx context.Context, id string, body AppsUpdateInstanceJSONRequestBody) (*AppsUpdateInstanceResponse, error) {
	rsp, err := c.AppsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppsUpdateInstanceResponse(rsp)
}

// AppsAppInfosGetToManyRelatedWithResponse request returning *AppsAppInfosGetToManyRelatedResponse
func (c *ClientWithResponses) AppsAppInfosGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsAppInfosGetToManyRelatedParams) (*AppsAppInfosGetToManyRelatedResponse, error) {
	rsp, err := c.AppsAppInfosGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsAppInfosGetToManyRelatedResponse(rsp)
}

// AppsAppStoreVersionsGetToManyRelatedWithResponse request returning *AppsAppStoreVersionsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsAppStoreVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsAppStoreVersionsGetToManyRelatedParams) (*AppsAppStoreVersionsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsAppStoreVersionsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsAppStoreVersionsGetToManyRelatedResponse(rsp)
}

// AppsAvailableTerritoriesGetToManyRelatedWithResponse request returning *AppsAvailableTerritoriesGetToManyRelatedResponse
func (c *ClientWithResponses) AppsAvailableTerritoriesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsAvailableTerritoriesGetToManyRelatedParams) (*AppsAvailableTerritoriesGetToManyRelatedResponse, error) {
	rsp, err := c.AppsAvailableTerritoriesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsAvailableTerritoriesGetToManyRelatedResponse(rsp)
}

// AppsBetaAppLocalizationsGetToManyRelatedWithResponse request returning *AppsBetaAppLocalizationsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsBetaAppLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsBetaAppLocalizationsGetToManyRelatedParams) (*AppsBetaAppLocalizationsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsBetaAppLocalizationsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsBetaAppLocalizationsGetToManyRelatedResponse(rsp)
}

// AppsBetaAppReviewDetailGetToOneRelatedWithResponse request returning *AppsBetaAppReviewDetailGetToOneRelatedResponse
func (c *ClientWithResponses) AppsBetaAppReviewDetailGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsBetaAppReviewDetailGetToOneRelatedParams) (*AppsBetaAppReviewDetailGetToOneRelatedResponse, error) {
	rsp, err := c.AppsBetaAppReviewDetailGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsBetaAppReviewDetailGetToOneRelatedResponse(rsp)
}

// AppsBetaGroupsGetToManyRelatedWithResponse request returning *AppsBetaGroupsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsBetaGroupsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsBetaGroupsGetToManyRelatedParams) (*AppsBetaGroupsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsBetaGroupsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsBetaGroupsGetToManyRelatedResponse(rsp)
}

// AppsBetaLicenseAgreementGetToOneRelatedWithResponse request returning *AppsBetaLicenseAgreementGetToOneRelatedResponse
func (c *ClientWithResponses) AppsBetaLicenseAgreementGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsBetaLicenseAgreementGetToOneRelatedParams) (*AppsBetaLicenseAgreementGetToOneRelatedResponse, error) {
	rsp, err := c.AppsBetaLicenseAgreementGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsBetaLicenseAgreementGetToOneRelatedResponse(rsp)
}

// AppsBuildsGetToManyRelatedWithResponse request returning *AppsBuildsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsBuildsGetToManyRelatedParams) (*AppsBuildsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsBuildsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsBuildsGetToManyRelatedResponse(rsp)
}

// AppsEndUserLicenseAgreementGetToOneRelatedWithResponse request returning *AppsEndUserLicenseAgreementGetToOneRelatedResponse
func (c *ClientWithResponses) AppsEndUserLicenseAgreementGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsEndUserLicenseAgreementGetToOneRelatedParams) (*AppsEndUserLicenseAgreementGetToOneRelatedResponse, error) {
	rsp, err := c.AppsEndUserLicenseAgreementGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsEndUserLicenseAgreementGetToOneRelatedResponse(rsp)
}

// AppsGameCenterEnabledVersionsGetToManyRelatedWithResponse request returning *AppsGameCenterEnabledVersionsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsGameCenterEnabledVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsGameCenterEnabledVersionsGetToManyRelatedParams) (*AppsGameCenterEnabledVersionsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsGameCenterEnabledVersionsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsGameCenterEnabledVersionsGetToManyRelatedResponse(rsp)
}

// AppsInAppPurchasesGetToManyRelatedWithResponse request returning *AppsInAppPurchasesGetToManyRelatedResponse
func (c *ClientWithResponses) AppsInAppPurchasesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsInAppPurchasesGetToManyRelatedParams) (*AppsInAppPurchasesGetToManyRelatedResponse, error) {
	rsp, err := c.AppsInAppPurchasesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsInAppPurchasesGetToManyRelatedResponse(rsp)
}

// AppsPerfPowerMetricsGetToManyRelatedWithResponse request returning *AppsPerfPowerMetricsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsPerfPowerMetricsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsPerfPowerMetricsGetToManyRelatedParams) (*AppsPerfPowerMetricsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsPerfPowerMetricsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsPerfPowerMetricsGetToManyRelatedResponse(rsp)
}

// AppsPreOrderGetToOneRelatedWithResponse request returning *AppsPreOrderGetToOneRelatedResponse
func (c *ClientWithResponses) AppsPreOrderGetToOneRelatedWithResponse(ctx context.Context, id string, params *AppsPreOrderGetToOneRelatedParams) (*AppsPreOrderGetToOneRelatedResponse, error) {
	rsp, err := c.AppsPreOrderGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsPreOrderGetToOneRelatedResponse(rsp)
}

// AppsPreReleaseVersionsGetToManyRelatedWithResponse request returning *AppsPreReleaseVersionsGetToManyRelatedResponse
func (c *ClientWithResponses) AppsPreReleaseVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsPreReleaseVersionsGetToManyRelatedParams) (*AppsPreReleaseVersionsGetToManyRelatedResponse, error) {
	rsp, err := c.AppsPreReleaseVersionsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsPreReleaseVersionsGetToManyRelatedResponse(rsp)
}

// AppsPricesGetToManyRelatedWithResponse request returning *AppsPricesGetToManyRelatedResponse
func (c *ClientWithResponses) AppsPricesGetToManyRelatedWithResponse(ctx context.Context, id string, params *AppsPricesGetToManyRelatedParams) (*AppsPricesGetToManyRelatedResponse, error) {
	rsp, err := c.AppsPricesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseAppsPricesGetToManyRelatedResponse(rsp)
}

// AppsBetaTestersDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *AppsBetaTestersDeleteToManyRelationshipResponse
func (c *ClientWithResponses) AppsBetaTestersDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*AppsBetaTestersDeleteToManyRelationshipResponse, error) {
	rsp, err := c.AppsBetaTestersDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseAppsBetaTestersDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) AppsBetaTestersDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body AppsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*AppsBetaTestersDeleteToManyRelationshipResponse, error) {
	rsp, err := c.AppsBetaTestersDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseAppsBetaTestersDeleteToManyRelationshipResponse(rsp)
}

// BetaAppLocalizationsGetCollectionWithResponse request returning *BetaAppLocalizationsGetCollectionResponse
func (c *ClientWithResponses) BetaAppLocalizationsGetCollectionWithResponse(ctx context.Context, params *BetaAppLocalizationsGetCollectionParams) (*BetaAppLocalizationsGetCollectionResponse, error) {
	rsp, err := c.BetaAppLocalizationsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsGetCollectionResponse(rsp)
}

// BetaAppLocalizationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BetaAppLocalizationsCreateInstanceResponse
func (c *ClientWithResponses) BetaAppLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaAppLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.BetaAppLocalizationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaAppLocalizationsCreateInstanceWithResponse(ctx context.Context, body BetaAppLocalizationsCreateInstanceJSONRequestBody) (*BetaAppLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.BetaAppLocalizationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsCreateInstanceResponse(rsp)
}

// BetaAppLocalizationsDeleteInstanceWithResponse request returning *BetaAppLocalizationsDeleteInstanceResponse
func (c *ClientWithResponses) BetaAppLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaAppLocalizationsDeleteInstanceResponse, error) {
	rsp, err := c.BetaAppLocalizationsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsDeleteInstanceResponse(rsp)
}

// BetaAppLocalizationsGetInstanceWithResponse request returning *BetaAppLocalizationsGetInstanceResponse
func (c *ClientWithResponses) BetaAppLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *BetaAppLocalizationsGetInstanceParams) (*BetaAppLocalizationsGetInstanceResponse, error) {
	rsp, err := c.BetaAppLocalizationsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsGetInstanceResponse(rsp)
}

// BetaAppLocalizationsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BetaAppLocalizationsUpdateInstanceResponse
func (c *ClientWithResponses) BetaAppLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaAppLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.BetaAppLocalizationsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaAppLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaAppLocalizationsUpdateInstanceJSONRequestBody) (*BetaAppLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.BetaAppLocalizationsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsUpdateInstanceResponse(rsp)
}

// BetaAppLocalizationsAppGetToOneRelatedWithResponse request returning *BetaAppLocalizationsAppGetToOneRelatedResponse
func (c *ClientWithResponses) BetaAppLocalizationsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaAppLocalizationsAppGetToOneRelatedParams) (*BetaAppLocalizationsAppGetToOneRelatedResponse, error) {
	rsp, err := c.BetaAppLocalizationsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppLocalizationsAppGetToOneRelatedResponse(rsp)
}

// BetaAppReviewDetailsGetCollectionWithResponse request returning *BetaAppReviewDetailsGetCollectionResponse
func (c *ClientWithResponses) BetaAppReviewDetailsGetCollectionWithResponse(ctx context.Context, params *BetaAppReviewDetailsGetCollectionParams) (*BetaAppReviewDetailsGetCollectionResponse, error) {
	rsp, err := c.BetaAppReviewDetailsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewDetailsGetCollectionResponse(rsp)
}

// BetaAppReviewDetailsGetInstanceWithResponse request returning *BetaAppReviewDetailsGetInstanceResponse
func (c *ClientWithResponses) BetaAppReviewDetailsGetInstanceWithResponse(ctx context.Context, id string, params *BetaAppReviewDetailsGetInstanceParams) (*BetaAppReviewDetailsGetInstanceResponse, error) {
	rsp, err := c.BetaAppReviewDetailsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewDetailsGetInstanceResponse(rsp)
}

// BetaAppReviewDetailsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BetaAppReviewDetailsUpdateInstanceResponse
func (c *ClientWithResponses) BetaAppReviewDetailsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaAppReviewDetailsUpdateInstanceResponse, error) {
	rsp, err := c.BetaAppReviewDetailsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewDetailsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaAppReviewDetailsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaAppReviewDetailsUpdateInstanceJSONRequestBody) (*BetaAppReviewDetailsUpdateInstanceResponse, error) {
	rsp, err := c.BetaAppReviewDetailsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewDetailsUpdateInstanceResponse(rsp)
}

// BetaAppReviewDetailsAppGetToOneRelatedWithResponse request returning *BetaAppReviewDetailsAppGetToOneRelatedResponse
func (c *ClientWithResponses) BetaAppReviewDetailsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaAppReviewDetailsAppGetToOneRelatedParams) (*BetaAppReviewDetailsAppGetToOneRelatedResponse, error) {
	rsp, err := c.BetaAppReviewDetailsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewDetailsAppGetToOneRelatedResponse(rsp)
}

// BetaAppReviewSubmissionsGetCollectionWithResponse request returning *BetaAppReviewSubmissionsGetCollectionResponse
func (c *ClientWithResponses) BetaAppReviewSubmissionsGetCollectionWithResponse(ctx context.Context, params *BetaAppReviewSubmissionsGetCollectionParams) (*BetaAppReviewSubmissionsGetCollectionResponse, error) {
	rsp, err := c.BetaAppReviewSubmissionsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewSubmissionsGetCollectionResponse(rsp)
}

// BetaAppReviewSubmissionsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BetaAppReviewSubmissionsCreateInstanceResponse
func (c *ClientWithResponses) BetaAppReviewSubmissionsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaAppReviewSubmissionsCreateInstanceResponse, error) {
	rsp, err := c.BetaAppReviewSubmissionsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewSubmissionsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaAppReviewSubmissionsCreateInstanceWithResponse(ctx context.Context, body BetaAppReviewSubmissionsCreateInstanceJSONRequestBody) (*BetaAppReviewSubmissionsCreateInstanceResponse, error) {
	rsp, err := c.BetaAppReviewSubmissionsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewSubmissionsCreateInstanceResponse(rsp)
}

// BetaAppReviewSubmissionsGetInstanceWithResponse request returning *BetaAppReviewSubmissionsGetInstanceResponse
func (c *ClientWithResponses) BetaAppReviewSubmissionsGetInstanceWithResponse(ctx context.Context, id string, params *BetaAppReviewSubmissionsGetInstanceParams) (*BetaAppReviewSubmissionsGetInstanceResponse, error) {
	rsp, err := c.BetaAppReviewSubmissionsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewSubmissionsGetInstanceResponse(rsp)
}

// BetaAppReviewSubmissionsBuildGetToOneRelatedWithResponse request returning *BetaAppReviewSubmissionsBuildGetToOneRelatedResponse
func (c *ClientWithResponses) BetaAppReviewSubmissionsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaAppReviewSubmissionsBuildGetToOneRelatedParams) (*BetaAppReviewSubmissionsBuildGetToOneRelatedResponse, error) {
	rsp, err := c.BetaAppReviewSubmissionsBuildGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaAppReviewSubmissionsBuildGetToOneRelatedResponse(rsp)
}

// BetaBuildLocalizationsGetCollectionWithResponse request returning *BetaBuildLocalizationsGetCollectionResponse
func (c *ClientWithResponses) BetaBuildLocalizationsGetCollectionWithResponse(ctx context.Context, params *BetaBuildLocalizationsGetCollectionParams) (*BetaBuildLocalizationsGetCollectionResponse, error) {
	rsp, err := c.BetaBuildLocalizationsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsGetCollectionResponse(rsp)
}

// BetaBuildLocalizationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BetaBuildLocalizationsCreateInstanceResponse
func (c *ClientWithResponses) BetaBuildLocalizationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaBuildLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.BetaBuildLocalizationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaBuildLocalizationsCreateInstanceWithResponse(ctx context.Context, body BetaBuildLocalizationsCreateInstanceJSONRequestBody) (*BetaBuildLocalizationsCreateInstanceResponse, error) {
	rsp, err := c.BetaBuildLocalizationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsCreateInstanceResponse(rsp)
}

// BetaBuildLocalizationsDeleteInstanceWithResponse request returning *BetaBuildLocalizationsDeleteInstanceResponse
func (c *ClientWithResponses) BetaBuildLocalizationsDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaBuildLocalizationsDeleteInstanceResponse, error) {
	rsp, err := c.BetaBuildLocalizationsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsDeleteInstanceResponse(rsp)
}

// BetaBuildLocalizationsGetInstanceWithResponse request returning *BetaBuildLocalizationsGetInstanceResponse
func (c *ClientWithResponses) BetaBuildLocalizationsGetInstanceWithResponse(ctx context.Context, id string, params *BetaBuildLocalizationsGetInstanceParams) (*BetaBuildLocalizationsGetInstanceResponse, error) {
	rsp, err := c.BetaBuildLocalizationsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsGetInstanceResponse(rsp)
}

// BetaBuildLocalizationsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BetaBuildLocalizationsUpdateInstanceResponse
func (c *ClientWithResponses) BetaBuildLocalizationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaBuildLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.BetaBuildLocalizationsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaBuildLocalizationsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaBuildLocalizationsUpdateInstanceJSONRequestBody) (*BetaBuildLocalizationsUpdateInstanceResponse, error) {
	rsp, err := c.BetaBuildLocalizationsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsUpdateInstanceResponse(rsp)
}

// BetaBuildLocalizationsBuildGetToOneRelatedWithResponse request returning *BetaBuildLocalizationsBuildGetToOneRelatedResponse
func (c *ClientWithResponses) BetaBuildLocalizationsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaBuildLocalizationsBuildGetToOneRelatedParams) (*BetaBuildLocalizationsBuildGetToOneRelatedResponse, error) {
	rsp, err := c.BetaBuildLocalizationsBuildGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaBuildLocalizationsBuildGetToOneRelatedResponse(rsp)
}

// BetaGroupsGetCollectionWithResponse request returning *BetaGroupsGetCollectionResponse
func (c *ClientWithResponses) BetaGroupsGetCollectionWithResponse(ctx context.Context, params *BetaGroupsGetCollectionParams) (*BetaGroupsGetCollectionResponse, error) {
	rsp, err := c.BetaGroupsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsGetCollectionResponse(rsp)
}

// BetaGroupsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BetaGroupsCreateInstanceResponse
func (c *ClientWithResponses) BetaGroupsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaGroupsCreateInstanceResponse, error) {
	rsp, err := c.BetaGroupsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaGroupsCreateInstanceWithResponse(ctx context.Context, body BetaGroupsCreateInstanceJSONRequestBody) (*BetaGroupsCreateInstanceResponse, error) {
	rsp, err := c.BetaGroupsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsCreateInstanceResponse(rsp)
}

// BetaGroupsDeleteInstanceWithResponse request returning *BetaGroupsDeleteInstanceResponse
func (c *ClientWithResponses) BetaGroupsDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaGroupsDeleteInstanceResponse, error) {
	rsp, err := c.BetaGroupsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsDeleteInstanceResponse(rsp)
}

// BetaGroupsGetInstanceWithResponse request returning *BetaGroupsGetInstanceResponse
func (c *ClientWithResponses) BetaGroupsGetInstanceWithResponse(ctx context.Context, id string, params *BetaGroupsGetInstanceParams) (*BetaGroupsGetInstanceResponse, error) {
	rsp, err := c.BetaGroupsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsGetInstanceResponse(rsp)
}

// BetaGroupsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BetaGroupsUpdateInstanceResponse
func (c *ClientWithResponses) BetaGroupsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsUpdateInstanceResponse, error) {
	rsp, err := c.BetaGroupsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaGroupsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaGroupsUpdateInstanceJSONRequestBody) (*BetaGroupsUpdateInstanceResponse, error) {
	rsp, err := c.BetaGroupsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsUpdateInstanceResponse(rsp)
}

// BetaGroupsAppGetToOneRelatedWithResponse request returning *BetaGroupsAppGetToOneRelatedResponse
func (c *ClientWithResponses) BetaGroupsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaGroupsAppGetToOneRelatedParams) (*BetaGroupsAppGetToOneRelatedResponse, error) {
	rsp, err := c.BetaGroupsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsAppGetToOneRelatedResponse(rsp)
}

// BetaGroupsBetaTestersGetToManyRelatedWithResponse request returning *BetaGroupsBetaTestersGetToManyRelatedResponse
func (c *ClientWithResponses) BetaGroupsBetaTestersGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelatedParams) (*BetaGroupsBetaTestersGetToManyRelatedResponse, error) {
	rsp, err := c.BetaGroupsBetaTestersGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBetaTestersGetToManyRelatedResponse(rsp)
}

// BetaGroupsBuildsGetToManyRelatedWithResponse request returning *BetaGroupsBuildsGetToManyRelatedResponse
func (c *ClientWithResponses) BetaGroupsBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelatedParams) (*BetaGroupsBuildsGetToManyRelatedResponse, error) {
	rsp, err := c.BetaGroupsBuildsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBuildsGetToManyRelatedResponse(rsp)
}

// BetaGroupsBetaTestersDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaGroupsBetaTestersDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BetaGroupsBetaTestersDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBetaTestersDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBetaTestersDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBetaTestersDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaGroupsBetaTestersDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBetaTestersDeleteToManyRelationshipJSONRequestBody) (*BetaGroupsBetaTestersDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBetaTestersDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBetaTestersDeleteToManyRelationshipResponse(rsp)
}

// BetaGroupsBetaTestersGetToManyRelationshipWithResponse request returning *BetaGroupsBetaTestersGetToManyRelationshipResponse
func (c *ClientWithResponses) BetaGroupsBetaTestersGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaGroupsBetaTestersGetToManyRelationshipParams) (*BetaGroupsBetaTestersGetToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBetaTestersGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBetaTestersGetToManyRelationshipResponse(rsp)
}

// BetaGroupsBetaTestersCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaGroupsBetaTestersCreateToManyRelationshipResponse
func (c *ClientWithResponses) BetaGroupsBetaTestersCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBetaTestersCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBetaTestersCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBetaTestersCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaGroupsBetaTestersCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBetaTestersCreateToManyRelationshipJSONRequestBody) (*BetaGroupsBetaTestersCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBetaTestersCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBetaTestersCreateToManyRelationshipResponse(rsp)
}

// BetaGroupsBuildsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaGroupsBuildsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BetaGroupsBuildsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBuildsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBuildsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBuildsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaGroupsBuildsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBuildsDeleteToManyRelationshipJSONRequestBody) (*BetaGroupsBuildsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBuildsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBuildsDeleteToManyRelationshipResponse(rsp)
}

// BetaGroupsBuildsGetToManyRelationshipWithResponse request returning *BetaGroupsBuildsGetToManyRelationshipResponse
func (c *ClientWithResponses) BetaGroupsBuildsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaGroupsBuildsGetToManyRelationshipParams) (*BetaGroupsBuildsGetToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBuildsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBuildsGetToManyRelationshipResponse(rsp)
}

// BetaGroupsBuildsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaGroupsBuildsCreateToManyRelationshipResponse
func (c *ClientWithResponses) BetaGroupsBuildsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaGroupsBuildsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBuildsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBuildsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaGroupsBuildsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaGroupsBuildsCreateToManyRelationshipJSONRequestBody) (*BetaGroupsBuildsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaGroupsBuildsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaGroupsBuildsCreateToManyRelationshipResponse(rsp)
}

// BetaLicenseAgreementsGetCollectionWithResponse request returning *BetaLicenseAgreementsGetCollectionResponse
func (c *ClientWithResponses) BetaLicenseAgreementsGetCollectionWithResponse(ctx context.Context, params *BetaLicenseAgreementsGetCollectionParams) (*BetaLicenseAgreementsGetCollectionResponse, error) {
	rsp, err := c.BetaLicenseAgreementsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaLicenseAgreementsGetCollectionResponse(rsp)
}

// BetaLicenseAgreementsGetInstanceWithResponse request returning *BetaLicenseAgreementsGetInstanceResponse
func (c *ClientWithResponses) BetaLicenseAgreementsGetInstanceWithResponse(ctx context.Context, id string, params *BetaLicenseAgreementsGetInstanceParams) (*BetaLicenseAgreementsGetInstanceResponse, error) {
	rsp, err := c.BetaLicenseAgreementsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaLicenseAgreementsGetInstanceResponse(rsp)
}

// BetaLicenseAgreementsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BetaLicenseAgreementsUpdateInstanceResponse
func (c *ClientWithResponses) BetaLicenseAgreementsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaLicenseAgreementsUpdateInstanceResponse, error) {
	rsp, err := c.BetaLicenseAgreementsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaLicenseAgreementsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaLicenseAgreementsUpdateInstanceWithResponse(ctx context.Context, id string, body BetaLicenseAgreementsUpdateInstanceJSONRequestBody) (*BetaLicenseAgreementsUpdateInstanceResponse, error) {
	rsp, err := c.BetaLicenseAgreementsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaLicenseAgreementsUpdateInstanceResponse(rsp)
}

// BetaLicenseAgreementsAppGetToOneRelatedWithResponse request returning *BetaLicenseAgreementsAppGetToOneRelatedResponse
func (c *ClientWithResponses) BetaLicenseAgreementsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BetaLicenseAgreementsAppGetToOneRelatedParams) (*BetaLicenseAgreementsAppGetToOneRelatedResponse, error) {
	rsp, err := c.BetaLicenseAgreementsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaLicenseAgreementsAppGetToOneRelatedResponse(rsp)
}

// BetaTesterInvitationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BetaTesterInvitationsCreateInstanceResponse
func (c *ClientWithResponses) BetaTesterInvitationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaTesterInvitationsCreateInstanceResponse, error) {
	rsp, err := c.BetaTesterInvitationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTesterInvitationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaTesterInvitationsCreateInstanceWithResponse(ctx context.Context, body BetaTesterInvitationsCreateInstanceJSONRequestBody) (*BetaTesterInvitationsCreateInstanceResponse, error) {
	rsp, err := c.BetaTesterInvitationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTesterInvitationsCreateInstanceResponse(rsp)
}

// BetaTestersGetCollectionWithResponse request returning *BetaTestersGetCollectionResponse
func (c *ClientWithResponses) BetaTestersGetCollectionWithResponse(ctx context.Context, params *BetaTestersGetCollectionParams) (*BetaTestersGetCollectionResponse, error) {
	rsp, err := c.BetaTestersGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersGetCollectionResponse(rsp)
}

// BetaTestersCreateInstanceWithBodyWithResponse request with arbitrary body returning *BetaTestersCreateInstanceResponse
func (c *ClientWithResponses) BetaTestersCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BetaTestersCreateInstanceResponse, error) {
	rsp, err := c.BetaTestersCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BetaTestersCreateInstanceWithResponse(ctx context.Context, body BetaTestersCreateInstanceJSONRequestBody) (*BetaTestersCreateInstanceResponse, error) {
	rsp, err := c.BetaTestersCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersCreateInstanceResponse(rsp)
}

// BetaTestersDeleteInstanceWithResponse request returning *BetaTestersDeleteInstanceResponse
func (c *ClientWithResponses) BetaTestersDeleteInstanceWithResponse(ctx context.Context, id string) (*BetaTestersDeleteInstanceResponse, error) {
	rsp, err := c.BetaTestersDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersDeleteInstanceResponse(rsp)
}

// BetaTestersGetInstanceWithResponse request returning *BetaTestersGetInstanceResponse
func (c *ClientWithResponses) BetaTestersGetInstanceWithResponse(ctx context.Context, id string, params *BetaTestersGetInstanceParams) (*BetaTestersGetInstanceResponse, error) {
	rsp, err := c.BetaTestersGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersGetInstanceResponse(rsp)
}

// BetaTestersAppsGetToManyRelatedWithResponse request returning *BetaTestersAppsGetToManyRelatedResponse
func (c *ClientWithResponses) BetaTestersAppsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelatedParams) (*BetaTestersAppsGetToManyRelatedResponse, error) {
	rsp, err := c.BetaTestersAppsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersAppsGetToManyRelatedResponse(rsp)
}

// BetaTestersBetaGroupsGetToManyRelatedWithResponse request returning *BetaTestersBetaGroupsGetToManyRelatedResponse
func (c *ClientWithResponses) BetaTestersBetaGroupsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelatedParams) (*BetaTestersBetaGroupsGetToManyRelatedResponse, error) {
	rsp, err := c.BetaTestersBetaGroupsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBetaGroupsGetToManyRelatedResponse(rsp)
}

// BetaTestersBuildsGetToManyRelatedWithResponse request returning *BetaTestersBuildsGetToManyRelatedResponse
func (c *ClientWithResponses) BetaTestersBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelatedParams) (*BetaTestersBuildsGetToManyRelatedResponse, error) {
	rsp, err := c.BetaTestersBuildsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBuildsGetToManyRelatedResponse(rsp)
}

// BetaTestersAppsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaTestersAppsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersAppsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersAppsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersAppsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersAppsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaTestersAppsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersAppsDeleteToManyRelationshipJSONRequestBody) (*BetaTestersAppsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersAppsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersAppsDeleteToManyRelationshipResponse(rsp)
}

// BetaTestersAppsGetToManyRelationshipWithResponse request returning *BetaTestersAppsGetToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersAppsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaTestersAppsGetToManyRelationshipParams) (*BetaTestersAppsGetToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersAppsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersAppsGetToManyRelationshipResponse(rsp)
}

// BetaTestersBetaGroupsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaTestersBetaGroupsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersBetaGroupsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBetaGroupsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBetaGroupsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBetaGroupsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaTestersBetaGroupsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*BetaTestersBetaGroupsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBetaGroupsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBetaGroupsDeleteToManyRelationshipResponse(rsp)
}

// BetaTestersBetaGroupsGetToManyRelationshipWithResponse request returning *BetaTestersBetaGroupsGetToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersBetaGroupsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaTestersBetaGroupsGetToManyRelationshipParams) (*BetaTestersBetaGroupsGetToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBetaGroupsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBetaGroupsGetToManyRelationshipResponse(rsp)
}

// BetaTestersBetaGroupsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaTestersBetaGroupsCreateToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersBetaGroupsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBetaGroupsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBetaGroupsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBetaGroupsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaTestersBetaGroupsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBetaGroupsCreateToManyRelationshipJSONRequestBody) (*BetaTestersBetaGroupsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBetaGroupsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBetaGroupsCreateToManyRelationshipResponse(rsp)
}

// BetaTestersBuildsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaTestersBuildsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersBuildsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBuildsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBuildsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBuildsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaTestersBuildsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBuildsDeleteToManyRelationshipJSONRequestBody) (*BetaTestersBuildsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBuildsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBuildsDeleteToManyRelationshipResponse(rsp)
}

// BetaTestersBuildsGetToManyRelationshipWithResponse request returning *BetaTestersBuildsGetToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersBuildsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BetaTestersBuildsGetToManyRelationshipParams) (*BetaTestersBuildsGetToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBuildsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBuildsGetToManyRelationshipResponse(rsp)
}

// BetaTestersBuildsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BetaTestersBuildsCreateToManyRelationshipResponse
func (c *ClientWithResponses) BetaTestersBuildsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BetaTestersBuildsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBuildsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBuildsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BetaTestersBuildsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BetaTestersBuildsCreateToManyRelationshipJSONRequestBody) (*BetaTestersBuildsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BetaTestersBuildsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBetaTestersBuildsCreateToManyRelationshipResponse(rsp)
}

// BuildBetaDetailsGetCollectionWithResponse request returning *BuildBetaDetailsGetCollectionResponse
func (c *ClientWithResponses) BuildBetaDetailsGetCollectionWithResponse(ctx context.Context, params *BuildBetaDetailsGetCollectionParams) (*BuildBetaDetailsGetCollectionResponse, error) {
	rsp, err := c.BuildBetaDetailsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaDetailsGetCollectionResponse(rsp)
}

// BuildBetaDetailsGetInstanceWithResponse request returning *BuildBetaDetailsGetInstanceResponse
func (c *ClientWithResponses) BuildBetaDetailsGetInstanceWithResponse(ctx context.Context, id string, params *BuildBetaDetailsGetInstanceParams) (*BuildBetaDetailsGetInstanceResponse, error) {
	rsp, err := c.BuildBetaDetailsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaDetailsGetInstanceResponse(rsp)
}

// BuildBetaDetailsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BuildBetaDetailsUpdateInstanceResponse
func (c *ClientWithResponses) BuildBetaDetailsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildBetaDetailsUpdateInstanceResponse, error) {
	rsp, err := c.BuildBetaDetailsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaDetailsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BuildBetaDetailsUpdateInstanceWithResponse(ctx context.Context, id string, body BuildBetaDetailsUpdateInstanceJSONRequestBody) (*BuildBetaDetailsUpdateInstanceResponse, error) {
	rsp, err := c.BuildBetaDetailsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaDetailsUpdateInstanceResponse(rsp)
}

// BuildBetaDetailsBuildGetToOneRelatedWithResponse request returning *BuildBetaDetailsBuildGetToOneRelatedResponse
func (c *ClientWithResponses) BuildBetaDetailsBuildGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildBetaDetailsBuildGetToOneRelatedParams) (*BuildBetaDetailsBuildGetToOneRelatedResponse, error) {
	rsp, err := c.BuildBetaDetailsBuildGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaDetailsBuildGetToOneRelatedResponse(rsp)
}

// BuildBetaNotificationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BuildBetaNotificationsCreateInstanceResponse
func (c *ClientWithResponses) BuildBetaNotificationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BuildBetaNotificationsCreateInstanceResponse, error) {
	rsp, err := c.BuildBetaNotificationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaNotificationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BuildBetaNotificationsCreateInstanceWithResponse(ctx context.Context, body BuildBetaNotificationsCreateInstanceJSONRequestBody) (*BuildBetaNotificationsCreateInstanceResponse, error) {
	rsp, err := c.BuildBetaNotificationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildBetaNotificationsCreateInstanceResponse(rsp)
}

// BuildsGetCollectionWithResponse request returning *BuildsGetCollectionResponse
func (c *ClientWithResponses) BuildsGetCollectionWithResponse(ctx context.Context, params *BuildsGetCollectionParams) (*BuildsGetCollectionResponse, error) {
	rsp, err := c.BuildsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsGetCollectionResponse(rsp)
}

// BuildsGetInstanceWithResponse request returning *BuildsGetInstanceResponse
func (c *ClientWithResponses) BuildsGetInstanceWithResponse(ctx context.Context, id string, params *BuildsGetInstanceParams) (*BuildsGetInstanceResponse, error) {
	rsp, err := c.BuildsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsGetInstanceResponse(rsp)
}

// BuildsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BuildsUpdateInstanceResponse
func (c *ClientWithResponses) BuildsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsUpdateInstanceResponse, error) {
	rsp, err := c.BuildsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BuildsUpdateInstanceWithResponse(ctx context.Context, id string, body BuildsUpdateInstanceJSONRequestBody) (*BuildsUpdateInstanceResponse, error) {
	rsp, err := c.BuildsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsUpdateInstanceResponse(rsp)
}

// BuildsAppGetToOneRelatedWithResponse request returning *BuildsAppGetToOneRelatedResponse
func (c *ClientWithResponses) BuildsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsAppGetToOneRelatedParams) (*BuildsAppGetToOneRelatedResponse, error) {
	rsp, err := c.BuildsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsAppGetToOneRelatedResponse(rsp)
}

// BuildsAppEncryptionDeclarationGetToOneRelatedWithResponse request returning *BuildsAppEncryptionDeclarationGetToOneRelatedResponse
func (c *ClientWithResponses) BuildsAppEncryptionDeclarationGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsAppEncryptionDeclarationGetToOneRelatedParams) (*BuildsAppEncryptionDeclarationGetToOneRelatedResponse, error) {
	rsp, err := c.BuildsAppEncryptionDeclarationGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsAppEncryptionDeclarationGetToOneRelatedResponse(rsp)
}

// BuildsAppStoreVersionGetToOneRelatedWithResponse request returning *BuildsAppStoreVersionGetToOneRelatedResponse
func (c *ClientWithResponses) BuildsAppStoreVersionGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsAppStoreVersionGetToOneRelatedParams) (*BuildsAppStoreVersionGetToOneRelatedResponse, error) {
	rsp, err := c.BuildsAppStoreVersionGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsAppStoreVersionGetToOneRelatedResponse(rsp)
}

// BuildsBetaAppReviewSubmissionGetToOneRelatedWithResponse request returning *BuildsBetaAppReviewSubmissionGetToOneRelatedResponse
func (c *ClientWithResponses) BuildsBetaAppReviewSubmissionGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsBetaAppReviewSubmissionGetToOneRelatedParams) (*BuildsBetaAppReviewSubmissionGetToOneRelatedResponse, error) {
	rsp, err := c.BuildsBetaAppReviewSubmissionGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBetaAppReviewSubmissionGetToOneRelatedResponse(rsp)
}

// BuildsBetaBuildLocalizationsGetToManyRelatedWithResponse request returning *BuildsBetaBuildLocalizationsGetToManyRelatedResponse
func (c *ClientWithResponses) BuildsBetaBuildLocalizationsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsBetaBuildLocalizationsGetToManyRelatedParams) (*BuildsBetaBuildLocalizationsGetToManyRelatedResponse, error) {
	rsp, err := c.BuildsBetaBuildLocalizationsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBetaBuildLocalizationsGetToManyRelatedResponse(rsp)
}

// BuildsBuildBetaDetailGetToOneRelatedWithResponse request returning *BuildsBuildBetaDetailGetToOneRelatedResponse
func (c *ClientWithResponses) BuildsBuildBetaDetailGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsBuildBetaDetailGetToOneRelatedParams) (*BuildsBuildBetaDetailGetToOneRelatedResponse, error) {
	rsp, err := c.BuildsBuildBetaDetailGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBuildBetaDetailGetToOneRelatedResponse(rsp)
}

// BuildsDiagnosticSignaturesGetToManyRelatedWithResponse request returning *BuildsDiagnosticSignaturesGetToManyRelatedResponse
func (c *ClientWithResponses) BuildsDiagnosticSignaturesGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsDiagnosticSignaturesGetToManyRelatedParams) (*BuildsDiagnosticSignaturesGetToManyRelatedResponse, error) {
	rsp, err := c.BuildsDiagnosticSignaturesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsDiagnosticSignaturesGetToManyRelatedResponse(rsp)
}

// BuildsIconsGetToManyRelatedWithResponse request returning *BuildsIconsGetToManyRelatedResponse
func (c *ClientWithResponses) BuildsIconsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsIconsGetToManyRelatedParams) (*BuildsIconsGetToManyRelatedResponse, error) {
	rsp, err := c.BuildsIconsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIconsGetToManyRelatedResponse(rsp)
}

// BuildsIndividualTestersGetToManyRelatedWithResponse request returning *BuildsIndividualTestersGetToManyRelatedResponse
func (c *ClientWithResponses) BuildsIndividualTestersGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelatedParams) (*BuildsIndividualTestersGetToManyRelatedResponse, error) {
	rsp, err := c.BuildsIndividualTestersGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIndividualTestersGetToManyRelatedResponse(rsp)
}

// BuildsPerfPowerMetricsGetToManyRelatedWithResponse request returning *BuildsPerfPowerMetricsGetToManyRelatedResponse
func (c *ClientWithResponses) BuildsPerfPowerMetricsGetToManyRelatedWithResponse(ctx context.Context, id string, params *BuildsPerfPowerMetricsGetToManyRelatedParams) (*BuildsPerfPowerMetricsGetToManyRelatedResponse, error) {
	rsp, err := c.BuildsPerfPowerMetricsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsPerfPowerMetricsGetToManyRelatedResponse(rsp)
}

// BuildsPreReleaseVersionGetToOneRelatedWithResponse request returning *BuildsPreReleaseVersionGetToOneRelatedResponse
func (c *ClientWithResponses) BuildsPreReleaseVersionGetToOneRelatedWithResponse(ctx context.Context, id string, params *BuildsPreReleaseVersionGetToOneRelatedParams) (*BuildsPreReleaseVersionGetToOneRelatedResponse, error) {
	rsp, err := c.BuildsPreReleaseVersionGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsPreReleaseVersionGetToOneRelatedResponse(rsp)
}

// BuildsAppEncryptionDeclarationGetToOneRelationshipWithResponse request returning *BuildsAppEncryptionDeclarationGetToOneRelationshipResponse
func (c *ClientWithResponses) BuildsAppEncryptionDeclarationGetToOneRelationshipWithResponse(ctx context.Context, id string) (*BuildsAppEncryptionDeclarationGetToOneRelationshipResponse, error) {
	rsp, err := c.BuildsAppEncryptionDeclarationGetToOneRelationship(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBuildsAppEncryptionDeclarationGetToOneRelationshipResponse(rsp)
}

// BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithBodyWithResponse request with arbitrary body returning *BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse
func (c *ClientWithResponses) BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse, error) {
	rsp, err := c.BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithResponse(ctx context.Context, id string, body BuildsAppEncryptionDeclarationUpdateToOneRelationshipJSONRequestBody) (*BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse, error) {
	rsp, err := c.BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse(rsp)
}

// BuildsBetaGroupsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BuildsBetaGroupsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BuildsBetaGroupsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsBetaGroupsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BuildsBetaGroupsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBetaGroupsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BuildsBetaGroupsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsBetaGroupsDeleteToManyRelationshipJSONRequestBody) (*BuildsBetaGroupsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BuildsBetaGroupsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBetaGroupsDeleteToManyRelationshipResponse(rsp)
}

// BuildsBetaGroupsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BuildsBetaGroupsCreateToManyRelationshipResponse
func (c *ClientWithResponses) BuildsBetaGroupsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsBetaGroupsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BuildsBetaGroupsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBetaGroupsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BuildsBetaGroupsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsBetaGroupsCreateToManyRelationshipJSONRequestBody) (*BuildsBetaGroupsCreateToManyRelationshipResponse, error) {
	rsp, err := c.BuildsBetaGroupsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsBetaGroupsCreateToManyRelationshipResponse(rsp)
}

// BuildsIndividualTestersDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BuildsIndividualTestersDeleteToManyRelationshipResponse
func (c *ClientWithResponses) BuildsIndividualTestersDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsIndividualTestersDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BuildsIndividualTestersDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIndividualTestersDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BuildsIndividualTestersDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsIndividualTestersDeleteToManyRelationshipJSONRequestBody) (*BuildsIndividualTestersDeleteToManyRelationshipResponse, error) {
	rsp, err := c.BuildsIndividualTestersDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIndividualTestersDeleteToManyRelationshipResponse(rsp)
}

// BuildsIndividualTestersGetToManyRelationshipWithResponse request returning *BuildsIndividualTestersGetToManyRelationshipResponse
func (c *ClientWithResponses) BuildsIndividualTestersGetToManyRelationshipWithResponse(ctx context.Context, id string, params *BuildsIndividualTestersGetToManyRelationshipParams) (*BuildsIndividualTestersGetToManyRelationshipResponse, error) {
	rsp, err := c.BuildsIndividualTestersGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIndividualTestersGetToManyRelationshipResponse(rsp)
}

// BuildsIndividualTestersCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *BuildsIndividualTestersCreateToManyRelationshipResponse
func (c *ClientWithResponses) BuildsIndividualTestersCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BuildsIndividualTestersCreateToManyRelationshipResponse, error) {
	rsp, err := c.BuildsIndividualTestersCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIndividualTestersCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) BuildsIndividualTestersCreateToManyRelationshipWithResponse(ctx context.Context, id string, body BuildsIndividualTestersCreateToManyRelationshipJSONRequestBody) (*BuildsIndividualTestersCreateToManyRelationshipResponse, error) {
	rsp, err := c.BuildsIndividualTestersCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBuildsIndividualTestersCreateToManyRelationshipResponse(rsp)
}

// BundleIdCapabilitiesCreateInstanceWithBodyWithResponse request with arbitrary body returning *BundleIdCapabilitiesCreateInstanceResponse
func (c *ClientWithResponses) BundleIdCapabilitiesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BundleIdCapabilitiesCreateInstanceResponse, error) {
	rsp, err := c.BundleIdCapabilitiesCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdCapabilitiesCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BundleIdCapabilitiesCreateInstanceWithResponse(ctx context.Context, body BundleIdCapabilitiesCreateInstanceJSONRequestBody) (*BundleIdCapabilitiesCreateInstanceResponse, error) {
	rsp, err := c.BundleIdCapabilitiesCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdCapabilitiesCreateInstanceResponse(rsp)
}

// BundleIdCapabilitiesDeleteInstanceWithResponse request returning *BundleIdCapabilitiesDeleteInstanceResponse
func (c *ClientWithResponses) BundleIdCapabilitiesDeleteInstanceWithResponse(ctx context.Context, id string) (*BundleIdCapabilitiesDeleteInstanceResponse, error) {
	rsp, err := c.BundleIdCapabilitiesDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdCapabilitiesDeleteInstanceResponse(rsp)
}

// BundleIdCapabilitiesUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BundleIdCapabilitiesUpdateInstanceResponse
func (c *ClientWithResponses) BundleIdCapabilitiesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BundleIdCapabilitiesUpdateInstanceResponse, error) {
	rsp, err := c.BundleIdCapabilitiesUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdCapabilitiesUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BundleIdCapabilitiesUpdateInstanceWithResponse(ctx context.Context, id string, body BundleIdCapabilitiesUpdateInstanceJSONRequestBody) (*BundleIdCapabilitiesUpdateInstanceResponse, error) {
	rsp, err := c.BundleIdCapabilitiesUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdCapabilitiesUpdateInstanceResponse(rsp)
}

// BundleIdsGetCollectionWithResponse request returning *BundleIdsGetCollectionResponse
func (c *ClientWithResponses) BundleIdsGetCollectionWithResponse(ctx context.Context, params *BundleIdsGetCollectionParams) (*BundleIdsGetCollectionResponse, error) {
	rsp, err := c.BundleIdsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsGetCollectionResponse(rsp)
}

// BundleIdsCreateInstanceWithBodyWithResponse request with arbitrary body returning *BundleIdsCreateInstanceResponse
func (c *ClientWithResponses) BundleIdsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*BundleIdsCreateInstanceResponse, error) {
	rsp, err := c.BundleIdsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BundleIdsCreateInstanceWithResponse(ctx context.Context, body BundleIdsCreateInstanceJSONRequestBody) (*BundleIdsCreateInstanceResponse, error) {
	rsp, err := c.BundleIdsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsCreateInstanceResponse(rsp)
}

// BundleIdsDeleteInstanceWithResponse request returning *BundleIdsDeleteInstanceResponse
func (c *ClientWithResponses) BundleIdsDeleteInstanceWithResponse(ctx context.Context, id string) (*BundleIdsDeleteInstanceResponse, error) {
	rsp, err := c.BundleIdsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsDeleteInstanceResponse(rsp)
}

// BundleIdsGetInstanceWithResponse request returning *BundleIdsGetInstanceResponse
func (c *ClientWithResponses) BundleIdsGetInstanceWithResponse(ctx context.Context, id string, params *BundleIdsGetInstanceParams) (*BundleIdsGetInstanceResponse, error) {
	rsp, err := c.BundleIdsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsGetInstanceResponse(rsp)
}

// BundleIdsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *BundleIdsUpdateInstanceResponse
func (c *ClientWithResponses) BundleIdsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*BundleIdsUpdateInstanceResponse, error) {
	rsp, err := c.BundleIdsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) BundleIdsUpdateInstanceWithResponse(ctx context.Context, id string, body BundleIdsUpdateInstanceJSONRequestBody) (*BundleIdsUpdateInstanceResponse, error) {
	rsp, err := c.BundleIdsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsUpdateInstanceResponse(rsp)
}

// BundleIdsAppGetToOneRelatedWithResponse request returning *BundleIdsAppGetToOneRelatedResponse
func (c *ClientWithResponses) BundleIdsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *BundleIdsAppGetToOneRelatedParams) (*BundleIdsAppGetToOneRelatedResponse, error) {
	rsp, err := c.BundleIdsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsAppGetToOneRelatedResponse(rsp)
}

// BundleIdsBundleIdCapabilitiesGetToManyRelatedWithResponse request returning *BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse
func (c *ClientWithResponses) BundleIdsBundleIdCapabilitiesGetToManyRelatedWithResponse(ctx context.Context, id string, params *BundleIdsBundleIdCapabilitiesGetToManyRelatedParams) (*BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse, error) {
	rsp, err := c.BundleIdsBundleIdCapabilitiesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsBundleIdCapabilitiesGetToManyRelatedResponse(rsp)
}

// BundleIdsProfilesGetToManyRelatedWithResponse request returning *BundleIdsProfilesGetToManyRelatedResponse
func (c *ClientWithResponses) BundleIdsProfilesGetToManyRelatedWithResponse(ctx context.Context, id string, params *BundleIdsProfilesGetToManyRelatedParams) (*BundleIdsProfilesGetToManyRelatedResponse, error) {
	rsp, err := c.BundleIdsProfilesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseBundleIdsProfilesGetToManyRelatedResponse(rsp)
}

// CertificatesGetCollectionWithResponse request returning *CertificatesGetCollectionResponse
func (c *ClientWithResponses) CertificatesGetCollectionWithResponse(ctx context.Context, params *CertificatesGetCollectionParams) (*CertificatesGetCollectionResponse, error) {
	rsp, err := c.CertificatesGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseCertificatesGetCollectionResponse(rsp)
}

// CertificatesCreateInstanceWithBodyWithResponse request with arbitrary body returning *CertificatesCreateInstanceResponse
func (c *ClientWithResponses) CertificatesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CertificatesCreateInstanceResponse, error) {
	rsp, err := c.CertificatesCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCertificatesCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) CertificatesCreateInstanceWithResponse(ctx context.Context, body CertificatesCreateInstanceJSONRequestBody) (*CertificatesCreateInstanceResponse, error) {
	rsp, err := c.CertificatesCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCertificatesCreateInstanceResponse(rsp)
}

// CertificatesDeleteInstanceWithResponse request returning *CertificatesDeleteInstanceResponse
func (c *ClientWithResponses) CertificatesDeleteInstanceWithResponse(ctx context.Context, id string) (*CertificatesDeleteInstanceResponse, error) {
	rsp, err := c.CertificatesDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseCertificatesDeleteInstanceResponse(rsp)
}

// CertificatesGetInstanceWithResponse request returning *CertificatesGetInstanceResponse
func (c *ClientWithResponses) CertificatesGetInstanceWithResponse(ctx context.Context, id string, params *CertificatesGetInstanceParams) (*CertificatesGetInstanceResponse, error) {
	rsp, err := c.CertificatesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseCertificatesGetInstanceResponse(rsp)
}

// DevicesGetCollectionWithResponse request returning *DevicesGetCollectionResponse
func (c *ClientWithResponses) DevicesGetCollectionWithResponse(ctx context.Context, params *DevicesGetCollectionParams) (*DevicesGetCollectionResponse, error) {
	rsp, err := c.DevicesGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseDevicesGetCollectionResponse(rsp)
}

// DevicesCreateInstanceWithBodyWithResponse request with arbitrary body returning *DevicesCreateInstanceResponse
func (c *ClientWithResponses) DevicesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*DevicesCreateInstanceResponse, error) {
	rsp, err := c.DevicesCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseDevicesCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) DevicesCreateInstanceWithResponse(ctx context.Context, body DevicesCreateInstanceJSONRequestBody) (*DevicesCreateInstanceResponse, error) {
	rsp, err := c.DevicesCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseDevicesCreateInstanceResponse(rsp)
}

// DevicesGetInstanceWithResponse request returning *DevicesGetInstanceResponse
func (c *ClientWithResponses) DevicesGetInstanceWithResponse(ctx context.Context, id string, params *DevicesGetInstanceParams) (*DevicesGetInstanceResponse, error) {
	rsp, err := c.DevicesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseDevicesGetInstanceResponse(rsp)
}

// DevicesUpdateInstanceWithBodyWithResponse request with arbitrary body returning *DevicesUpdateInstanceResponse
func (c *ClientWithResponses) DevicesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*DevicesUpdateInstanceResponse, error) {
	rsp, err := c.DevicesUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseDevicesUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) DevicesUpdateInstanceWithResponse(ctx context.Context, id string, body DevicesUpdateInstanceJSONRequestBody) (*DevicesUpdateInstanceResponse, error) {
	rsp, err := c.DevicesUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseDevicesUpdateInstanceResponse(rsp)
}

// DiagnosticSignaturesLogsGetToManyRelatedWithResponse request returning *DiagnosticSignaturesLogsGetToManyRelatedResponse
func (c *ClientWithResponses) DiagnosticSignaturesLogsGetToManyRelatedWithResponse(ctx context.Context, id string, params *DiagnosticSignaturesLogsGetToManyRelatedParams) (*DiagnosticSignaturesLogsGetToManyRelatedResponse, error) {
	rsp, err := c.DiagnosticSignaturesLogsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseDiagnosticSignaturesLogsGetToManyRelatedResponse(rsp)
}

// EndUserLicenseAgreementsCreateInstanceWithBodyWithResponse request with arbitrary body returning *EndUserLicenseAgreementsCreateInstanceResponse
func (c *ClientWithResponses) EndUserLicenseAgreementsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*EndUserLicenseAgreementsCreateInstanceResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) EndUserLicenseAgreementsCreateInstanceWithResponse(ctx context.Context, body EndUserLicenseAgreementsCreateInstanceJSONRequestBody) (*EndUserLicenseAgreementsCreateInstanceResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsCreateInstanceResponse(rsp)
}

// EndUserLicenseAgreementsDeleteInstanceWithResponse request returning *EndUserLicenseAgreementsDeleteInstanceResponse
func (c *ClientWithResponses) EndUserLicenseAgreementsDeleteInstanceWithResponse(ctx context.Context, id string) (*EndUserLicenseAgreementsDeleteInstanceResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsDeleteInstanceResponse(rsp)
}

// EndUserLicenseAgreementsGetInstanceWithResponse request returning *EndUserLicenseAgreementsGetInstanceResponse
func (c *ClientWithResponses) EndUserLicenseAgreementsGetInstanceWithResponse(ctx context.Context, id string, params *EndUserLicenseAgreementsGetInstanceParams) (*EndUserLicenseAgreementsGetInstanceResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsGetInstanceResponse(rsp)
}

// EndUserLicenseAgreementsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *EndUserLicenseAgreementsUpdateInstanceResponse
func (c *ClientWithResponses) EndUserLicenseAgreementsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*EndUserLicenseAgreementsUpdateInstanceResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) EndUserLicenseAgreementsUpdateInstanceWithResponse(ctx context.Context, id string, body EndUserLicenseAgreementsUpdateInstanceJSONRequestBody) (*EndUserLicenseAgreementsUpdateInstanceResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsUpdateInstanceResponse(rsp)
}

// EndUserLicenseAgreementsTerritoriesGetToManyRelatedWithResponse request returning *EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse
func (c *ClientWithResponses) EndUserLicenseAgreementsTerritoriesGetToManyRelatedWithResponse(ctx context.Context, id string, params *EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams) (*EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse, error) {
	rsp, err := c.EndUserLicenseAgreementsTerritoriesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseEndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse(rsp)
}

// FinanceReportsGetCollectionWithResponse request returning *FinanceReportsGetCollectionResponse
func (c *ClientWithResponses) FinanceReportsGetCollectionWithResponse(ctx context.Context, params *FinanceReportsGetCollectionParams) (*FinanceReportsGetCollectionResponse, error) {
	rsp, err := c.FinanceReportsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseFinanceReportsGetCollectionResponse(rsp)
}

// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithResponse request returning *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse
func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithResponse(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams) (*GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse(rsp)
}

// GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipJSONRequestBody) (*GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse(rsp)
}

// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithResponse request returning *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse
func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams) (*GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse(rsp)
}

// GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithBodyWithResponse request with arbitrary body returning *GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse
func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipJSONRequestBody) (*GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse(rsp)
}

// GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse
func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipJSONRequestBody) (*GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse, error) {
	rsp, err := c.GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse(rsp)
}

// IdfaDeclarationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *IdfaDeclarationsCreateInstanceResponse
func (c *ClientWithResponses) IdfaDeclarationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*IdfaDeclarationsCreateInstanceResponse, error) {
	rsp, err := c.IdfaDeclarationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseIdfaDeclarationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) IdfaDeclarationsCreateInstanceWithResponse(ctx context.Context, body IdfaDeclarationsCreateInstanceJSONRequestBody) (*IdfaDeclarationsCreateInstanceResponse, error) {
	rsp, err := c.IdfaDeclarationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseIdfaDeclarationsCreateInstanceResponse(rsp)
}

// IdfaDeclarationsDeleteInstanceWithResponse request returning *IdfaDeclarationsDeleteInstanceResponse
func (c *ClientWithResponses) IdfaDeclarationsDeleteInstanceWithResponse(ctx context.Context, id string) (*IdfaDeclarationsDeleteInstanceResponse, error) {
	rsp, err := c.IdfaDeclarationsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseIdfaDeclarationsDeleteInstanceResponse(rsp)
}

// IdfaDeclarationsUpdateInstanceWithBodyWithResponse request with arbitrary body returning *IdfaDeclarationsUpdateInstanceResponse
func (c *ClientWithResponses) IdfaDeclarationsUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*IdfaDeclarationsUpdateInstanceResponse, error) {
	rsp, err := c.IdfaDeclarationsUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseIdfaDeclarationsUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) IdfaDeclarationsUpdateInstanceWithResponse(ctx context.Context, id string, body IdfaDeclarationsUpdateInstanceJSONRequestBody) (*IdfaDeclarationsUpdateInstanceResponse, error) {
	rsp, err := c.IdfaDeclarationsUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseIdfaDeclarationsUpdateInstanceResponse(rsp)
}

// InAppPurchasesGetInstanceWithResponse request returning *InAppPurchasesGetInstanceResponse
func (c *ClientWithResponses) InAppPurchasesGetInstanceWithResponse(ctx context.Context, id string, params *InAppPurchasesGetInstanceParams) (*InAppPurchasesGetInstanceResponse, error) {
	rsp, err := c.InAppPurchasesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseInAppPurchasesGetInstanceResponse(rsp)
}

// PreReleaseVersionsGetCollectionWithResponse request returning *PreReleaseVersionsGetCollectionResponse
func (c *ClientWithResponses) PreReleaseVersionsGetCollectionWithResponse(ctx context.Context, params *PreReleaseVersionsGetCollectionParams) (*PreReleaseVersionsGetCollectionResponse, error) {
	rsp, err := c.PreReleaseVersionsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParsePreReleaseVersionsGetCollectionResponse(rsp)
}

// PreReleaseVersionsGetInstanceWithResponse request returning *PreReleaseVersionsGetInstanceResponse
func (c *ClientWithResponses) PreReleaseVersionsGetInstanceWithResponse(ctx context.Context, id string, params *PreReleaseVersionsGetInstanceParams) (*PreReleaseVersionsGetInstanceResponse, error) {
	rsp, err := c.PreReleaseVersionsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParsePreReleaseVersionsGetInstanceResponse(rsp)
}

// PreReleaseVersionsAppGetToOneRelatedWithResponse request returning *PreReleaseVersionsAppGetToOneRelatedResponse
func (c *ClientWithResponses) PreReleaseVersionsAppGetToOneRelatedWithResponse(ctx context.Context, id string, params *PreReleaseVersionsAppGetToOneRelatedParams) (*PreReleaseVersionsAppGetToOneRelatedResponse, error) {
	rsp, err := c.PreReleaseVersionsAppGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParsePreReleaseVersionsAppGetToOneRelatedResponse(rsp)
}

// PreReleaseVersionsBuildsGetToManyRelatedWithResponse request returning *PreReleaseVersionsBuildsGetToManyRelatedResponse
func (c *ClientWithResponses) PreReleaseVersionsBuildsGetToManyRelatedWithResponse(ctx context.Context, id string, params *PreReleaseVersionsBuildsGetToManyRelatedParams) (*PreReleaseVersionsBuildsGetToManyRelatedResponse, error) {
	rsp, err := c.PreReleaseVersionsBuildsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParsePreReleaseVersionsBuildsGetToManyRelatedResponse(rsp)
}

// ProfilesGetCollectionWithResponse request returning *ProfilesGetCollectionResponse
func (c *ClientWithResponses) ProfilesGetCollectionWithResponse(ctx context.Context, params *ProfilesGetCollectionParams) (*ProfilesGetCollectionResponse, error) {
	rsp, err := c.ProfilesGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseProfilesGetCollectionResponse(rsp)
}

// ProfilesCreateInstanceWithBodyWithResponse request with arbitrary body returning *ProfilesCreateInstanceResponse
func (c *ClientWithResponses) ProfilesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*ProfilesCreateInstanceResponse, error) {
	rsp, err := c.ProfilesCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseProfilesCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) ProfilesCreateInstanceWithResponse(ctx context.Context, body ProfilesCreateInstanceJSONRequestBody) (*ProfilesCreateInstanceResponse, error) {
	rsp, err := c.ProfilesCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseProfilesCreateInstanceResponse(rsp)
}

// ProfilesDeleteInstanceWithResponse request returning *ProfilesDeleteInstanceResponse
func (c *ClientWithResponses) ProfilesDeleteInstanceWithResponse(ctx context.Context, id string) (*ProfilesDeleteInstanceResponse, error) {
	rsp, err := c.ProfilesDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseProfilesDeleteInstanceResponse(rsp)
}

// ProfilesGetInstanceWithResponse request returning *ProfilesGetInstanceResponse
func (c *ClientWithResponses) ProfilesGetInstanceWithResponse(ctx context.Context, id string, params *ProfilesGetInstanceParams) (*ProfilesGetInstanceResponse, error) {
	rsp, err := c.ProfilesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseProfilesGetInstanceResponse(rsp)
}

// ProfilesBundleIdGetToOneRelatedWithResponse request returning *ProfilesBundleIdGetToOneRelatedResponse
func (c *ClientWithResponses) ProfilesBundleIdGetToOneRelatedWithResponse(ctx context.Context, id string, params *ProfilesBundleIdGetToOneRelatedParams) (*ProfilesBundleIdGetToOneRelatedResponse, error) {
	rsp, err := c.ProfilesBundleIdGetToOneRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseProfilesBundleIdGetToOneRelatedResponse(rsp)
}

// ProfilesCertificatesGetToManyRelatedWithResponse request returning *ProfilesCertificatesGetToManyRelatedResponse
func (c *ClientWithResponses) ProfilesCertificatesGetToManyRelatedWithResponse(ctx context.Context, id string, params *ProfilesCertificatesGetToManyRelatedParams) (*ProfilesCertificatesGetToManyRelatedResponse, error) {
	rsp, err := c.ProfilesCertificatesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseProfilesCertificatesGetToManyRelatedResponse(rsp)
}

// ProfilesDevicesGetToManyRelatedWithResponse request returning *ProfilesDevicesGetToManyRelatedResponse
func (c *ClientWithResponses) ProfilesDevicesGetToManyRelatedWithResponse(ctx context.Context, id string, params *ProfilesDevicesGetToManyRelatedParams) (*ProfilesDevicesGetToManyRelatedResponse, error) {
	rsp, err := c.ProfilesDevicesGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseProfilesDevicesGetToManyRelatedResponse(rsp)
}

// RoutingAppCoveragesCreateInstanceWithBodyWithResponse request with arbitrary body returning *RoutingAppCoveragesCreateInstanceResponse
func (c *ClientWithResponses) RoutingAppCoveragesCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*RoutingAppCoveragesCreateInstanceResponse, error) {
	rsp, err := c.RoutingAppCoveragesCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseRoutingAppCoveragesCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) RoutingAppCoveragesCreateInstanceWithResponse(ctx context.Context, body RoutingAppCoveragesCreateInstanceJSONRequestBody) (*RoutingAppCoveragesCreateInstanceResponse, error) {
	rsp, err := c.RoutingAppCoveragesCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseRoutingAppCoveragesCreateInstanceResponse(rsp)
}

// RoutingAppCoveragesDeleteInstanceWithResponse request returning *RoutingAppCoveragesDeleteInstanceResponse
func (c *ClientWithResponses) RoutingAppCoveragesDeleteInstanceWithResponse(ctx context.Context, id string) (*RoutingAppCoveragesDeleteInstanceResponse, error) {
	rsp, err := c.RoutingAppCoveragesDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseRoutingAppCoveragesDeleteInstanceResponse(rsp)
}

// RoutingAppCoveragesGetInstanceWithResponse request returning *RoutingAppCoveragesGetInstanceResponse
func (c *ClientWithResponses) RoutingAppCoveragesGetInstanceWithResponse(ctx context.Context, id string, params *RoutingAppCoveragesGetInstanceParams) (*RoutingAppCoveragesGetInstanceResponse, error) {
	rsp, err := c.RoutingAppCoveragesGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseRoutingAppCoveragesGetInstanceResponse(rsp)
}

// RoutingAppCoveragesUpdateInstanceWithBodyWithResponse request with arbitrary body returning *RoutingAppCoveragesUpdateInstanceResponse
func (c *ClientWithResponses) RoutingAppCoveragesUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*RoutingAppCoveragesUpdateInstanceResponse, error) {
	rsp, err := c.RoutingAppCoveragesUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseRoutingAppCoveragesUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) RoutingAppCoveragesUpdateInstanceWithResponse(ctx context.Context, id string, body RoutingAppCoveragesUpdateInstanceJSONRequestBody) (*RoutingAppCoveragesUpdateInstanceResponse, error) {
	rsp, err := c.RoutingAppCoveragesUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseRoutingAppCoveragesUpdateInstanceResponse(rsp)
}

// SalesReportsGetCollectionWithResponse request returning *SalesReportsGetCollectionResponse
func (c *ClientWithResponses) SalesReportsGetCollectionWithResponse(ctx context.Context, params *SalesReportsGetCollectionParams) (*SalesReportsGetCollectionResponse, error) {
	rsp, err := c.SalesReportsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseSalesReportsGetCollectionResponse(rsp)
}

// TerritoriesGetCollectionWithResponse request returning *TerritoriesGetCollectionResponse
func (c *ClientWithResponses) TerritoriesGetCollectionWithResponse(ctx context.Context, params *TerritoriesGetCollectionParams) (*TerritoriesGetCollectionResponse, error) {
	rsp, err := c.TerritoriesGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseTerritoriesGetCollectionResponse(rsp)
}

// UserInvitationsGetCollectionWithResponse request returning *UserInvitationsGetCollectionResponse
func (c *ClientWithResponses) UserInvitationsGetCollectionWithResponse(ctx context.Context, params *UserInvitationsGetCollectionParams) (*UserInvitationsGetCollectionResponse, error) {
	rsp, err := c.UserInvitationsGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseUserInvitationsGetCollectionResponse(rsp)
}

// UserInvitationsCreateInstanceWithBodyWithResponse request with arbitrary body returning *UserInvitationsCreateInstanceResponse
func (c *ClientWithResponses) UserInvitationsCreateInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*UserInvitationsCreateInstanceResponse, error) {
	rsp, err := c.UserInvitationsCreateInstanceWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUserInvitationsCreateInstanceResponse(rsp)
}

func (c *ClientWithResponses) UserInvitationsCreateInstanceWithResponse(ctx context.Context, body UserInvitationsCreateInstanceJSONRequestBody) (*UserInvitationsCreateInstanceResponse, error) {
	rsp, err := c.UserInvitationsCreateInstance(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseUserInvitationsCreateInstanceResponse(rsp)
}

// UserInvitationsDeleteInstanceWithResponse request returning *UserInvitationsDeleteInstanceResponse
func (c *ClientWithResponses) UserInvitationsDeleteInstanceWithResponse(ctx context.Context, id string) (*UserInvitationsDeleteInstanceResponse, error) {
	rsp, err := c.UserInvitationsDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseUserInvitationsDeleteInstanceResponse(rsp)
}

// UserInvitationsGetInstanceWithResponse request returning *UserInvitationsGetInstanceResponse
func (c *ClientWithResponses) UserInvitationsGetInstanceWithResponse(ctx context.Context, id string, params *UserInvitationsGetInstanceParams) (*UserInvitationsGetInstanceResponse, error) {
	rsp, err := c.UserInvitationsGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseUserInvitationsGetInstanceResponse(rsp)
}

// UserInvitationsVisibleAppsGetToManyRelatedWithResponse request returning *UserInvitationsVisibleAppsGetToManyRelatedResponse
func (c *ClientWithResponses) UserInvitationsVisibleAppsGetToManyRelatedWithResponse(ctx context.Context, id string, params *UserInvitationsVisibleAppsGetToManyRelatedParams) (*UserInvitationsVisibleAppsGetToManyRelatedResponse, error) {
	rsp, err := c.UserInvitationsVisibleAppsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseUserInvitationsVisibleAppsGetToManyRelatedResponse(rsp)
}

// UsersGetCollectionWithResponse request returning *UsersGetCollectionResponse
func (c *ClientWithResponses) UsersGetCollectionWithResponse(ctx context.Context, params *UsersGetCollectionParams) (*UsersGetCollectionResponse, error) {
	rsp, err := c.UsersGetCollection(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetCollectionResponse(rsp)
}

// UsersDeleteInstanceWithResponse request returning *UsersDeleteInstanceResponse
func (c *ClientWithResponses) UsersDeleteInstanceWithResponse(ctx context.Context, id string) (*UsersDeleteInstanceResponse, error) {
	rsp, err := c.UsersDeleteInstance(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseUsersDeleteInstanceResponse(rsp)
}

// UsersGetInstanceWithResponse request returning *UsersGetInstanceResponse
func (c *ClientWithResponses) UsersGetInstanceWithResponse(ctx context.Context, id string, params *UsersGetInstanceParams) (*UsersGetInstanceResponse, error) {
	rsp, err := c.UsersGetInstance(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseUsersGetInstanceResponse(rsp)
}

// UsersUpdateInstanceWithBodyWithResponse request with arbitrary body returning *UsersUpdateInstanceResponse
func (c *ClientWithResponses) UsersUpdateInstanceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersUpdateInstanceResponse, error) {
	rsp, err := c.UsersUpdateInstanceWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateInstanceResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdateInstanceWithResponse(ctx context.Context, id string, body UsersUpdateInstanceJSONRequestBody) (*UsersUpdateInstanceResponse, error) {
	rsp, err := c.UsersUpdateInstance(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdateInstanceResponse(rsp)
}

// UsersVisibleAppsDeleteToManyRelationshipWithBodyWithResponse request with arbitrary body returning *UsersVisibleAppsDeleteToManyRelationshipResponse
func (c *ClientWithResponses) UsersVisibleAppsDeleteToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersVisibleAppsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsDeleteToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsDeleteToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) UsersVisibleAppsDeleteToManyRelationshipWithResponse(ctx context.Context, id string, body UsersVisibleAppsDeleteToManyRelationshipJSONRequestBody) (*UsersVisibleAppsDeleteToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsDeleteToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsDeleteToManyRelationshipResponse(rsp)
}

// UsersVisibleAppsGetToManyRelationshipWithResponse request returning *UsersVisibleAppsGetToManyRelationshipResponse
func (c *ClientWithResponses) UsersVisibleAppsGetToManyRelationshipWithResponse(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelationshipParams) (*UsersVisibleAppsGetToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsGetToManyRelationship(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsGetToManyRelationshipResponse(rsp)
}

// UsersVisibleAppsReplaceToManyRelationshipWithBodyWithResponse request with arbitrary body returning *UsersVisibleAppsReplaceToManyRelationshipResponse
func (c *ClientWithResponses) UsersVisibleAppsReplaceToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersVisibleAppsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsReplaceToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsReplaceToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) UsersVisibleAppsReplaceToManyRelationshipWithResponse(ctx context.Context, id string, body UsersVisibleAppsReplaceToManyRelationshipJSONRequestBody) (*UsersVisibleAppsReplaceToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsReplaceToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsReplaceToManyRelationshipResponse(rsp)
}

// UsersVisibleAppsCreateToManyRelationshipWithBodyWithResponse request with arbitrary body returning *UsersVisibleAppsCreateToManyRelationshipResponse
func (c *ClientWithResponses) UsersVisibleAppsCreateToManyRelationshipWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*UsersVisibleAppsCreateToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsCreateToManyRelationshipWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsCreateToManyRelationshipResponse(rsp)
}

func (c *ClientWithResponses) UsersVisibleAppsCreateToManyRelationshipWithResponse(ctx context.Context, id string, body UsersVisibleAppsCreateToManyRelationshipJSONRequestBody) (*UsersVisibleAppsCreateToManyRelationshipResponse, error) {
	rsp, err := c.UsersVisibleAppsCreateToManyRelationship(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsCreateToManyRelationshipResponse(rsp)
}

// UsersVisibleAppsGetToManyRelatedWithResponse request returning *UsersVisibleAppsGetToManyRelatedResponse
func (c *ClientWithResponses) UsersVisibleAppsGetToManyRelatedWithResponse(ctx context.Context, id string, params *UsersVisibleAppsGetToManyRelatedParams) (*UsersVisibleAppsGetToManyRelatedResponse, error) {
	rsp, err := c.UsersVisibleAppsGetToManyRelated(ctx, id, params)
	if err != nil {
		return nil, err
	}
	return ParseUsersVisibleAppsGetToManyRelatedResponse(rsp)
}

// ParseAgeRatingDeclarationsUpdateInstanceResponse parses an HTTP response from a AgeRatingDeclarationsUpdateInstanceWithResponse call
func ParseAgeRatingDeclarationsUpdateInstanceResponse(rsp *http.Response) (*AgeRatingDeclarationsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AgeRatingDeclarationsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgeRatingDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppCategoriesGetCollectionResponse parses an HTTP response from a AppCategoriesGetCollectionWithResponse call
func ParseAppCategoriesGetCollectionResponse(rsp *http.Response) (*AppCategoriesGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppCategoriesGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppCategoriesGetInstanceResponse parses an HTTP response from a AppCategoriesGetInstanceWithResponse call
func ParseAppCategoriesGetInstanceResponse(rsp *http.Response) (*AppCategoriesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppCategoriesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppCategoriesParentGetToOneRelatedResponse parses an HTTP response from a AppCategoriesParentGetToOneRelatedWithResponse call
func ParseAppCategoriesParentGetToOneRelatedResponse(rsp *http.Response) (*AppCategoriesParentGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppCategoriesParentGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppCategoriesSubcategoriesGetToManyRelatedResponse parses an HTTP response from a AppCategoriesSubcategoriesGetToManyRelatedWithResponse call
func ParseAppCategoriesSubcategoriesGetToManyRelatedResponse(rsp *http.Response) (*AppCategoriesSubcategoriesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppCategoriesSubcategoriesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppEncryptionDeclarationsGetCollectionResponse parses an HTTP response from a AppEncryptionDeclarationsGetCollectionWithResponse call
func ParseAppEncryptionDeclarationsGetCollectionResponse(rsp *http.Response) (*AppEncryptionDeclarationsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppEncryptionDeclarationsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppEncryptionDeclarationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppEncryptionDeclarationsGetInstanceResponse parses an HTTP response from a AppEncryptionDeclarationsGetInstanceWithResponse call
func ParseAppEncryptionDeclarationsGetInstanceResponse(rsp *http.Response) (*AppEncryptionDeclarationsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppEncryptionDeclarationsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppEncryptionDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppEncryptionDeclarationsAppGetToOneRelatedResponse parses an HTTP response from a AppEncryptionDeclarationsAppGetToOneRelatedWithResponse call
func ParseAppEncryptionDeclarationsAppGetToOneRelatedResponse(rsp *http.Response) (*AppEncryptionDeclarationsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppEncryptionDeclarationsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse parses an HTTP response from a AppEncryptionDeclarationsBuildsCreateToManyRelationshipWithResponse call
func ParseAppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse(rsp *http.Response) (*AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppEncryptionDeclarationsBuildsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppInfoLocalizationsCreateInstanceResponse parses an HTTP response from a AppInfoLocalizationsCreateInstanceWithResponse call
func ParseAppInfoLocalizationsCreateInstanceResponse(rsp *http.Response) (*AppInfoLocalizationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfoLocalizationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppInfoLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppInfoLocalizationsDeleteInstanceResponse parses an HTTP response from a AppInfoLocalizationsDeleteInstanceWithResponse call
func ParseAppInfoLocalizationsDeleteInstanceResponse(rsp *http.Response) (*AppInfoLocalizationsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfoLocalizationsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppInfoLocalizationsGetInstanceResponse parses an HTTP response from a AppInfoLocalizationsGetInstanceWithResponse call
func ParseAppInfoLocalizationsGetInstanceResponse(rsp *http.Response) (*AppInfoLocalizationsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfoLocalizationsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppInfoLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfoLocalizationsUpdateInstanceResponse parses an HTTP response from a AppInfoLocalizationsUpdateInstanceWithResponse call
func ParseAppInfoLocalizationsUpdateInstanceResponse(rsp *http.Response) (*AppInfoLocalizationsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfoLocalizationsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppInfoLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppInfosGetInstanceResponse parses an HTTP response from a AppInfosGetInstanceWithResponse call
func ParseAppInfosGetInstanceResponse(rsp *http.Response) (*AppInfosGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosUpdateInstanceResponse parses an HTTP response from a AppInfosUpdateInstanceWithResponse call
func ParseAppInfosUpdateInstanceResponse(rsp *http.Response) (*AppInfosUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppInfosAppInfoLocalizationsGetToManyRelatedResponse parses an HTTP response from a AppInfosAppInfoLocalizationsGetToManyRelatedWithResponse call
func ParseAppInfosAppInfoLocalizationsGetToManyRelatedResponse(rsp *http.Response) (*AppInfosAppInfoLocalizationsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosAppInfoLocalizationsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppInfoLocalizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosPrimaryCategoryGetToOneRelatedResponse parses an HTTP response from a AppInfosPrimaryCategoryGetToOneRelatedWithResponse call
func ParseAppInfosPrimaryCategoryGetToOneRelatedResponse(rsp *http.Response) (*AppInfosPrimaryCategoryGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosPrimaryCategoryGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosPrimarySubcategoryOneGetToOneRelatedResponse parses an HTTP response from a AppInfosPrimarySubcategoryOneGetToOneRelatedWithResponse call
func ParseAppInfosPrimarySubcategoryOneGetToOneRelatedResponse(rsp *http.Response) (*AppInfosPrimarySubcategoryOneGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosPrimarySubcategoryOneGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosPrimarySubcategoryTwoGetToOneRelatedResponse parses an HTTP response from a AppInfosPrimarySubcategoryTwoGetToOneRelatedWithResponse call
func ParseAppInfosPrimarySubcategoryTwoGetToOneRelatedResponse(rsp *http.Response) (*AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosPrimarySubcategoryTwoGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosSecondaryCategoryGetToOneRelatedResponse parses an HTTP response from a AppInfosSecondaryCategoryGetToOneRelatedWithResponse call
func ParseAppInfosSecondaryCategoryGetToOneRelatedResponse(rsp *http.Response) (*AppInfosSecondaryCategoryGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosSecondaryCategoryGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosSecondarySubcategoryOneGetToOneRelatedResponse parses an HTTP response from a AppInfosSecondarySubcategoryOneGetToOneRelatedWithResponse call
func ParseAppInfosSecondarySubcategoryOneGetToOneRelatedResponse(rsp *http.Response) (*AppInfosSecondarySubcategoryOneGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosSecondarySubcategoryOneGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppInfosSecondarySubcategoryTwoGetToOneRelatedResponse parses an HTTP response from a AppInfosSecondarySubcategoryTwoGetToOneRelatedWithResponse call
func ParseAppInfosSecondarySubcategoryTwoGetToOneRelatedResponse(rsp *http.Response) (*AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppInfosSecondarySubcategoryTwoGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPreOrdersCreateInstanceResponse parses an HTTP response from a AppPreOrdersCreateInstanceWithResponse call
func ParseAppPreOrdersCreateInstanceResponse(rsp *http.Response) (*AppPreOrdersCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreOrdersCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppPreOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreOrdersDeleteInstanceResponse parses an HTTP response from a AppPreOrdersDeleteInstanceWithResponse call
func ParseAppPreOrdersDeleteInstanceResponse(rsp *http.Response) (*AppPreOrdersDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreOrdersDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreOrdersGetInstanceResponse parses an HTTP response from a AppPreOrdersGetInstanceWithResponse call
func ParseAppPreOrdersGetInstanceResponse(rsp *http.Response) (*AppPreOrdersGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreOrdersGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPreOrdersUpdateInstanceResponse parses an HTTP response from a AppPreOrdersUpdateInstanceWithResponse call
func ParseAppPreOrdersUpdateInstanceResponse(rsp *http.Response) (*AppPreOrdersUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreOrdersUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreviewSetsCreateInstanceResponse parses an HTTP response from a AppPreviewSetsCreateInstanceWithResponse call
func ParseAppPreviewSetsCreateInstanceResponse(rsp *http.Response) (*AppPreviewSetsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewSetsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppPreviewSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreviewSetsDeleteInstanceResponse parses an HTTP response from a AppPreviewSetsDeleteInstanceWithResponse call
func ParseAppPreviewSetsDeleteInstanceResponse(rsp *http.Response) (*AppPreviewSetsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewSetsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreviewSetsGetInstanceResponse parses an HTTP response from a AppPreviewSetsGetInstanceWithResponse call
func ParseAppPreviewSetsGetInstanceResponse(rsp *http.Response) (*AppPreviewSetsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewSetsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreviewSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPreviewSetsAppPreviewsGetToManyRelatedResponse parses an HTTP response from a AppPreviewSetsAppPreviewsGetToManyRelatedWithResponse call
func ParseAppPreviewSetsAppPreviewsGetToManyRelatedResponse(rsp *http.Response) (*AppPreviewSetsAppPreviewsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewSetsAppPreviewsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreviewsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPreviewSetsAppPreviewsGetToManyRelationshipResponse parses an HTTP response from a AppPreviewSetsAppPreviewsGetToManyRelationshipWithResponse call
func ParseAppPreviewSetsAppPreviewsGetToManyRelationshipResponse(rsp *http.Response) (*AppPreviewSetsAppPreviewsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewSetsAppPreviewsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreviewSetAppPreviewsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse parses an HTTP response from a AppPreviewSetsAppPreviewsReplaceToManyRelationshipWithResponse call
func ParseAppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse(rsp *http.Response) (*AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewSetsAppPreviewsReplaceToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreviewsCreateInstanceResponse parses an HTTP response from a AppPreviewsCreateInstanceWithResponse call
func ParseAppPreviewsCreateInstanceResponse(rsp *http.Response) (*AppPreviewsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreviewsDeleteInstanceResponse parses an HTTP response from a AppPreviewsDeleteInstanceWithResponse call
func ParseAppPreviewsDeleteInstanceResponse(rsp *http.Response) (*AppPreviewsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPreviewsGetInstanceResponse parses an HTTP response from a AppPreviewsGetInstanceWithResponse call
func ParseAppPreviewsGetInstanceResponse(rsp *http.Response) (*AppPreviewsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPreviewsUpdateInstanceResponse parses an HTTP response from a AppPreviewsUpdateInstanceWithResponse call
func ParseAppPreviewsUpdateInstanceResponse(rsp *http.Response) (*AppPreviewsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPreviewsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreviewResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppPricePointsGetCollectionResponse parses an HTTP response from a AppPricePointsGetCollectionWithResponse call
func ParseAppPricePointsGetCollectionResponse(rsp *http.Response) (*AppPricePointsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPricePointsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPricePointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppPricePointsGetInstanceResponse parses an HTTP response from a AppPricePointsGetInstanceWithResponse call
func ParseAppPricePointsGetInstanceResponse(rsp *http.Response) (*AppPricePointsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPricePointsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPricePointResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPricePointsTerritoryGetToOneRelatedResponse parses an HTTP response from a AppPricePointsTerritoryGetToOneRelatedWithResponse call
func ParseAppPricePointsTerritoryGetToOneRelatedResponse(rsp *http.Response) (*AppPricePointsTerritoryGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPricePointsTerritoryGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TerritoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPriceTiersGetCollectionResponse parses an HTTP response from a AppPriceTiersGetCollectionWithResponse call
func ParseAppPriceTiersGetCollectionResponse(rsp *http.Response) (*AppPriceTiersGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPriceTiersGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPriceTiersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppPriceTiersGetInstanceResponse parses an HTTP response from a AppPriceTiersGetInstanceWithResponse call
func ParseAppPriceTiersGetInstanceResponse(rsp *http.Response) (*AppPriceTiersGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPriceTiersGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPriceTierResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPriceTiersPricePointsGetToManyRelatedResponse parses an HTTP response from a AppPriceTiersPricePointsGetToManyRelatedWithResponse call
func ParseAppPriceTiersPricePointsGetToManyRelatedResponse(rsp *http.Response) (*AppPriceTiersPricePointsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPriceTiersPricePointsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPricePointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppPricesGetInstanceResponse parses an HTTP response from a AppPricesGetInstanceWithResponse call
func ParseAppPricesGetInstanceResponse(rsp *http.Response) (*AppPricesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppPricesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPriceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppScreenshotSetsCreateInstanceResponse parses an HTTP response from a AppScreenshotSetsCreateInstanceWithResponse call
func ParseAppScreenshotSetsCreateInstanceResponse(rsp *http.Response) (*AppScreenshotSetsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotSetsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppScreenshotSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppScreenshotSetsDeleteInstanceResponse parses an HTTP response from a AppScreenshotSetsDeleteInstanceWithResponse call
func ParseAppScreenshotSetsDeleteInstanceResponse(rsp *http.Response) (*AppScreenshotSetsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotSetsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppScreenshotSetsGetInstanceResponse parses an HTTP response from a AppScreenshotSetsGetInstanceWithResponse call
func ParseAppScreenshotSetsGetInstanceResponse(rsp *http.Response) (*AppScreenshotSetsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotSetsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppScreenshotSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppScreenshotSetsAppScreenshotsGetToManyRelatedResponse parses an HTTP response from a AppScreenshotSetsAppScreenshotsGetToManyRelatedWithResponse call
func ParseAppScreenshotSetsAppScreenshotsGetToManyRelatedResponse(rsp *http.Response) (*AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotSetsAppScreenshotsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppScreenshotsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse parses an HTTP response from a AppScreenshotSetsAppScreenshotsGetToManyRelationshipWithResponse call
func ParseAppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse(rsp *http.Response) (*AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotSetsAppScreenshotsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppScreenshotSetAppScreenshotsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse parses an HTTP response from a AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipWithResponse call
func ParseAppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse(rsp *http.Response) (*AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotSetsAppScreenshotsReplaceToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppScreenshotsCreateInstanceResponse parses an HTTP response from a AppScreenshotsCreateInstanceWithResponse call
func ParseAppScreenshotsCreateInstanceResponse(rsp *http.Response) (*AppScreenshotsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppScreenshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppScreenshotsDeleteInstanceResponse parses an HTTP response from a AppScreenshotsDeleteInstanceWithResponse call
func ParseAppScreenshotsDeleteInstanceResponse(rsp *http.Response) (*AppScreenshotsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppScreenshotsGetInstanceResponse parses an HTTP response from a AppScreenshotsGetInstanceWithResponse call
func ParseAppScreenshotsGetInstanceResponse(rsp *http.Response) (*AppScreenshotsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppScreenshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppScreenshotsUpdateInstanceResponse parses an HTTP response from a AppScreenshotsUpdateInstanceWithResponse call
func ParseAppScreenshotsUpdateInstanceResponse(rsp *http.Response) (*AppScreenshotsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppScreenshotsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppScreenshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewAttachmentsCreateInstanceResponse parses an HTTP response from a AppStoreReviewAttachmentsCreateInstanceWithResponse call
func ParseAppStoreReviewAttachmentsCreateInstanceResponse(rsp *http.Response) (*AppStoreReviewAttachmentsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewAttachmentsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppStoreReviewAttachmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewAttachmentsDeleteInstanceResponse parses an HTTP response from a AppStoreReviewAttachmentsDeleteInstanceWithResponse call
func ParseAppStoreReviewAttachmentsDeleteInstanceResponse(rsp *http.Response) (*AppStoreReviewAttachmentsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewAttachmentsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewAttachmentsGetInstanceResponse parses an HTTP response from a AppStoreReviewAttachmentsGetInstanceWithResponse call
func ParseAppStoreReviewAttachmentsGetInstanceResponse(rsp *http.Response) (*AppStoreReviewAttachmentsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewAttachmentsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreReviewAttachmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewAttachmentsUpdateInstanceResponse parses an HTTP response from a AppStoreReviewAttachmentsUpdateInstanceWithResponse call
func ParseAppStoreReviewAttachmentsUpdateInstanceResponse(rsp *http.Response) (*AppStoreReviewAttachmentsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewAttachmentsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreReviewAttachmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewDetailsCreateInstanceResponse parses an HTTP response from a AppStoreReviewDetailsCreateInstanceWithResponse call
func ParseAppStoreReviewDetailsCreateInstanceResponse(rsp *http.Response) (*AppStoreReviewDetailsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewDetailsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppStoreReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewDetailsGetInstanceResponse parses an HTTP response from a AppStoreReviewDetailsGetInstanceWithResponse call
func ParseAppStoreReviewDetailsGetInstanceResponse(rsp *http.Response) (*AppStoreReviewDetailsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewDetailsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewDetailsUpdateInstanceResponse parses an HTTP response from a AppStoreReviewDetailsUpdateInstanceWithResponse call
func ParseAppStoreReviewDetailsUpdateInstanceResponse(rsp *http.Response) (*AppStoreReviewDetailsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewDetailsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse parses an HTTP response from a AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedWithResponse call
func ParseAppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse(rsp *http.Response) (*AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreReviewAttachmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionLocalizationsCreateInstanceResponse parses an HTTP response from a AppStoreVersionLocalizationsCreateInstanceWithResponse call
func ParseAppStoreVersionLocalizationsCreateInstanceResponse(rsp *http.Response) (*AppStoreVersionLocalizationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionLocalizationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppStoreVersionLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionLocalizationsDeleteInstanceResponse parses an HTTP response from a AppStoreVersionLocalizationsDeleteInstanceWithResponse call
func ParseAppStoreVersionLocalizationsDeleteInstanceResponse(rsp *http.Response) (*AppStoreVersionLocalizationsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionLocalizationsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionLocalizationsGetInstanceResponse parses an HTTP response from a AppStoreVersionLocalizationsGetInstanceWithResponse call
func ParseAppStoreVersionLocalizationsGetInstanceResponse(rsp *http.Response) (*AppStoreVersionLocalizationsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionLocalizationsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionLocalizationsUpdateInstanceResponse parses an HTTP response from a AppStoreVersionLocalizationsUpdateInstanceWithResponse call
func ParseAppStoreVersionLocalizationsUpdateInstanceResponse(rsp *http.Response) (*AppStoreVersionLocalizationsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionLocalizationsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse parses an HTTP response from a AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedWithResponse call
func ParseAppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse(rsp *http.Response) (*AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreviewSetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse parses an HTTP response from a AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedWithResponse call
func ParseAppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse(rsp *http.Response) (*AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppScreenshotSetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionPhasedReleasesCreateInstanceResponse parses an HTTP response from a AppStoreVersionPhasedReleasesCreateInstanceWithResponse call
func ParseAppStoreVersionPhasedReleasesCreateInstanceResponse(rsp *http.Response) (*AppStoreVersionPhasedReleasesCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionPhasedReleasesCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppStoreVersionPhasedReleaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionPhasedReleasesDeleteInstanceResponse parses an HTTP response from a AppStoreVersionPhasedReleasesDeleteInstanceWithResponse call
func ParseAppStoreVersionPhasedReleasesDeleteInstanceResponse(rsp *http.Response) (*AppStoreVersionPhasedReleasesDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionPhasedReleasesDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionPhasedReleasesUpdateInstanceResponse parses an HTTP response from a AppStoreVersionPhasedReleasesUpdateInstanceWithResponse call
func ParseAppStoreVersionPhasedReleasesUpdateInstanceResponse(rsp *http.Response) (*AppStoreVersionPhasedReleasesUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionPhasedReleasesUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionPhasedReleaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionSubmissionsCreateInstanceResponse parses an HTTP response from a AppStoreVersionSubmissionsCreateInstanceWithResponse call
func ParseAppStoreVersionSubmissionsCreateInstanceResponse(rsp *http.Response) (*AppStoreVersionSubmissionsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionSubmissionsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppStoreVersionSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionSubmissionsDeleteInstanceResponse parses an HTTP response from a AppStoreVersionSubmissionsDeleteInstanceWithResponse call
func ParseAppStoreVersionSubmissionsDeleteInstanceResponse(rsp *http.Response) (*AppStoreVersionSubmissionsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionSubmissionsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsCreateInstanceResponse parses an HTTP response from a AppStoreVersionsCreateInstanceWithResponse call
func ParseAppStoreVersionsCreateInstanceResponse(rsp *http.Response) (*AppStoreVersionsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppStoreVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsDeleteInstanceResponse parses an HTTP response from a AppStoreVersionsDeleteInstanceWithResponse call
func ParseAppStoreVersionsDeleteInstanceResponse(rsp *http.Response) (*AppStoreVersionsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsGetInstanceResponse parses an HTTP response from a AppStoreVersionsGetInstanceWithResponse call
func ParseAppStoreVersionsGetInstanceResponse(rsp *http.Response) (*AppStoreVersionsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsUpdateInstanceResponse parses an HTTP response from a AppStoreVersionsUpdateInstanceWithResponse call
func ParseAppStoreVersionsUpdateInstanceResponse(rsp *http.Response) (*AppStoreVersionsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsAgeRatingDeclarationGetToOneRelatedWithResponse call
func ParseAppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsAgeRatingDeclarationGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgeRatingDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsAppStoreReviewDetailGetToOneRelatedWithResponse call
func ParseAppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsAppStoreReviewDetailGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse parses an HTTP response from a AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedWithResponse call
func ParseAppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse(rsp *http.Response) (*AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionLocalizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedWithResponse call
func ParseAppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionPhasedReleaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedWithResponse call
func ParseAppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsBuildGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsBuildGetToOneRelatedWithResponse call
func ParseAppStoreVersionsBuildGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsBuildGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsBuildGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsIdfaDeclarationGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsIdfaDeclarationGetToOneRelatedWithResponse call
func ParseAppStoreVersionsIdfaDeclarationGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsIdfaDeclarationGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdfaDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsBuildGetToOneRelationshipResponse parses an HTTP response from a AppStoreVersionsBuildGetToOneRelationshipWithResponse call
func ParseAppStoreVersionsBuildGetToOneRelationshipResponse(rsp *http.Response) (*AppStoreVersionsBuildGetToOneRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsBuildGetToOneRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionBuildLinkageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsBuildUpdateToOneRelationshipResponse parses an HTTP response from a AppStoreVersionsBuildUpdateToOneRelationshipWithResponse call
func ParseAppStoreVersionsBuildUpdateToOneRelationshipResponse(rsp *http.Response) (*AppStoreVersionsBuildUpdateToOneRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsBuildUpdateToOneRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse parses an HTTP response from a AppStoreVersionsRoutingAppCoverageGetToOneRelatedWithResponse call
func ParseAppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse(rsp *http.Response) (*AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppStoreVersionsRoutingAppCoverageGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoutingAppCoverageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsGetCollectionResponse parses an HTTP response from a AppsGetCollectionWithResponse call
func ParseAppsGetCollectionResponse(rsp *http.Response) (*AppsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppsGetInstanceResponse parses an HTTP response from a AppsGetInstanceWithResponse call
func ParseAppsGetInstanceResponse(rsp *http.Response) (*AppsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsUpdateInstanceResponse parses an HTTP response from a AppsUpdateInstanceWithResponse call
func ParseAppsUpdateInstanceResponse(rsp *http.Response) (*AppsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAppsAppInfosGetToManyRelatedResponse parses an HTTP response from a AppsAppInfosGetToManyRelatedWithResponse call
func ParseAppsAppInfosGetToManyRelatedResponse(rsp *http.Response) (*AppsAppInfosGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsAppInfosGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppInfosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsAppStoreVersionsGetToManyRelatedResponse parses an HTTP response from a AppsAppStoreVersionsGetToManyRelatedWithResponse call
func ParseAppsAppStoreVersionsGetToManyRelatedResponse(rsp *http.Response) (*AppsAppStoreVersionsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsAppStoreVersionsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsAvailableTerritoriesGetToManyRelatedResponse parses an HTTP response from a AppsAvailableTerritoriesGetToManyRelatedWithResponse call
func ParseAppsAvailableTerritoriesGetToManyRelatedResponse(rsp *http.Response) (*AppsAvailableTerritoriesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsAvailableTerritoriesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TerritoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsBetaAppLocalizationsGetToManyRelatedResponse parses an HTTP response from a AppsBetaAppLocalizationsGetToManyRelatedWithResponse call
func ParseAppsBetaAppLocalizationsGetToManyRelatedResponse(rsp *http.Response) (*AppsBetaAppLocalizationsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsBetaAppLocalizationsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppLocalizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsBetaAppReviewDetailGetToOneRelatedResponse parses an HTTP response from a AppsBetaAppReviewDetailGetToOneRelatedWithResponse call
func ParseAppsBetaAppReviewDetailGetToOneRelatedResponse(rsp *http.Response) (*AppsBetaAppReviewDetailGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsBetaAppReviewDetailGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsBetaGroupsGetToManyRelatedResponse parses an HTTP response from a AppsBetaGroupsGetToManyRelatedWithResponse call
func ParseAppsBetaGroupsGetToManyRelatedResponse(rsp *http.Response) (*AppsBetaGroupsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsBetaGroupsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsBetaLicenseAgreementGetToOneRelatedResponse parses an HTTP response from a AppsBetaLicenseAgreementGetToOneRelatedWithResponse call
func ParseAppsBetaLicenseAgreementGetToOneRelatedResponse(rsp *http.Response) (*AppsBetaLicenseAgreementGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsBetaLicenseAgreementGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsBuildsGetToManyRelatedResponse parses an HTTP response from a AppsBuildsGetToManyRelatedWithResponse call
func ParseAppsBuildsGetToManyRelatedResponse(rsp *http.Response) (*AppsBuildsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsBuildsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsEndUserLicenseAgreementGetToOneRelatedResponse parses an HTTP response from a AppsEndUserLicenseAgreementGetToOneRelatedWithResponse call
func ParseAppsEndUserLicenseAgreementGetToOneRelatedResponse(rsp *http.Response) (*AppsEndUserLicenseAgreementGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsEndUserLicenseAgreementGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUserLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsGameCenterEnabledVersionsGetToManyRelatedResponse parses an HTTP response from a AppsGameCenterEnabledVersionsGetToManyRelatedWithResponse call
func ParseAppsGameCenterEnabledVersionsGetToManyRelatedResponse(rsp *http.Response) (*AppsGameCenterEnabledVersionsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsGameCenterEnabledVersionsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameCenterEnabledVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsInAppPurchasesGetToManyRelatedResponse parses an HTTP response from a AppsInAppPurchasesGetToManyRelatedWithResponse call
func ParseAppsInAppPurchasesGetToManyRelatedResponse(rsp *http.Response) (*AppsInAppPurchasesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsInAppPurchasesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InAppPurchasesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsPerfPowerMetricsGetToManyRelatedResponse parses an HTTP response from a AppsPerfPowerMetricsGetToManyRelatedWithResponse call
func ParseAppsPerfPowerMetricsGetToManyRelatedResponse(rsp *http.Response) (*AppsPerfPowerMetricsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsPerfPowerMetricsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PerfPowerMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsPreOrderGetToOneRelatedResponse parses an HTTP response from a AppsPreOrderGetToOneRelatedWithResponse call
func ParseAppsPreOrderGetToOneRelatedResponse(rsp *http.Response) (*AppsPreOrderGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsPreOrderGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPreOrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsPreReleaseVersionsGetToManyRelatedResponse parses an HTTP response from a AppsPreReleaseVersionsGetToManyRelatedWithResponse call
func ParseAppsPreReleaseVersionsGetToManyRelatedResponse(rsp *http.Response) (*AppsPreReleaseVersionsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsPreReleaseVersionsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreReleaseVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsPricesGetToManyRelatedResponse parses an HTTP response from a AppsPricesGetToManyRelatedWithResponse call
func ParseAppsPricesGetToManyRelatedResponse(rsp *http.Response) (*AppsPricesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsPricesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppPricesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsBetaTestersDeleteToManyRelationshipResponse parses an HTTP response from a AppsBetaTestersDeleteToManyRelationshipWithResponse call
func ParseAppsBetaTestersDeleteToManyRelationshipResponse(rsp *http.Response) (*AppsBetaTestersDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AppsBetaTestersDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaAppLocalizationsGetCollectionResponse parses an HTTP response from a BetaAppLocalizationsGetCollectionWithResponse call
func ParseBetaAppLocalizationsGetCollectionResponse(rsp *http.Response) (*BetaAppLocalizationsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppLocalizationsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppLocalizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaAppLocalizationsCreateInstanceResponse parses an HTTP response from a BetaAppLocalizationsCreateInstanceWithResponse call
func ParseBetaAppLocalizationsCreateInstanceResponse(rsp *http.Response) (*BetaAppLocalizationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppLocalizationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BetaAppLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaAppLocalizationsDeleteInstanceResponse parses an HTTP response from a BetaAppLocalizationsDeleteInstanceWithResponse call
func ParseBetaAppLocalizationsDeleteInstanceResponse(rsp *http.Response) (*BetaAppLocalizationsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppLocalizationsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaAppLocalizationsGetInstanceResponse parses an HTTP response from a BetaAppLocalizationsGetInstanceWithResponse call
func ParseBetaAppLocalizationsGetInstanceResponse(rsp *http.Response) (*BetaAppLocalizationsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppLocalizationsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaAppLocalizationsUpdateInstanceResponse parses an HTTP response from a BetaAppLocalizationsUpdateInstanceWithResponse call
func ParseBetaAppLocalizationsUpdateInstanceResponse(rsp *http.Response) (*BetaAppLocalizationsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppLocalizationsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaAppLocalizationsAppGetToOneRelatedResponse parses an HTTP response from a BetaAppLocalizationsAppGetToOneRelatedWithResponse call
func ParseBetaAppLocalizationsAppGetToOneRelatedResponse(rsp *http.Response) (*BetaAppLocalizationsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppLocalizationsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewDetailsGetCollectionResponse parses an HTTP response from a BetaAppReviewDetailsGetCollectionWithResponse call
func ParseBetaAppReviewDetailsGetCollectionResponse(rsp *http.Response) (*BetaAppReviewDetailsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewDetailsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewDetailsGetInstanceResponse parses an HTTP response from a BetaAppReviewDetailsGetInstanceWithResponse call
func ParseBetaAppReviewDetailsGetInstanceResponse(rsp *http.Response) (*BetaAppReviewDetailsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewDetailsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewDetailsUpdateInstanceResponse parses an HTTP response from a BetaAppReviewDetailsUpdateInstanceWithResponse call
func ParseBetaAppReviewDetailsUpdateInstanceResponse(rsp *http.Response) (*BetaAppReviewDetailsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewDetailsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewDetailsAppGetToOneRelatedResponse parses an HTTP response from a BetaAppReviewDetailsAppGetToOneRelatedWithResponse call
func ParseBetaAppReviewDetailsAppGetToOneRelatedResponse(rsp *http.Response) (*BetaAppReviewDetailsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewDetailsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewSubmissionsGetCollectionResponse parses an HTTP response from a BetaAppReviewSubmissionsGetCollectionWithResponse call
func ParseBetaAppReviewSubmissionsGetCollectionResponse(rsp *http.Response) (*BetaAppReviewSubmissionsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewSubmissionsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewSubmissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewSubmissionsCreateInstanceResponse parses an HTTP response from a BetaAppReviewSubmissionsCreateInstanceWithResponse call
func ParseBetaAppReviewSubmissionsCreateInstanceResponse(rsp *http.Response) (*BetaAppReviewSubmissionsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewSubmissionsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BetaAppReviewSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewSubmissionsGetInstanceResponse parses an HTTP response from a BetaAppReviewSubmissionsGetInstanceWithResponse call
func ParseBetaAppReviewSubmissionsGetInstanceResponse(rsp *http.Response) (*BetaAppReviewSubmissionsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewSubmissionsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaAppReviewSubmissionsBuildGetToOneRelatedResponse parses an HTTP response from a BetaAppReviewSubmissionsBuildGetToOneRelatedWithResponse call
func ParseBetaAppReviewSubmissionsBuildGetToOneRelatedResponse(rsp *http.Response) (*BetaAppReviewSubmissionsBuildGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaAppReviewSubmissionsBuildGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaBuildLocalizationsGetCollectionResponse parses an HTTP response from a BetaBuildLocalizationsGetCollectionWithResponse call
func ParseBetaBuildLocalizationsGetCollectionResponse(rsp *http.Response) (*BetaBuildLocalizationsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaBuildLocalizationsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaBuildLocalizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaBuildLocalizationsCreateInstanceResponse parses an HTTP response from a BetaBuildLocalizationsCreateInstanceWithResponse call
func ParseBetaBuildLocalizationsCreateInstanceResponse(rsp *http.Response) (*BetaBuildLocalizationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaBuildLocalizationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BetaBuildLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaBuildLocalizationsDeleteInstanceResponse parses an HTTP response from a BetaBuildLocalizationsDeleteInstanceWithResponse call
func ParseBetaBuildLocalizationsDeleteInstanceResponse(rsp *http.Response) (*BetaBuildLocalizationsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaBuildLocalizationsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaBuildLocalizationsGetInstanceResponse parses an HTTP response from a BetaBuildLocalizationsGetInstanceWithResponse call
func ParseBetaBuildLocalizationsGetInstanceResponse(rsp *http.Response) (*BetaBuildLocalizationsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaBuildLocalizationsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaBuildLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaBuildLocalizationsUpdateInstanceResponse parses an HTTP response from a BetaBuildLocalizationsUpdateInstanceWithResponse call
func ParseBetaBuildLocalizationsUpdateInstanceResponse(rsp *http.Response) (*BetaBuildLocalizationsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaBuildLocalizationsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaBuildLocalizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaBuildLocalizationsBuildGetToOneRelatedResponse parses an HTTP response from a BetaBuildLocalizationsBuildGetToOneRelatedWithResponse call
func ParseBetaBuildLocalizationsBuildGetToOneRelatedResponse(rsp *http.Response) (*BetaBuildLocalizationsBuildGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaBuildLocalizationsBuildGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsGetCollectionResponse parses an HTTP response from a BetaGroupsGetCollectionWithResponse call
func ParseBetaGroupsGetCollectionResponse(rsp *http.Response) (*BetaGroupsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaGroupsCreateInstanceResponse parses an HTTP response from a BetaGroupsCreateInstanceWithResponse call
func ParseBetaGroupsCreateInstanceResponse(rsp *http.Response) (*BetaGroupsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BetaGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaGroupsDeleteInstanceResponse parses an HTTP response from a BetaGroupsDeleteInstanceWithResponse call
func ParseBetaGroupsDeleteInstanceResponse(rsp *http.Response) (*BetaGroupsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaGroupsGetInstanceResponse parses an HTTP response from a BetaGroupsGetInstanceWithResponse call
func ParseBetaGroupsGetInstanceResponse(rsp *http.Response) (*BetaGroupsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsUpdateInstanceResponse parses an HTTP response from a BetaGroupsUpdateInstanceWithResponse call
func ParseBetaGroupsUpdateInstanceResponse(rsp *http.Response) (*BetaGroupsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaGroupsAppGetToOneRelatedResponse parses an HTTP response from a BetaGroupsAppGetToOneRelatedWithResponse call
func ParseBetaGroupsAppGetToOneRelatedResponse(rsp *http.Response) (*BetaGroupsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBetaTestersGetToManyRelatedResponse parses an HTTP response from a BetaGroupsBetaTestersGetToManyRelatedWithResponse call
func ParseBetaGroupsBetaTestersGetToManyRelatedResponse(rsp *http.Response) (*BetaGroupsBetaTestersGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBetaTestersGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTestersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBuildsGetToManyRelatedResponse parses an HTTP response from a BetaGroupsBuildsGetToManyRelatedWithResponse call
func ParseBetaGroupsBuildsGetToManyRelatedResponse(rsp *http.Response) (*BetaGroupsBuildsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBuildsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBetaTestersDeleteToManyRelationshipResponse parses an HTTP response from a BetaGroupsBetaTestersDeleteToManyRelationshipWithResponse call
func ParseBetaGroupsBetaTestersDeleteToManyRelationshipResponse(rsp *http.Response) (*BetaGroupsBetaTestersDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBetaTestersDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBetaTestersGetToManyRelationshipResponse parses an HTTP response from a BetaGroupsBetaTestersGetToManyRelationshipWithResponse call
func ParseBetaGroupsBetaTestersGetToManyRelationshipResponse(rsp *http.Response) (*BetaGroupsBetaTestersGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBetaTestersGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupBetaTestersLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBetaTestersCreateToManyRelationshipResponse parses an HTTP response from a BetaGroupsBetaTestersCreateToManyRelationshipWithResponse call
func ParseBetaGroupsBetaTestersCreateToManyRelationshipResponse(rsp *http.Response) (*BetaGroupsBetaTestersCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBetaTestersCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBuildsDeleteToManyRelationshipResponse parses an HTTP response from a BetaGroupsBuildsDeleteToManyRelationshipWithResponse call
func ParseBetaGroupsBuildsDeleteToManyRelationshipResponse(rsp *http.Response) (*BetaGroupsBuildsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBuildsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBuildsGetToManyRelationshipResponse parses an HTTP response from a BetaGroupsBuildsGetToManyRelationshipWithResponse call
func ParseBetaGroupsBuildsGetToManyRelationshipResponse(rsp *http.Response) (*BetaGroupsBuildsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBuildsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupBuildsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaGroupsBuildsCreateToManyRelationshipResponse parses an HTTP response from a BetaGroupsBuildsCreateToManyRelationshipWithResponse call
func ParseBetaGroupsBuildsCreateToManyRelationshipResponse(rsp *http.Response) (*BetaGroupsBuildsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaGroupsBuildsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaLicenseAgreementsGetCollectionResponse parses an HTTP response from a BetaLicenseAgreementsGetCollectionWithResponse call
func ParseBetaLicenseAgreementsGetCollectionResponse(rsp *http.Response) (*BetaLicenseAgreementsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaLicenseAgreementsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaLicenseAgreementsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaLicenseAgreementsGetInstanceResponse parses an HTTP response from a BetaLicenseAgreementsGetInstanceWithResponse call
func ParseBetaLicenseAgreementsGetInstanceResponse(rsp *http.Response) (*BetaLicenseAgreementsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaLicenseAgreementsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaLicenseAgreementsUpdateInstanceResponse parses an HTTP response from a BetaLicenseAgreementsUpdateInstanceWithResponse call
func ParseBetaLicenseAgreementsUpdateInstanceResponse(rsp *http.Response) (*BetaLicenseAgreementsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaLicenseAgreementsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaLicenseAgreementsAppGetToOneRelatedResponse parses an HTTP response from a BetaLicenseAgreementsAppGetToOneRelatedWithResponse call
func ParseBetaLicenseAgreementsAppGetToOneRelatedResponse(rsp *http.Response) (*BetaLicenseAgreementsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaLicenseAgreementsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTesterInvitationsCreateInstanceResponse parses an HTTP response from a BetaTesterInvitationsCreateInstanceWithResponse call
func ParseBetaTesterInvitationsCreateInstanceResponse(rsp *http.Response) (*BetaTesterInvitationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTesterInvitationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BetaTesterInvitationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersGetCollectionResponse parses an HTTP response from a BetaTestersGetCollectionWithResponse call
func ParseBetaTestersGetCollectionResponse(rsp *http.Response) (*BetaTestersGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTestersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBetaTestersCreateInstanceResponse parses an HTTP response from a BetaTestersCreateInstanceWithResponse call
func ParseBetaTestersCreateInstanceResponse(rsp *http.Response) (*BetaTestersCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BetaTesterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersDeleteInstanceResponse parses an HTTP response from a BetaTestersDeleteInstanceWithResponse call
func ParseBetaTestersDeleteInstanceResponse(rsp *http.Response) (*BetaTestersDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersGetInstanceResponse parses an HTTP response from a BetaTestersGetInstanceWithResponse call
func ParseBetaTestersGetInstanceResponse(rsp *http.Response) (*BetaTestersGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTesterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersAppsGetToManyRelatedResponse parses an HTTP response from a BetaTestersAppsGetToManyRelatedWithResponse call
func ParseBetaTestersAppsGetToManyRelatedResponse(rsp *http.Response) (*BetaTestersAppsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersAppsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersBetaGroupsGetToManyRelatedResponse parses an HTTP response from a BetaTestersBetaGroupsGetToManyRelatedWithResponse call
func ParseBetaTestersBetaGroupsGetToManyRelatedResponse(rsp *http.Response) (*BetaTestersBetaGroupsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBetaGroupsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersBuildsGetToManyRelatedResponse parses an HTTP response from a BetaTestersBuildsGetToManyRelatedWithResponse call
func ParseBetaTestersBuildsGetToManyRelatedResponse(rsp *http.Response) (*BetaTestersBuildsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBuildsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersAppsDeleteToManyRelationshipResponse parses an HTTP response from a BetaTestersAppsDeleteToManyRelationshipWithResponse call
func ParseBetaTestersAppsDeleteToManyRelationshipResponse(rsp *http.Response) (*BetaTestersAppsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersAppsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersAppsGetToManyRelationshipResponse parses an HTTP response from a BetaTestersAppsGetToManyRelationshipWithResponse call
func ParseBetaTestersAppsGetToManyRelationshipResponse(rsp *http.Response) (*BetaTestersAppsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersAppsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTesterAppsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersBetaGroupsDeleteToManyRelationshipResponse parses an HTTP response from a BetaTestersBetaGroupsDeleteToManyRelationshipWithResponse call
func ParseBetaTestersBetaGroupsDeleteToManyRelationshipResponse(rsp *http.Response) (*BetaTestersBetaGroupsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBetaGroupsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersBetaGroupsGetToManyRelationshipResponse parses an HTTP response from a BetaTestersBetaGroupsGetToManyRelationshipWithResponse call
func ParseBetaTestersBetaGroupsGetToManyRelationshipResponse(rsp *http.Response) (*BetaTestersBetaGroupsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBetaGroupsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTesterBetaGroupsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersBetaGroupsCreateToManyRelationshipResponse parses an HTTP response from a BetaTestersBetaGroupsCreateToManyRelationshipWithResponse call
func ParseBetaTestersBetaGroupsCreateToManyRelationshipResponse(rsp *http.Response) (*BetaTestersBetaGroupsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBetaGroupsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersBuildsDeleteToManyRelationshipResponse parses an HTTP response from a BetaTestersBuildsDeleteToManyRelationshipWithResponse call
func ParseBetaTestersBuildsDeleteToManyRelationshipResponse(rsp *http.Response) (*BetaTestersBuildsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBuildsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBetaTestersBuildsGetToManyRelationshipResponse parses an HTTP response from a BetaTestersBuildsGetToManyRelationshipWithResponse call
func ParseBetaTestersBuildsGetToManyRelationshipResponse(rsp *http.Response) (*BetaTestersBuildsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBuildsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTesterBuildsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBetaTestersBuildsCreateToManyRelationshipResponse parses an HTTP response from a BetaTestersBuildsCreateToManyRelationshipWithResponse call
func ParseBetaTestersBuildsCreateToManyRelationshipResponse(rsp *http.Response) (*BetaTestersBuildsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BetaTestersBuildsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildBetaDetailsGetCollectionResponse parses an HTTP response from a BuildBetaDetailsGetCollectionWithResponse call
func ParseBuildBetaDetailsGetCollectionResponse(rsp *http.Response) (*BuildBetaDetailsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildBetaDetailsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildBetaDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBuildBetaDetailsGetInstanceResponse parses an HTTP response from a BuildBetaDetailsGetInstanceWithResponse call
func ParseBuildBetaDetailsGetInstanceResponse(rsp *http.Response) (*BuildBetaDetailsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildBetaDetailsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildBetaDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildBetaDetailsUpdateInstanceResponse parses an HTTP response from a BuildBetaDetailsUpdateInstanceWithResponse call
func ParseBuildBetaDetailsUpdateInstanceResponse(rsp *http.Response) (*BuildBetaDetailsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildBetaDetailsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildBetaDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildBetaDetailsBuildGetToOneRelatedResponse parses an HTTP response from a BuildBetaDetailsBuildGetToOneRelatedWithResponse call
func ParseBuildBetaDetailsBuildGetToOneRelatedResponse(rsp *http.Response) (*BuildBetaDetailsBuildGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildBetaDetailsBuildGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildBetaNotificationsCreateInstanceResponse parses an HTTP response from a BuildBetaNotificationsCreateInstanceWithResponse call
func ParseBuildBetaNotificationsCreateInstanceResponse(rsp *http.Response) (*BuildBetaNotificationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildBetaNotificationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BuildBetaNotificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildsGetCollectionResponse parses an HTTP response from a BuildsGetCollectionWithResponse call
func ParseBuildsGetCollectionResponse(rsp *http.Response) (*BuildsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBuildsGetInstanceResponse parses an HTTP response from a BuildsGetInstanceWithResponse call
func ParseBuildsGetInstanceResponse(rsp *http.Response) (*BuildsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsUpdateInstanceResponse parses an HTTP response from a BuildsUpdateInstanceWithResponse call
func ParseBuildsUpdateInstanceResponse(rsp *http.Response) (*BuildsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildsAppGetToOneRelatedResponse parses an HTTP response from a BuildsAppGetToOneRelatedWithResponse call
func ParseBuildsAppGetToOneRelatedResponse(rsp *http.Response) (*BuildsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsAppEncryptionDeclarationGetToOneRelatedResponse parses an HTTP response from a BuildsAppEncryptionDeclarationGetToOneRelatedWithResponse call
func ParseBuildsAppEncryptionDeclarationGetToOneRelatedResponse(rsp *http.Response) (*BuildsAppEncryptionDeclarationGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsAppEncryptionDeclarationGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppEncryptionDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsAppStoreVersionGetToOneRelatedResponse parses an HTTP response from a BuildsAppStoreVersionGetToOneRelatedWithResponse call
func ParseBuildsAppStoreVersionGetToOneRelatedResponse(rsp *http.Response) (*BuildsAppStoreVersionGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsAppStoreVersionGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsBetaAppReviewSubmissionGetToOneRelatedResponse parses an HTTP response from a BuildsBetaAppReviewSubmissionGetToOneRelatedWithResponse call
func ParseBuildsBetaAppReviewSubmissionGetToOneRelatedResponse(rsp *http.Response) (*BuildsBetaAppReviewSubmissionGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsBetaAppReviewSubmissionGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaAppReviewSubmissionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsBetaBuildLocalizationsGetToManyRelatedResponse parses an HTTP response from a BuildsBetaBuildLocalizationsGetToManyRelatedWithResponse call
func ParseBuildsBetaBuildLocalizationsGetToManyRelatedResponse(rsp *http.Response) (*BuildsBetaBuildLocalizationsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsBetaBuildLocalizationsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaBuildLocalizationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsBuildBetaDetailGetToOneRelatedResponse parses an HTTP response from a BuildsBuildBetaDetailGetToOneRelatedWithResponse call
func ParseBuildsBuildBetaDetailGetToOneRelatedResponse(rsp *http.Response) (*BuildsBuildBetaDetailGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsBuildBetaDetailGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildBetaDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsDiagnosticSignaturesGetToManyRelatedResponse parses an HTTP response from a BuildsDiagnosticSignaturesGetToManyRelatedWithResponse call
func ParseBuildsDiagnosticSignaturesGetToManyRelatedResponse(rsp *http.Response) (*BuildsDiagnosticSignaturesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsDiagnosticSignaturesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiagnosticSignaturesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsIconsGetToManyRelatedResponse parses an HTTP response from a BuildsIconsGetToManyRelatedWithResponse call
func ParseBuildsIconsGetToManyRelatedResponse(rsp *http.Response) (*BuildsIconsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsIconsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildIconsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsIndividualTestersGetToManyRelatedResponse parses an HTTP response from a BuildsIndividualTestersGetToManyRelatedWithResponse call
func ParseBuildsIndividualTestersGetToManyRelatedResponse(rsp *http.Response) (*BuildsIndividualTestersGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsIndividualTestersGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BetaTestersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsPerfPowerMetricsGetToManyRelatedResponse parses an HTTP response from a BuildsPerfPowerMetricsGetToManyRelatedWithResponse call
func ParseBuildsPerfPowerMetricsGetToManyRelatedResponse(rsp *http.Response) (*BuildsPerfPowerMetricsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsPerfPowerMetricsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PerfPowerMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsPreReleaseVersionGetToOneRelatedResponse parses an HTTP response from a BuildsPreReleaseVersionGetToOneRelatedWithResponse call
func ParseBuildsPreReleaseVersionGetToOneRelatedResponse(rsp *http.Response) (*BuildsPreReleaseVersionGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsPreReleaseVersionGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrereleaseVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsAppEncryptionDeclarationGetToOneRelationshipResponse parses an HTTP response from a BuildsAppEncryptionDeclarationGetToOneRelationshipWithResponse call
func ParseBuildsAppEncryptionDeclarationGetToOneRelationshipResponse(rsp *http.Response) (*BuildsAppEncryptionDeclarationGetToOneRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsAppEncryptionDeclarationGetToOneRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildAppEncryptionDeclarationLinkageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse parses an HTTP response from a BuildsAppEncryptionDeclarationUpdateToOneRelationshipWithResponse call
func ParseBuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse(rsp *http.Response) (*BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsAppEncryptionDeclarationUpdateToOneRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildsBetaGroupsDeleteToManyRelationshipResponse parses an HTTP response from a BuildsBetaGroupsDeleteToManyRelationshipWithResponse call
func ParseBuildsBetaGroupsDeleteToManyRelationshipResponse(rsp *http.Response) (*BuildsBetaGroupsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsBetaGroupsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildsBetaGroupsCreateToManyRelationshipResponse parses an HTTP response from a BuildsBetaGroupsCreateToManyRelationshipWithResponse call
func ParseBuildsBetaGroupsCreateToManyRelationshipResponse(rsp *http.Response) (*BuildsBetaGroupsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsBetaGroupsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildsIndividualTestersDeleteToManyRelationshipResponse parses an HTTP response from a BuildsIndividualTestersDeleteToManyRelationshipWithResponse call
func ParseBuildsIndividualTestersDeleteToManyRelationshipResponse(rsp *http.Response) (*BuildsIndividualTestersDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsIndividualTestersDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBuildsIndividualTestersGetToManyRelationshipResponse parses an HTTP response from a BuildsIndividualTestersGetToManyRelationshipWithResponse call
func ParseBuildsIndividualTestersGetToManyRelationshipResponse(rsp *http.Response) (*BuildsIndividualTestersGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsIndividualTestersGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildIndividualTestersLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBuildsIndividualTestersCreateToManyRelationshipResponse parses an HTTP response from a BuildsIndividualTestersCreateToManyRelationshipWithResponse call
func ParseBuildsIndividualTestersCreateToManyRelationshipResponse(rsp *http.Response) (*BuildsIndividualTestersCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BuildsIndividualTestersCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdCapabilitiesCreateInstanceResponse parses an HTTP response from a BundleIdCapabilitiesCreateInstanceWithResponse call
func ParseBundleIdCapabilitiesCreateInstanceResponse(rsp *http.Response) (*BundleIdCapabilitiesCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdCapabilitiesCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BundleIdCapabilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdCapabilitiesDeleteInstanceResponse parses an HTTP response from a BundleIdCapabilitiesDeleteInstanceWithResponse call
func ParseBundleIdCapabilitiesDeleteInstanceResponse(rsp *http.Response) (*BundleIdCapabilitiesDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdCapabilitiesDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdCapabilitiesUpdateInstanceResponse parses an HTTP response from a BundleIdCapabilitiesUpdateInstanceWithResponse call
func ParseBundleIdCapabilitiesUpdateInstanceResponse(rsp *http.Response) (*BundleIdCapabilitiesUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdCapabilitiesUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleIdCapabilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdsGetCollectionResponse parses an HTTP response from a BundleIdsGetCollectionWithResponse call
func ParseBundleIdsGetCollectionResponse(rsp *http.Response) (*BundleIdsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleIdsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBundleIdsCreateInstanceResponse parses an HTTP response from a BundleIdsCreateInstanceWithResponse call
func ParseBundleIdsCreateInstanceResponse(rsp *http.Response) (*BundleIdsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BundleIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdsDeleteInstanceResponse parses an HTTP response from a BundleIdsDeleteInstanceWithResponse call
func ParseBundleIdsDeleteInstanceResponse(rsp *http.Response) (*BundleIdsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdsGetInstanceResponse parses an HTTP response from a BundleIdsGetInstanceWithResponse call
func ParseBundleIdsGetInstanceResponse(rsp *http.Response) (*BundleIdsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBundleIdsUpdateInstanceResponse parses an HTTP response from a BundleIdsUpdateInstanceWithResponse call
func ParseBundleIdsUpdateInstanceResponse(rsp *http.Response) (*BundleIdsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseBundleIdsAppGetToOneRelatedResponse parses an HTTP response from a BundleIdsAppGetToOneRelatedWithResponse call
func ParseBundleIdsAppGetToOneRelatedResponse(rsp *http.Response) (*BundleIdsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBundleIdsBundleIdCapabilitiesGetToManyRelatedResponse parses an HTTP response from a BundleIdsBundleIdCapabilitiesGetToManyRelatedWithResponse call
func ParseBundleIdsBundleIdCapabilitiesGetToManyRelatedResponse(rsp *http.Response) (*BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsBundleIdCapabilitiesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleIdCapabilitiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBundleIdsProfilesGetToManyRelatedResponse parses an HTTP response from a BundleIdsProfilesGetToManyRelatedWithResponse call
func ParseBundleIdsProfilesGetToManyRelatedResponse(rsp *http.Response) (*BundleIdsProfilesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &BundleIdsProfilesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCertificatesGetCollectionResponse parses an HTTP response from a CertificatesGetCollectionWithResponse call
func ParseCertificatesGetCollectionResponse(rsp *http.Response) (*CertificatesGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CertificatesGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCertificatesCreateInstanceResponse parses an HTTP response from a CertificatesCreateInstanceWithResponse call
func ParseCertificatesCreateInstanceResponse(rsp *http.Response) (*CertificatesCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CertificatesCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCertificatesDeleteInstanceResponse parses an HTTP response from a CertificatesDeleteInstanceWithResponse call
func ParseCertificatesDeleteInstanceResponse(rsp *http.Response) (*CertificatesDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CertificatesDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseCertificatesGetInstanceResponse parses an HTTP response from a CertificatesGetInstanceWithResponse call
func ParseCertificatesGetInstanceResponse(rsp *http.Response) (*CertificatesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CertificatesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDevicesGetCollectionResponse parses an HTTP response from a DevicesGetCollectionWithResponse call
func ParseDevicesGetCollectionResponse(rsp *http.Response) (*DevicesGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DevicesGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDevicesCreateInstanceResponse parses an HTTP response from a DevicesCreateInstanceWithResponse call
func ParseDevicesCreateInstanceResponse(rsp *http.Response) (*DevicesCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DevicesCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DeviceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDevicesGetInstanceResponse parses an HTTP response from a DevicesGetInstanceWithResponse call
func ParseDevicesGetInstanceResponse(rsp *http.Response) (*DevicesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DevicesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDevicesUpdateInstanceResponse parses an HTTP response from a DevicesUpdateInstanceWithResponse call
func ParseDevicesUpdateInstanceResponse(rsp *http.Response) (*DevicesUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DevicesUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeviceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDiagnosticSignaturesLogsGetToManyRelatedResponse parses an HTTP response from a DiagnosticSignaturesLogsGetToManyRelatedWithResponse call
func ParseDiagnosticSignaturesLogsGetToManyRelatedResponse(rsp *http.Response) (*DiagnosticSignaturesLogsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiagnosticSignaturesLogsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiagnosticLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEndUserLicenseAgreementsCreateInstanceResponse parses an HTTP response from a EndUserLicenseAgreementsCreateInstanceWithResponse call
func ParseEndUserLicenseAgreementsCreateInstanceResponse(rsp *http.Response) (*EndUserLicenseAgreementsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EndUserLicenseAgreementsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndUserLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseEndUserLicenseAgreementsDeleteInstanceResponse parses an HTTP response from a EndUserLicenseAgreementsDeleteInstanceWithResponse call
func ParseEndUserLicenseAgreementsDeleteInstanceResponse(rsp *http.Response) (*EndUserLicenseAgreementsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EndUserLicenseAgreementsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseEndUserLicenseAgreementsGetInstanceResponse parses an HTTP response from a EndUserLicenseAgreementsGetInstanceWithResponse call
func ParseEndUserLicenseAgreementsGetInstanceResponse(rsp *http.Response) (*EndUserLicenseAgreementsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EndUserLicenseAgreementsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUserLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEndUserLicenseAgreementsUpdateInstanceResponse parses an HTTP response from a EndUserLicenseAgreementsUpdateInstanceWithResponse call
func ParseEndUserLicenseAgreementsUpdateInstanceResponse(rsp *http.Response) (*EndUserLicenseAgreementsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EndUserLicenseAgreementsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndUserLicenseAgreementResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseEndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse parses an HTTP response from a EndUserLicenseAgreementsTerritoriesGetToManyRelatedWithResponse call
func ParseEndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse(rsp *http.Response) (*EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &EndUserLicenseAgreementsTerritoriesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TerritoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFinanceReportsGetCollectionResponse parses an HTTP response from a FinanceReportsGetCollectionWithResponse call
func ParseFinanceReportsGetCollectionResponse(rsp *http.Response) (*FinanceReportsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FinanceReportsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse parses an HTTP response from a GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedWithResponse call
func ParseGameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse(rsp *http.Response) (*GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameCenterEnabledVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse parses an HTTP response from a GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipWithResponse call
func ParseGameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse(rsp *http.Response) (*GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse parses an HTTP response from a GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipWithResponse call
func ParseGameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse(rsp *http.Response) (*GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameCenterEnabledVersionCompatibleVersionsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse parses an HTTP response from a GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipWithResponse call
func ParseGameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse(rsp *http.Response) (*GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse parses an HTTP response from a GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipWithResponse call
func ParseGameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse(rsp *http.Response) (*GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseIdfaDeclarationsCreateInstanceResponse parses an HTTP response from a IdfaDeclarationsCreateInstanceWithResponse call
func ParseIdfaDeclarationsCreateInstanceResponse(rsp *http.Response) (*IdfaDeclarationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &IdfaDeclarationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IdfaDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseIdfaDeclarationsDeleteInstanceResponse parses an HTTP response from a IdfaDeclarationsDeleteInstanceWithResponse call
func ParseIdfaDeclarationsDeleteInstanceResponse(rsp *http.Response) (*IdfaDeclarationsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &IdfaDeclarationsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseIdfaDeclarationsUpdateInstanceResponse parses an HTTP response from a IdfaDeclarationsUpdateInstanceWithResponse call
func ParseIdfaDeclarationsUpdateInstanceResponse(rsp *http.Response) (*IdfaDeclarationsUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &IdfaDeclarationsUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdfaDeclarationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseInAppPurchasesGetInstanceResponse parses an HTTP response from a InAppPurchasesGetInstanceWithResponse call
func ParseInAppPurchasesGetInstanceResponse(rsp *http.Response) (*InAppPurchasesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InAppPurchasesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InAppPurchaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePreReleaseVersionsGetCollectionResponse parses an HTTP response from a PreReleaseVersionsGetCollectionWithResponse call
func ParsePreReleaseVersionsGetCollectionResponse(rsp *http.Response) (*PreReleaseVersionsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PreReleaseVersionsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreReleaseVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePreReleaseVersionsGetInstanceResponse parses an HTTP response from a PreReleaseVersionsGetInstanceWithResponse call
func ParsePreReleaseVersionsGetInstanceResponse(rsp *http.Response) (*PreReleaseVersionsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PreReleaseVersionsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrereleaseVersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePreReleaseVersionsAppGetToOneRelatedResponse parses an HTTP response from a PreReleaseVersionsAppGetToOneRelatedWithResponse call
func ParsePreReleaseVersionsAppGetToOneRelatedResponse(rsp *http.Response) (*PreReleaseVersionsAppGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PreReleaseVersionsAppGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePreReleaseVersionsBuildsGetToManyRelatedResponse parses an HTTP response from a PreReleaseVersionsBuildsGetToManyRelatedWithResponse call
func ParsePreReleaseVersionsBuildsGetToManyRelatedResponse(rsp *http.Response) (*PreReleaseVersionsBuildsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PreReleaseVersionsBuildsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProfilesGetCollectionResponse parses an HTTP response from a ProfilesGetCollectionWithResponse call
func ParseProfilesGetCollectionResponse(rsp *http.Response) (*ProfilesGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProfilesCreateInstanceResponse parses an HTTP response from a ProfilesCreateInstanceWithResponse call
func ParseProfilesCreateInstanceResponse(rsp *http.Response) (*ProfilesCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseProfilesDeleteInstanceResponse parses an HTTP response from a ProfilesDeleteInstanceWithResponse call
func ParseProfilesDeleteInstanceResponse(rsp *http.Response) (*ProfilesDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseProfilesGetInstanceResponse parses an HTTP response from a ProfilesGetInstanceWithResponse call
func ParseProfilesGetInstanceResponse(rsp *http.Response) (*ProfilesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProfilesBundleIdGetToOneRelatedResponse parses an HTTP response from a ProfilesBundleIdGetToOneRelatedWithResponse call
func ParseProfilesBundleIdGetToOneRelatedResponse(rsp *http.Response) (*ProfilesBundleIdGetToOneRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesBundleIdGetToOneRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BundleIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProfilesCertificatesGetToManyRelatedResponse parses an HTTP response from a ProfilesCertificatesGetToManyRelatedWithResponse call
func ParseProfilesCertificatesGetToManyRelatedResponse(rsp *http.Response) (*ProfilesCertificatesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesCertificatesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProfilesDevicesGetToManyRelatedResponse parses an HTTP response from a ProfilesDevicesGetToManyRelatedWithResponse call
func ParseProfilesDevicesGetToManyRelatedResponse(rsp *http.Response) (*ProfilesDevicesGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ProfilesDevicesGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DevicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRoutingAppCoveragesCreateInstanceResponse parses an HTTP response from a RoutingAppCoveragesCreateInstanceWithResponse call
func ParseRoutingAppCoveragesCreateInstanceResponse(rsp *http.Response) (*RoutingAppCoveragesCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RoutingAppCoveragesCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoutingAppCoverageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRoutingAppCoveragesDeleteInstanceResponse parses an HTTP response from a RoutingAppCoveragesDeleteInstanceWithResponse call
func ParseRoutingAppCoveragesDeleteInstanceResponse(rsp *http.Response) (*RoutingAppCoveragesDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RoutingAppCoveragesDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseRoutingAppCoveragesGetInstanceResponse parses an HTTP response from a RoutingAppCoveragesGetInstanceWithResponse call
func ParseRoutingAppCoveragesGetInstanceResponse(rsp *http.Response) (*RoutingAppCoveragesGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RoutingAppCoveragesGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoutingAppCoverageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRoutingAppCoveragesUpdateInstanceResponse parses an HTTP response from a RoutingAppCoveragesUpdateInstanceWithResponse call
func ParseRoutingAppCoveragesUpdateInstanceResponse(rsp *http.Response) (*RoutingAppCoveragesUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RoutingAppCoveragesUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoutingAppCoverageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseSalesReportsGetCollectionResponse parses an HTTP response from a SalesReportsGetCollectionWithResponse call
func ParseSalesReportsGetCollectionResponse(rsp *http.Response) (*SalesReportsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SalesReportsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTerritoriesGetCollectionResponse parses an HTTP response from a TerritoriesGetCollectionWithResponse call
func ParseTerritoriesGetCollectionResponse(rsp *http.Response) (*TerritoriesGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &TerritoriesGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TerritoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserInvitationsGetCollectionResponse parses an HTTP response from a UserInvitationsGetCollectionWithResponse call
func ParseUserInvitationsGetCollectionResponse(rsp *http.Response) (*UserInvitationsGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UserInvitationsGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserInvitationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserInvitationsCreateInstanceResponse parses an HTTP response from a UserInvitationsCreateInstanceWithResponse call
func ParseUserInvitationsCreateInstanceResponse(rsp *http.Response) (*UserInvitationsCreateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UserInvitationsCreateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserInvitationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUserInvitationsDeleteInstanceResponse parses an HTTP response from a UserInvitationsDeleteInstanceWithResponse call
func ParseUserInvitationsDeleteInstanceResponse(rsp *http.Response) (*UserInvitationsDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UserInvitationsDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUserInvitationsGetInstanceResponse parses an HTTP response from a UserInvitationsGetInstanceWithResponse call
func ParseUserInvitationsGetInstanceResponse(rsp *http.Response) (*UserInvitationsGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UserInvitationsGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserInvitationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserInvitationsVisibleAppsGetToManyRelatedResponse parses an HTTP response from a UserInvitationsVisibleAppsGetToManyRelatedWithResponse call
func ParseUserInvitationsVisibleAppsGetToManyRelatedResponse(rsp *http.Response) (*UserInvitationsVisibleAppsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UserInvitationsVisibleAppsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersGetCollectionResponse parses an HTTP response from a UsersGetCollectionWithResponse call
func ParseUsersGetCollectionResponse(rsp *http.Response) (*UsersGetCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersGetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUsersDeleteInstanceResponse parses an HTTP response from a UsersDeleteInstanceWithResponse call
func ParseUsersDeleteInstanceResponse(rsp *http.Response) (*UsersDeleteInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersDeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUsersGetInstanceResponse parses an HTTP response from a UsersGetInstanceWithResponse call
func ParseUsersGetInstanceResponse(rsp *http.Response) (*UsersGetInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersGetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersUpdateInstanceResponse parses an HTTP response from a UsersUpdateInstanceWithResponse call
func ParseUsersUpdateInstanceResponse(rsp *http.Response) (*UsersUpdateInstanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdateInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUsersVisibleAppsDeleteToManyRelationshipResponse parses an HTTP response from a UsersVisibleAppsDeleteToManyRelationshipWithResponse call
func ParseUsersVisibleAppsDeleteToManyRelationshipResponse(rsp *http.Response) (*UsersVisibleAppsDeleteToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersVisibleAppsDeleteToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUsersVisibleAppsGetToManyRelationshipResponse parses an HTTP response from a UsersVisibleAppsGetToManyRelationshipWithResponse call
func ParseUsersVisibleAppsGetToManyRelationshipResponse(rsp *http.Response) (*UsersVisibleAppsGetToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersVisibleAppsGetToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserVisibleAppsLinkagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersVisibleAppsReplaceToManyRelationshipResponse parses an HTTP response from a UsersVisibleAppsReplaceToManyRelationshipWithResponse call
func ParseUsersVisibleAppsReplaceToManyRelationshipResponse(rsp *http.Response) (*UsersVisibleAppsReplaceToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersVisibleAppsReplaceToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUsersVisibleAppsCreateToManyRelationshipResponse parses an HTTP response from a UsersVisibleAppsCreateToManyRelationshipWithResponse call
func ParseUsersVisibleAppsCreateToManyRelationshipResponse(rsp *http.Response) (*UsersVisibleAppsCreateToManyRelationshipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersVisibleAppsCreateToManyRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseUsersVisibleAppsGetToManyRelatedResponse parses an HTTP response from a UsersVisibleAppsGetToManyRelatedWithResponse call
func ParseUsersVisibleAppsGetToManyRelatedResponse(rsp *http.Response) (*UsersVisibleAppsGetToManyRelatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UsersVisibleAppsGetToManyRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (PATCH /v1/ageRatingDeclarations/{id})
	AgeRatingDeclarationsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appCategories)
	AppCategoriesGetCollection(ctx echo.Context, params AppCategoriesGetCollectionParams) error

	// (GET /v1/appCategories/{id})
	AppCategoriesGetInstance(ctx echo.Context, id string, params AppCategoriesGetInstanceParams) error

	// (GET /v1/appCategories/{id}/parent)
	AppCategoriesParentGetToOneRelated(ctx echo.Context, id string, params AppCategoriesParentGetToOneRelatedParams) error

	// (GET /v1/appCategories/{id}/subcategories)
	AppCategoriesSubcategoriesGetToManyRelated(ctx echo.Context, id string, params AppCategoriesSubcategoriesGetToManyRelatedParams) error

	// (GET /v1/appEncryptionDeclarations)
	AppEncryptionDeclarationsGetCollection(ctx echo.Context, params AppEncryptionDeclarationsGetCollectionParams) error

	// (GET /v1/appEncryptionDeclarations/{id})
	AppEncryptionDeclarationsGetInstance(ctx echo.Context, id string, params AppEncryptionDeclarationsGetInstanceParams) error

	// (GET /v1/appEncryptionDeclarations/{id}/app)
	AppEncryptionDeclarationsAppGetToOneRelated(ctx echo.Context, id string, params AppEncryptionDeclarationsAppGetToOneRelatedParams) error

	// (POST /v1/appEncryptionDeclarations/{id}/relationships/builds)
	AppEncryptionDeclarationsBuildsCreateToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/appInfoLocalizations)
	AppInfoLocalizationsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appInfoLocalizations/{id})
	AppInfoLocalizationsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appInfoLocalizations/{id})
	AppInfoLocalizationsGetInstance(ctx echo.Context, id string, params AppInfoLocalizationsGetInstanceParams) error

	// (PATCH /v1/appInfoLocalizations/{id})
	AppInfoLocalizationsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appInfos/{id})
	AppInfosGetInstance(ctx echo.Context, id string, params AppInfosGetInstanceParams) error

	// (PATCH /v1/appInfos/{id})
	AppInfosUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appInfos/{id}/appInfoLocalizations)
	AppInfosAppInfoLocalizationsGetToManyRelated(ctx echo.Context, id string, params AppInfosAppInfoLocalizationsGetToManyRelatedParams) error

	// (GET /v1/appInfos/{id}/primaryCategory)
	AppInfosPrimaryCategoryGetToOneRelated(ctx echo.Context, id string, params AppInfosPrimaryCategoryGetToOneRelatedParams) error

	// (GET /v1/appInfos/{id}/primarySubcategoryOne)
	AppInfosPrimarySubcategoryOneGetToOneRelated(ctx echo.Context, id string, params AppInfosPrimarySubcategoryOneGetToOneRelatedParams) error

	// (GET /v1/appInfos/{id}/primarySubcategoryTwo)
	AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx echo.Context, id string, params AppInfosPrimarySubcategoryTwoGetToOneRelatedParams) error

	// (GET /v1/appInfos/{id}/secondaryCategory)
	AppInfosSecondaryCategoryGetToOneRelated(ctx echo.Context, id string, params AppInfosSecondaryCategoryGetToOneRelatedParams) error

	// (GET /v1/appInfos/{id}/secondarySubcategoryOne)
	AppInfosSecondarySubcategoryOneGetToOneRelated(ctx echo.Context, id string, params AppInfosSecondarySubcategoryOneGetToOneRelatedParams) error

	// (GET /v1/appInfos/{id}/secondarySubcategoryTwo)
	AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx echo.Context, id string, params AppInfosSecondarySubcategoryTwoGetToOneRelatedParams) error

	// (POST /v1/appPreOrders)
	AppPreOrdersCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appPreOrders/{id})
	AppPreOrdersDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appPreOrders/{id})
	AppPreOrdersGetInstance(ctx echo.Context, id string, params AppPreOrdersGetInstanceParams) error

	// (PATCH /v1/appPreOrders/{id})
	AppPreOrdersUpdateInstance(ctx echo.Context, id string) error

	// (POST /v1/appPreviewSets)
	AppPreviewSetsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appPreviewSets/{id})
	AppPreviewSetsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appPreviewSets/{id})
	AppPreviewSetsGetInstance(ctx echo.Context, id string, params AppPreviewSetsGetInstanceParams) error

	// (GET /v1/appPreviewSets/{id}/appPreviews)
	AppPreviewSetsAppPreviewsGetToManyRelated(ctx echo.Context, id string, params AppPreviewSetsAppPreviewsGetToManyRelatedParams) error

	// (GET /v1/appPreviewSets/{id}/relationships/appPreviews)
	AppPreviewSetsAppPreviewsGetToManyRelationship(ctx echo.Context, id string, params AppPreviewSetsAppPreviewsGetToManyRelationshipParams) error

	// (PATCH /v1/appPreviewSets/{id}/relationships/appPreviews)
	AppPreviewSetsAppPreviewsReplaceToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/appPreviews)
	AppPreviewsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appPreviews/{id})
	AppPreviewsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appPreviews/{id})
	AppPreviewsGetInstance(ctx echo.Context, id string, params AppPreviewsGetInstanceParams) error

	// (PATCH /v1/appPreviews/{id})
	AppPreviewsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appPricePoints)
	AppPricePointsGetCollection(ctx echo.Context, params AppPricePointsGetCollectionParams) error

	// (GET /v1/appPricePoints/{id})
	AppPricePointsGetInstance(ctx echo.Context, id string, params AppPricePointsGetInstanceParams) error

	// (GET /v1/appPricePoints/{id}/territory)
	AppPricePointsTerritoryGetToOneRelated(ctx echo.Context, id string, params AppPricePointsTerritoryGetToOneRelatedParams) error

	// (GET /v1/appPriceTiers)
	AppPriceTiersGetCollection(ctx echo.Context, params AppPriceTiersGetCollectionParams) error

	// (GET /v1/appPriceTiers/{id})
	AppPriceTiersGetInstance(ctx echo.Context, id string, params AppPriceTiersGetInstanceParams) error

	// (GET /v1/appPriceTiers/{id}/pricePoints)
	AppPriceTiersPricePointsGetToManyRelated(ctx echo.Context, id string, params AppPriceTiersPricePointsGetToManyRelatedParams) error

	// (GET /v1/appPrices/{id})
	AppPricesGetInstance(ctx echo.Context, id string, params AppPricesGetInstanceParams) error

	// (POST /v1/appScreenshotSets)
	AppScreenshotSetsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appScreenshotSets/{id})
	AppScreenshotSetsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appScreenshotSets/{id})
	AppScreenshotSetsGetInstance(ctx echo.Context, id string, params AppScreenshotSetsGetInstanceParams) error

	// (GET /v1/appScreenshotSets/{id}/appScreenshots)
	AppScreenshotSetsAppScreenshotsGetToManyRelated(ctx echo.Context, id string, params AppScreenshotSetsAppScreenshotsGetToManyRelatedParams) error

	// (GET /v1/appScreenshotSets/{id}/relationships/appScreenshots)
	AppScreenshotSetsAppScreenshotsGetToManyRelationship(ctx echo.Context, id string, params AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams) error

	// (PATCH /v1/appScreenshotSets/{id}/relationships/appScreenshots)
	AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/appScreenshots)
	AppScreenshotsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appScreenshots/{id})
	AppScreenshotsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appScreenshots/{id})
	AppScreenshotsGetInstance(ctx echo.Context, id string, params AppScreenshotsGetInstanceParams) error

	// (PATCH /v1/appScreenshots/{id})
	AppScreenshotsUpdateInstance(ctx echo.Context, id string) error

	// (POST /v1/appStoreReviewAttachments)
	AppStoreReviewAttachmentsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appStoreReviewAttachments/{id})
	AppStoreReviewAttachmentsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appStoreReviewAttachments/{id})
	AppStoreReviewAttachmentsGetInstance(ctx echo.Context, id string, params AppStoreReviewAttachmentsGetInstanceParams) error

	// (PATCH /v1/appStoreReviewAttachments/{id})
	AppStoreReviewAttachmentsUpdateInstance(ctx echo.Context, id string) error

	// (POST /v1/appStoreReviewDetails)
	AppStoreReviewDetailsCreateInstance(ctx echo.Context) error

	// (GET /v1/appStoreReviewDetails/{id})
	AppStoreReviewDetailsGetInstance(ctx echo.Context, id string, params AppStoreReviewDetailsGetInstanceParams) error

	// (PATCH /v1/appStoreReviewDetails/{id})
	AppStoreReviewDetailsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appStoreReviewDetails/{id}/appStoreReviewAttachments)
	AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(ctx echo.Context, id string, params AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams) error

	// (POST /v1/appStoreVersionLocalizations)
	AppStoreVersionLocalizationsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appStoreVersionLocalizations/{id})
	AppStoreVersionLocalizationsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appStoreVersionLocalizations/{id})
	AppStoreVersionLocalizationsGetInstance(ctx echo.Context, id string, params AppStoreVersionLocalizationsGetInstanceParams) error

	// (PATCH /v1/appStoreVersionLocalizations/{id})
	AppStoreVersionLocalizationsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appStoreVersionLocalizations/{id}/appPreviewSets)
	AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(ctx echo.Context, id string, params AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams) error

	// (GET /v1/appStoreVersionLocalizations/{id}/appScreenshotSets)
	AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(ctx echo.Context, id string, params AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams) error

	// (POST /v1/appStoreVersionPhasedReleases)
	AppStoreVersionPhasedReleasesCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appStoreVersionPhasedReleases/{id})
	AppStoreVersionPhasedReleasesDeleteInstance(ctx echo.Context, id string) error

	// (PATCH /v1/appStoreVersionPhasedReleases/{id})
	AppStoreVersionPhasedReleasesUpdateInstance(ctx echo.Context, id string) error

	// (POST /v1/appStoreVersionSubmissions)
	AppStoreVersionSubmissionsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appStoreVersionSubmissions/{id})
	AppStoreVersionSubmissionsDeleteInstance(ctx echo.Context, id string) error

	// (POST /v1/appStoreVersions)
	AppStoreVersionsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/appStoreVersions/{id})
	AppStoreVersionsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/appStoreVersions/{id})
	AppStoreVersionsGetInstance(ctx echo.Context, id string, params AppStoreVersionsGetInstanceParams) error

	// (PATCH /v1/appStoreVersions/{id})
	AppStoreVersionsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/appStoreVersions/{id}/ageRatingDeclaration)
	AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/appStoreReviewDetail)
	AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/appStoreVersionLocalizations)
	AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx echo.Context, id string, params AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/appStoreVersionPhasedRelease)
	AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/appStoreVersionSubmission)
	AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/build)
	AppStoreVersionsBuildGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsBuildGetToOneRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/idfaDeclaration)
	AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsIdfaDeclarationGetToOneRelatedParams) error

	// (GET /v1/appStoreVersions/{id}/relationships/build)
	AppStoreVersionsBuildGetToOneRelationship(ctx echo.Context, id string) error

	// (PATCH /v1/appStoreVersions/{id}/relationships/build)
	AppStoreVersionsBuildUpdateToOneRelationship(ctx echo.Context, id string) error

	// (GET /v1/appStoreVersions/{id}/routingAppCoverage)
	AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx echo.Context, id string, params AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams) error

	// (GET /v1/apps)
	AppsGetCollection(ctx echo.Context, params AppsGetCollectionParams) error

	// (GET /v1/apps/{id})
	AppsGetInstance(ctx echo.Context, id string, params AppsGetInstanceParams) error

	// (PATCH /v1/apps/{id})
	AppsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/apps/{id}/appInfos)
	AppsAppInfosGetToManyRelated(ctx echo.Context, id string, params AppsAppInfosGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/appStoreVersions)
	AppsAppStoreVersionsGetToManyRelated(ctx echo.Context, id string, params AppsAppStoreVersionsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/availableTerritories)
	AppsAvailableTerritoriesGetToManyRelated(ctx echo.Context, id string, params AppsAvailableTerritoriesGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/betaAppLocalizations)
	AppsBetaAppLocalizationsGetToManyRelated(ctx echo.Context, id string, params AppsBetaAppLocalizationsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/betaAppReviewDetail)
	AppsBetaAppReviewDetailGetToOneRelated(ctx echo.Context, id string, params AppsBetaAppReviewDetailGetToOneRelatedParams) error

	// (GET /v1/apps/{id}/betaGroups)
	AppsBetaGroupsGetToManyRelated(ctx echo.Context, id string, params AppsBetaGroupsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/betaLicenseAgreement)
	AppsBetaLicenseAgreementGetToOneRelated(ctx echo.Context, id string, params AppsBetaLicenseAgreementGetToOneRelatedParams) error

	// (GET /v1/apps/{id}/builds)
	AppsBuildsGetToManyRelated(ctx echo.Context, id string, params AppsBuildsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/endUserLicenseAgreement)
	AppsEndUserLicenseAgreementGetToOneRelated(ctx echo.Context, id string, params AppsEndUserLicenseAgreementGetToOneRelatedParams) error

	// (GET /v1/apps/{id}/gameCenterEnabledVersions)
	AppsGameCenterEnabledVersionsGetToManyRelated(ctx echo.Context, id string, params AppsGameCenterEnabledVersionsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/inAppPurchases)
	AppsInAppPurchasesGetToManyRelated(ctx echo.Context, id string, params AppsInAppPurchasesGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/perfPowerMetrics)
	AppsPerfPowerMetricsGetToManyRelated(ctx echo.Context, id string, params AppsPerfPowerMetricsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/preOrder)
	AppsPreOrderGetToOneRelated(ctx echo.Context, id string, params AppsPreOrderGetToOneRelatedParams) error

	// (GET /v1/apps/{id}/preReleaseVersions)
	AppsPreReleaseVersionsGetToManyRelated(ctx echo.Context, id string, params AppsPreReleaseVersionsGetToManyRelatedParams) error

	// (GET /v1/apps/{id}/prices)
	AppsPricesGetToManyRelated(ctx echo.Context, id string, params AppsPricesGetToManyRelatedParams) error

	// (DELETE /v1/apps/{id}/relationships/betaTesters)
	AppsBetaTestersDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaAppLocalizations)
	BetaAppLocalizationsGetCollection(ctx echo.Context, params BetaAppLocalizationsGetCollectionParams) error

	// (POST /v1/betaAppLocalizations)
	BetaAppLocalizationsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/betaAppLocalizations/{id})
	BetaAppLocalizationsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/betaAppLocalizations/{id})
	BetaAppLocalizationsGetInstance(ctx echo.Context, id string, params BetaAppLocalizationsGetInstanceParams) error

	// (PATCH /v1/betaAppLocalizations/{id})
	BetaAppLocalizationsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/betaAppLocalizations/{id}/app)
	BetaAppLocalizationsAppGetToOneRelated(ctx echo.Context, id string, params BetaAppLocalizationsAppGetToOneRelatedParams) error

	// (GET /v1/betaAppReviewDetails)
	BetaAppReviewDetailsGetCollection(ctx echo.Context, params BetaAppReviewDetailsGetCollectionParams) error

	// (GET /v1/betaAppReviewDetails/{id})
	BetaAppReviewDetailsGetInstance(ctx echo.Context, id string, params BetaAppReviewDetailsGetInstanceParams) error

	// (PATCH /v1/betaAppReviewDetails/{id})
	BetaAppReviewDetailsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/betaAppReviewDetails/{id}/app)
	BetaAppReviewDetailsAppGetToOneRelated(ctx echo.Context, id string, params BetaAppReviewDetailsAppGetToOneRelatedParams) error

	// (GET /v1/betaAppReviewSubmissions)
	BetaAppReviewSubmissionsGetCollection(ctx echo.Context, params BetaAppReviewSubmissionsGetCollectionParams) error

	// (POST /v1/betaAppReviewSubmissions)
	BetaAppReviewSubmissionsCreateInstance(ctx echo.Context) error

	// (GET /v1/betaAppReviewSubmissions/{id})
	BetaAppReviewSubmissionsGetInstance(ctx echo.Context, id string, params BetaAppReviewSubmissionsGetInstanceParams) error

	// (GET /v1/betaAppReviewSubmissions/{id}/build)
	BetaAppReviewSubmissionsBuildGetToOneRelated(ctx echo.Context, id string, params BetaAppReviewSubmissionsBuildGetToOneRelatedParams) error

	// (GET /v1/betaBuildLocalizations)
	BetaBuildLocalizationsGetCollection(ctx echo.Context, params BetaBuildLocalizationsGetCollectionParams) error

	// (POST /v1/betaBuildLocalizations)
	BetaBuildLocalizationsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/betaBuildLocalizations/{id})
	BetaBuildLocalizationsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/betaBuildLocalizations/{id})
	BetaBuildLocalizationsGetInstance(ctx echo.Context, id string, params BetaBuildLocalizationsGetInstanceParams) error

	// (PATCH /v1/betaBuildLocalizations/{id})
	BetaBuildLocalizationsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/betaBuildLocalizations/{id}/build)
	BetaBuildLocalizationsBuildGetToOneRelated(ctx echo.Context, id string, params BetaBuildLocalizationsBuildGetToOneRelatedParams) error

	// (GET /v1/betaGroups)
	BetaGroupsGetCollection(ctx echo.Context, params BetaGroupsGetCollectionParams) error

	// (POST /v1/betaGroups)
	BetaGroupsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/betaGroups/{id})
	BetaGroupsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/betaGroups/{id})
	BetaGroupsGetInstance(ctx echo.Context, id string, params BetaGroupsGetInstanceParams) error

	// (PATCH /v1/betaGroups/{id})
	BetaGroupsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/betaGroups/{id}/app)
	BetaGroupsAppGetToOneRelated(ctx echo.Context, id string, params BetaGroupsAppGetToOneRelatedParams) error

	// (GET /v1/betaGroups/{id}/betaTesters)
	BetaGroupsBetaTestersGetToManyRelated(ctx echo.Context, id string, params BetaGroupsBetaTestersGetToManyRelatedParams) error

	// (GET /v1/betaGroups/{id}/builds)
	BetaGroupsBuildsGetToManyRelated(ctx echo.Context, id string, params BetaGroupsBuildsGetToManyRelatedParams) error

	// (DELETE /v1/betaGroups/{id}/relationships/betaTesters)
	BetaGroupsBetaTestersDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaGroups/{id}/relationships/betaTesters)
	BetaGroupsBetaTestersGetToManyRelationship(ctx echo.Context, id string, params BetaGroupsBetaTestersGetToManyRelationshipParams) error

	// (POST /v1/betaGroups/{id}/relationships/betaTesters)
	BetaGroupsBetaTestersCreateToManyRelationship(ctx echo.Context, id string) error

	// (DELETE /v1/betaGroups/{id}/relationships/builds)
	BetaGroupsBuildsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaGroups/{id}/relationships/builds)
	BetaGroupsBuildsGetToManyRelationship(ctx echo.Context, id string, params BetaGroupsBuildsGetToManyRelationshipParams) error

	// (POST /v1/betaGroups/{id}/relationships/builds)
	BetaGroupsBuildsCreateToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaLicenseAgreements)
	BetaLicenseAgreementsGetCollection(ctx echo.Context, params BetaLicenseAgreementsGetCollectionParams) error

	// (GET /v1/betaLicenseAgreements/{id})
	BetaLicenseAgreementsGetInstance(ctx echo.Context, id string, params BetaLicenseAgreementsGetInstanceParams) error

	// (PATCH /v1/betaLicenseAgreements/{id})
	BetaLicenseAgreementsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/betaLicenseAgreements/{id}/app)
	BetaLicenseAgreementsAppGetToOneRelated(ctx echo.Context, id string, params BetaLicenseAgreementsAppGetToOneRelatedParams) error

	// (POST /v1/betaTesterInvitations)
	BetaTesterInvitationsCreateInstance(ctx echo.Context) error

	// (GET /v1/betaTesters)
	BetaTestersGetCollection(ctx echo.Context, params BetaTestersGetCollectionParams) error

	// (POST /v1/betaTesters)
	BetaTestersCreateInstance(ctx echo.Context) error

	// (DELETE /v1/betaTesters/{id})
	BetaTestersDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/betaTesters/{id})
	BetaTestersGetInstance(ctx echo.Context, id string, params BetaTestersGetInstanceParams) error

	// (GET /v1/betaTesters/{id}/apps)
	BetaTestersAppsGetToManyRelated(ctx echo.Context, id string, params BetaTestersAppsGetToManyRelatedParams) error

	// (GET /v1/betaTesters/{id}/betaGroups)
	BetaTestersBetaGroupsGetToManyRelated(ctx echo.Context, id string, params BetaTestersBetaGroupsGetToManyRelatedParams) error

	// (GET /v1/betaTesters/{id}/builds)
	BetaTestersBuildsGetToManyRelated(ctx echo.Context, id string, params BetaTestersBuildsGetToManyRelatedParams) error

	// (DELETE /v1/betaTesters/{id}/relationships/apps)
	BetaTestersAppsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaTesters/{id}/relationships/apps)
	BetaTestersAppsGetToManyRelationship(ctx echo.Context, id string, params BetaTestersAppsGetToManyRelationshipParams) error

	// (DELETE /v1/betaTesters/{id}/relationships/betaGroups)
	BetaTestersBetaGroupsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaTesters/{id}/relationships/betaGroups)
	BetaTestersBetaGroupsGetToManyRelationship(ctx echo.Context, id string, params BetaTestersBetaGroupsGetToManyRelationshipParams) error

	// (POST /v1/betaTesters/{id}/relationships/betaGroups)
	BetaTestersBetaGroupsCreateToManyRelationship(ctx echo.Context, id string) error

	// (DELETE /v1/betaTesters/{id}/relationships/builds)
	BetaTestersBuildsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/betaTesters/{id}/relationships/builds)
	BetaTestersBuildsGetToManyRelationship(ctx echo.Context, id string, params BetaTestersBuildsGetToManyRelationshipParams) error

	// (POST /v1/betaTesters/{id}/relationships/builds)
	BetaTestersBuildsCreateToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/buildBetaDetails)
	BuildBetaDetailsGetCollection(ctx echo.Context, params BuildBetaDetailsGetCollectionParams) error

	// (GET /v1/buildBetaDetails/{id})
	BuildBetaDetailsGetInstance(ctx echo.Context, id string, params BuildBetaDetailsGetInstanceParams) error

	// (PATCH /v1/buildBetaDetails/{id})
	BuildBetaDetailsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/buildBetaDetails/{id}/build)
	BuildBetaDetailsBuildGetToOneRelated(ctx echo.Context, id string, params BuildBetaDetailsBuildGetToOneRelatedParams) error

	// (POST /v1/buildBetaNotifications)
	BuildBetaNotificationsCreateInstance(ctx echo.Context) error

	// (GET /v1/builds)
	BuildsGetCollection(ctx echo.Context, params BuildsGetCollectionParams) error

	// (GET /v1/builds/{id})
	BuildsGetInstance(ctx echo.Context, id string, params BuildsGetInstanceParams) error

	// (PATCH /v1/builds/{id})
	BuildsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/builds/{id}/app)
	BuildsAppGetToOneRelated(ctx echo.Context, id string, params BuildsAppGetToOneRelatedParams) error

	// (GET /v1/builds/{id}/appEncryptionDeclaration)
	BuildsAppEncryptionDeclarationGetToOneRelated(ctx echo.Context, id string, params BuildsAppEncryptionDeclarationGetToOneRelatedParams) error

	// (GET /v1/builds/{id}/appStoreVersion)
	BuildsAppStoreVersionGetToOneRelated(ctx echo.Context, id string, params BuildsAppStoreVersionGetToOneRelatedParams) error

	// (GET /v1/builds/{id}/betaAppReviewSubmission)
	BuildsBetaAppReviewSubmissionGetToOneRelated(ctx echo.Context, id string, params BuildsBetaAppReviewSubmissionGetToOneRelatedParams) error

	// (GET /v1/builds/{id}/betaBuildLocalizations)
	BuildsBetaBuildLocalizationsGetToManyRelated(ctx echo.Context, id string, params BuildsBetaBuildLocalizationsGetToManyRelatedParams) error

	// (GET /v1/builds/{id}/buildBetaDetail)
	BuildsBuildBetaDetailGetToOneRelated(ctx echo.Context, id string, params BuildsBuildBetaDetailGetToOneRelatedParams) error

	// (GET /v1/builds/{id}/diagnosticSignatures)
	BuildsDiagnosticSignaturesGetToManyRelated(ctx echo.Context, id string, params BuildsDiagnosticSignaturesGetToManyRelatedParams) error

	// (GET /v1/builds/{id}/icons)
	BuildsIconsGetToManyRelated(ctx echo.Context, id string, params BuildsIconsGetToManyRelatedParams) error

	// (GET /v1/builds/{id}/individualTesters)
	BuildsIndividualTestersGetToManyRelated(ctx echo.Context, id string, params BuildsIndividualTestersGetToManyRelatedParams) error

	// (GET /v1/builds/{id}/perfPowerMetrics)
	BuildsPerfPowerMetricsGetToManyRelated(ctx echo.Context, id string, params BuildsPerfPowerMetricsGetToManyRelatedParams) error

	// (GET /v1/builds/{id}/preReleaseVersion)
	BuildsPreReleaseVersionGetToOneRelated(ctx echo.Context, id string, params BuildsPreReleaseVersionGetToOneRelatedParams) error

	// (GET /v1/builds/{id}/relationships/appEncryptionDeclaration)
	BuildsAppEncryptionDeclarationGetToOneRelationship(ctx echo.Context, id string) error

	// (PATCH /v1/builds/{id}/relationships/appEncryptionDeclaration)
	BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx echo.Context, id string) error

	// (DELETE /v1/builds/{id}/relationships/betaGroups)
	BuildsBetaGroupsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/builds/{id}/relationships/betaGroups)
	BuildsBetaGroupsCreateToManyRelationship(ctx echo.Context, id string) error

	// (DELETE /v1/builds/{id}/relationships/individualTesters)
	BuildsIndividualTestersDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/builds/{id}/relationships/individualTesters)
	BuildsIndividualTestersGetToManyRelationship(ctx echo.Context, id string, params BuildsIndividualTestersGetToManyRelationshipParams) error

	// (POST /v1/builds/{id}/relationships/individualTesters)
	BuildsIndividualTestersCreateToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/bundleIdCapabilities)
	BundleIdCapabilitiesCreateInstance(ctx echo.Context) error

	// (DELETE /v1/bundleIdCapabilities/{id})
	BundleIdCapabilitiesDeleteInstance(ctx echo.Context, id string) error

	// (PATCH /v1/bundleIdCapabilities/{id})
	BundleIdCapabilitiesUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/bundleIds)
	BundleIdsGetCollection(ctx echo.Context, params BundleIdsGetCollectionParams) error

	// (POST /v1/bundleIds)
	BundleIdsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/bundleIds/{id})
	BundleIdsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/bundleIds/{id})
	BundleIdsGetInstance(ctx echo.Context, id string, params BundleIdsGetInstanceParams) error

	// (PATCH /v1/bundleIds/{id})
	BundleIdsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/bundleIds/{id}/app)
	BundleIdsAppGetToOneRelated(ctx echo.Context, id string, params BundleIdsAppGetToOneRelatedParams) error

	// (GET /v1/bundleIds/{id}/bundleIdCapabilities)
	BundleIdsBundleIdCapabilitiesGetToManyRelated(ctx echo.Context, id string, params BundleIdsBundleIdCapabilitiesGetToManyRelatedParams) error

	// (GET /v1/bundleIds/{id}/profiles)
	BundleIdsProfilesGetToManyRelated(ctx echo.Context, id string, params BundleIdsProfilesGetToManyRelatedParams) error

	// (GET /v1/certificates)
	CertificatesGetCollection(ctx echo.Context, params CertificatesGetCollectionParams) error

	// (POST /v1/certificates)
	CertificatesCreateInstance(ctx echo.Context) error

	// (DELETE /v1/certificates/{id})
	CertificatesDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/certificates/{id})
	CertificatesGetInstance(ctx echo.Context, id string, params CertificatesGetInstanceParams) error

	// (GET /v1/devices)
	DevicesGetCollection(ctx echo.Context, params DevicesGetCollectionParams) error

	// (POST /v1/devices)
	DevicesCreateInstance(ctx echo.Context) error

	// (GET /v1/devices/{id})
	DevicesGetInstance(ctx echo.Context, id string, params DevicesGetInstanceParams) error

	// (PATCH /v1/devices/{id})
	DevicesUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/diagnosticSignatures/{id}/logs)
	DiagnosticSignaturesLogsGetToManyRelated(ctx echo.Context, id string, params DiagnosticSignaturesLogsGetToManyRelatedParams) error

	// (POST /v1/endUserLicenseAgreements)
	EndUserLicenseAgreementsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/endUserLicenseAgreements/{id})
	EndUserLicenseAgreementsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/endUserLicenseAgreements/{id})
	EndUserLicenseAgreementsGetInstance(ctx echo.Context, id string, params EndUserLicenseAgreementsGetInstanceParams) error

	// (PATCH /v1/endUserLicenseAgreements/{id})
	EndUserLicenseAgreementsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/endUserLicenseAgreements/{id}/territories)
	EndUserLicenseAgreementsTerritoriesGetToManyRelated(ctx echo.Context, id string, params EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams) error

	// (GET /v1/financeReports)
	FinanceReportsGetCollection(ctx echo.Context, params FinanceReportsGetCollectionParams) error

	// (GET /v1/gameCenterEnabledVersions/{id}/compatibleVersions)
	GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(ctx echo.Context, id string, params GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams) error

	// (DELETE /v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions)
	GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions)
	GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(ctx echo.Context, id string, params GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams) error

	// (PATCH /v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions)
	GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions)
	GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/idfaDeclarations)
	IdfaDeclarationsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/idfaDeclarations/{id})
	IdfaDeclarationsDeleteInstance(ctx echo.Context, id string) error

	// (PATCH /v1/idfaDeclarations/{id})
	IdfaDeclarationsUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/inAppPurchases/{id})
	InAppPurchasesGetInstance(ctx echo.Context, id string, params InAppPurchasesGetInstanceParams) error

	// (GET /v1/preReleaseVersions)
	PreReleaseVersionsGetCollection(ctx echo.Context, params PreReleaseVersionsGetCollectionParams) error

	// (GET /v1/preReleaseVersions/{id})
	PreReleaseVersionsGetInstance(ctx echo.Context, id string, params PreReleaseVersionsGetInstanceParams) error

	// (GET /v1/preReleaseVersions/{id}/app)
	PreReleaseVersionsAppGetToOneRelated(ctx echo.Context, id string, params PreReleaseVersionsAppGetToOneRelatedParams) error

	// (GET /v1/preReleaseVersions/{id}/builds)
	PreReleaseVersionsBuildsGetToManyRelated(ctx echo.Context, id string, params PreReleaseVersionsBuildsGetToManyRelatedParams) error

	// (GET /v1/profiles)
	ProfilesGetCollection(ctx echo.Context, params ProfilesGetCollectionParams) error

	// (POST /v1/profiles)
	ProfilesCreateInstance(ctx echo.Context) error

	// (DELETE /v1/profiles/{id})
	ProfilesDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/profiles/{id})
	ProfilesGetInstance(ctx echo.Context, id string, params ProfilesGetInstanceParams) error

	// (GET /v1/profiles/{id}/bundleId)
	ProfilesBundleIdGetToOneRelated(ctx echo.Context, id string, params ProfilesBundleIdGetToOneRelatedParams) error

	// (GET /v1/profiles/{id}/certificates)
	ProfilesCertificatesGetToManyRelated(ctx echo.Context, id string, params ProfilesCertificatesGetToManyRelatedParams) error

	// (GET /v1/profiles/{id}/devices)
	ProfilesDevicesGetToManyRelated(ctx echo.Context, id string, params ProfilesDevicesGetToManyRelatedParams) error

	// (POST /v1/routingAppCoverages)
	RoutingAppCoveragesCreateInstance(ctx echo.Context) error

	// (DELETE /v1/routingAppCoverages/{id})
	RoutingAppCoveragesDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/routingAppCoverages/{id})
	RoutingAppCoveragesGetInstance(ctx echo.Context, id string, params RoutingAppCoveragesGetInstanceParams) error

	// (PATCH /v1/routingAppCoverages/{id})
	RoutingAppCoveragesUpdateInstance(ctx echo.Context, id string) error

	// (GET /v1/salesReports)
	SalesReportsGetCollection(ctx echo.Context, params SalesReportsGetCollectionParams) error

	// (GET /v1/territories)
	TerritoriesGetCollection(ctx echo.Context, params TerritoriesGetCollectionParams) error

	// (GET /v1/userInvitations)
	UserInvitationsGetCollection(ctx echo.Context, params UserInvitationsGetCollectionParams) error

	// (POST /v1/userInvitations)
	UserInvitationsCreateInstance(ctx echo.Context) error

	// (DELETE /v1/userInvitations/{id})
	UserInvitationsDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/userInvitations/{id})
	UserInvitationsGetInstance(ctx echo.Context, id string, params UserInvitationsGetInstanceParams) error

	// (GET /v1/userInvitations/{id}/visibleApps)
	UserInvitationsVisibleAppsGetToManyRelated(ctx echo.Context, id string, params UserInvitationsVisibleAppsGetToManyRelatedParams) error

	// (GET /v1/users)
	UsersGetCollection(ctx echo.Context, params UsersGetCollectionParams) error

	// (DELETE /v1/users/{id})
	UsersDeleteInstance(ctx echo.Context, id string) error

	// (GET /v1/users/{id})
	UsersGetInstance(ctx echo.Context, id string, params UsersGetInstanceParams) error

	// (PATCH /v1/users/{id})
	UsersUpdateInstance(ctx echo.Context, id string) error

	// (DELETE /v1/users/{id}/relationships/visibleApps)
	UsersVisibleAppsDeleteToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/users/{id}/relationships/visibleApps)
	UsersVisibleAppsGetToManyRelationship(ctx echo.Context, id string, params UsersVisibleAppsGetToManyRelationshipParams) error

	// (PATCH /v1/users/{id}/relationships/visibleApps)
	UsersVisibleAppsReplaceToManyRelationship(ctx echo.Context, id string) error

	// (POST /v1/users/{id}/relationships/visibleApps)
	UsersVisibleAppsCreateToManyRelationship(ctx echo.Context, id string) error

	// (GET /v1/users/{id}/visibleApps)
	UsersVisibleAppsGetToManyRelated(ctx echo.Context, id string, params UsersVisibleAppsGetToManyRelatedParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AgeRatingDeclarationsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AgeRatingDeclarationsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AgeRatingDeclarationsUpdateInstance(ctx, id)
	return err
}

// AppCategoriesGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) AppCategoriesGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppCategoriesGetCollectionParams
	// ------------- Optional query parameter "filter[platforms]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platforms]", ctx.QueryParams(), &params.FilterPlatforms)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platforms]: %s", err))
	}

	// ------------- Optional query parameter "exists[parent]" -------------

	err = runtime.BindQueryParameter("form", false, false, "exists[parent]", ctx.QueryParams(), &params.ExistsParent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exists[parent]: %s", err))
	}

	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "limit[subcategories]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[subcategories]", ctx.QueryParams(), &params.LimitSubcategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[subcategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppCategoriesGetCollection(ctx, params)
	return err
}

// AppCategoriesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppCategoriesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppCategoriesGetInstanceParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "limit[subcategories]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[subcategories]", ctx.QueryParams(), &params.LimitSubcategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[subcategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppCategoriesGetInstance(ctx, id, params)
	return err
}

// AppCategoriesParentGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppCategoriesParentGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppCategoriesParentGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppCategoriesParentGetToOneRelated(ctx, id, params)
	return err
}

// AppCategoriesSubcategoriesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppCategoriesSubcategoriesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppCategoriesSubcategoriesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppCategoriesSubcategoriesGetToManyRelated(ctx, id, params)
	return err
}

// AppEncryptionDeclarationsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) AppEncryptionDeclarationsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppEncryptionDeclarationsGetCollectionParams
	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "filter[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[builds]", ctx.QueryParams(), &params.FilterBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[appEncryptionDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appEncryptionDeclarations]", ctx.QueryParams(), &params.FieldsAppEncryptionDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appEncryptionDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppEncryptionDeclarationsGetCollection(ctx, params)
	return err
}

// AppEncryptionDeclarationsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppEncryptionDeclarationsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppEncryptionDeclarationsGetInstanceParams
	// ------------- Optional query parameter "fields[appEncryptionDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appEncryptionDeclarations]", ctx.QueryParams(), &params.FieldsAppEncryptionDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appEncryptionDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppEncryptionDeclarationsGetInstance(ctx, id, params)
	return err
}

// AppEncryptionDeclarationsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppEncryptionDeclarationsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppEncryptionDeclarationsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppEncryptionDeclarationsAppGetToOneRelated(ctx, id, params)
	return err
}

// AppEncryptionDeclarationsBuildsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppEncryptionDeclarationsBuildsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppEncryptionDeclarationsBuildsCreateToManyRelationship(ctx, id)
	return err
}

// AppInfoLocalizationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfoLocalizationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfoLocalizationsCreateInstance(ctx)
	return err
}

// AppInfoLocalizationsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfoLocalizationsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfoLocalizationsDeleteInstance(ctx, id)
	return err
}

// AppInfoLocalizationsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfoLocalizationsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfoLocalizationsGetInstanceParams
	// ------------- Optional query parameter "fields[appInfoLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfoLocalizations]", ctx.QueryParams(), &params.FieldsAppInfoLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfoLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfoLocalizationsGetInstance(ctx, id, params)
	return err
}

// AppInfoLocalizationsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfoLocalizationsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfoLocalizationsUpdateInstance(ctx, id)
	return err
}

// AppInfosGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosGetInstanceParams
	// ------------- Optional query parameter "fields[appInfos]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfos]", ctx.QueryParams(), &params.FieldsAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// ------------- Optional query parameter "fields[appInfoLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfoLocalizations]", ctx.QueryParams(), &params.FieldsAppInfoLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfoLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit[appInfoLocalizations]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appInfoLocalizations]", ctx.QueryParams(), &params.LimitAppInfoLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appInfoLocalizations]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosGetInstance(ctx, id, params)
	return err
}

// AppInfosUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosUpdateInstance(ctx, id)
	return err
}

// AppInfosAppInfoLocalizationsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosAppInfoLocalizationsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosAppInfoLocalizationsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[locale]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[locale]", ctx.QueryParams(), &params.FilterLocale)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[locale]: %s", err))
	}

	// ------------- Optional query parameter "fields[appInfos]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfos]", ctx.QueryParams(), &params.FieldsAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "fields[appInfoLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfoLocalizations]", ctx.QueryParams(), &params.FieldsAppInfoLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfoLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosAppInfoLocalizationsGetToManyRelated(ctx, id, params)
	return err
}

// AppInfosPrimaryCategoryGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosPrimaryCategoryGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosPrimaryCategoryGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosPrimaryCategoryGetToOneRelated(ctx, id, params)
	return err
}

// AppInfosPrimarySubcategoryOneGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosPrimarySubcategoryOneGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosPrimarySubcategoryOneGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosPrimarySubcategoryOneGetToOneRelated(ctx, id, params)
	return err
}

// AppInfosPrimarySubcategoryTwoGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosPrimarySubcategoryTwoGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx, id, params)
	return err
}

// AppInfosSecondaryCategoryGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosSecondaryCategoryGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosSecondaryCategoryGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosSecondaryCategoryGetToOneRelated(ctx, id, params)
	return err
}

// AppInfosSecondarySubcategoryOneGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosSecondarySubcategoryOneGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosSecondarySubcategoryOneGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosSecondarySubcategoryOneGetToOneRelated(ctx, id, params)
	return err
}

// AppInfosSecondarySubcategoryTwoGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppInfosSecondarySubcategoryTwoGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx, id, params)
	return err
}

// AppPreOrdersCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreOrdersCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreOrdersCreateInstance(ctx)
	return err
}

// AppPreOrdersDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreOrdersDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreOrdersDeleteInstance(ctx, id)
	return err
}

// AppPreOrdersGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreOrdersGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPreOrdersGetInstanceParams
	// ------------- Optional query parameter "fields[appPreOrders]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreOrders]", ctx.QueryParams(), &params.FieldsAppPreOrders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreOrders]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreOrdersGetInstance(ctx, id, params)
	return err
}

// AppPreOrdersUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreOrdersUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreOrdersUpdateInstance(ctx, id)
	return err
}

// AppPreviewSetsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewSetsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewSetsCreateInstance(ctx)
	return err
}

// AppPreviewSetsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewSetsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewSetsDeleteInstance(ctx, id)
	return err
}

// AppPreviewSetsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewSetsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPreviewSetsGetInstanceParams
	// ------------- Optional query parameter "fields[appPreviewSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviewSets]", ctx.QueryParams(), &params.FieldsAppPreviewSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviewSets]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreviews]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviews]", ctx.QueryParams(), &params.FieldsAppPreviews)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviews]: %s", err))
	}

	// ------------- Optional query parameter "limit[appPreviews]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appPreviews]", ctx.QueryParams(), &params.LimitAppPreviews)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appPreviews]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewSetsGetInstance(ctx, id, params)
	return err
}

// AppPreviewSetsAppPreviewsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewSetsAppPreviewsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPreviewSetsAppPreviewsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appPreviews]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviews]", ctx.QueryParams(), &params.FieldsAppPreviews)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviews]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreviewSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviewSets]", ctx.QueryParams(), &params.FieldsAppPreviewSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviewSets]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewSetsAppPreviewsGetToManyRelated(ctx, id, params)
	return err
}

// AppPreviewSetsAppPreviewsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewSetsAppPreviewsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPreviewSetsAppPreviewsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewSetsAppPreviewsGetToManyRelationship(ctx, id, params)
	return err
}

// AppPreviewSetsAppPreviewsReplaceToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewSetsAppPreviewsReplaceToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewSetsAppPreviewsReplaceToManyRelationship(ctx, id)
	return err
}

// AppPreviewsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewsCreateInstance(ctx)
	return err
}

// AppPreviewsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewsDeleteInstance(ctx, id)
	return err
}

// AppPreviewsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPreviewsGetInstanceParams
	// ------------- Optional query parameter "fields[appPreviews]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviews]", ctx.QueryParams(), &params.FieldsAppPreviews)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviews]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewsGetInstance(ctx, id, params)
	return err
}

// AppPreviewsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPreviewsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPreviewsUpdateInstance(ctx, id)
	return err
}

// AppPricePointsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) AppPricePointsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPricePointsGetCollectionParams
	// ------------- Optional query parameter "filter[priceTier]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[priceTier]", ctx.QueryParams(), &params.FilterPriceTier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[priceTier]: %s", err))
	}

	// ------------- Optional query parameter "filter[territory]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[territory]", ctx.QueryParams(), &params.FilterTerritory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[territory]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPricePoints]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPricePoints]", ctx.QueryParams(), &params.FieldsAppPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPricePoints]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPricePointsGetCollection(ctx, params)
	return err
}

// AppPricePointsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPricePointsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPricePointsGetInstanceParams
	// ------------- Optional query parameter "fields[appPricePoints]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPricePoints]", ctx.QueryParams(), &params.FieldsAppPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPricePoints]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPricePointsGetInstance(ctx, id, params)
	return err
}

// AppPricePointsTerritoryGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppPricePointsTerritoryGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPricePointsTerritoryGetToOneRelatedParams
	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPricePointsTerritoryGetToOneRelated(ctx, id, params)
	return err
}

// AppPriceTiersGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) AppPriceTiersGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPriceTiersGetCollectionParams
	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPriceTiers]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPriceTiers]", ctx.QueryParams(), &params.FieldsAppPriceTiers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPriceTiers]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appPricePoints]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPricePoints]", ctx.QueryParams(), &params.FieldsAppPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPricePoints]: %s", err))
	}

	// ------------- Optional query parameter "limit[pricePoints]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[pricePoints]", ctx.QueryParams(), &params.LimitPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[pricePoints]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPriceTiersGetCollection(ctx, params)
	return err
}

// AppPriceTiersGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPriceTiersGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPriceTiersGetInstanceParams
	// ------------- Optional query parameter "fields[appPriceTiers]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPriceTiers]", ctx.QueryParams(), &params.FieldsAppPriceTiers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPriceTiers]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appPricePoints]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPricePoints]", ctx.QueryParams(), &params.FieldsAppPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPricePoints]: %s", err))
	}

	// ------------- Optional query parameter "limit[pricePoints]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[pricePoints]", ctx.QueryParams(), &params.LimitPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[pricePoints]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPriceTiersGetInstance(ctx, id, params)
	return err
}

// AppPriceTiersPricePointsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppPriceTiersPricePointsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPriceTiersPricePointsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appPricePoints]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPricePoints]", ctx.QueryParams(), &params.FieldsAppPricePoints)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPricePoints]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPriceTiersPricePointsGetToManyRelated(ctx, id, params)
	return err
}

// AppPricesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppPricesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppPricesGetInstanceParams
	// ------------- Optional query parameter "fields[appPrices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPrices]", ctx.QueryParams(), &params.FieldsAppPrices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPrices]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppPricesGetInstance(ctx, id, params)
	return err
}

// AppScreenshotSetsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotSetsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotSetsCreateInstance(ctx)
	return err
}

// AppScreenshotSetsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotSetsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotSetsDeleteInstance(ctx, id)
	return err
}

// AppScreenshotSetsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotSetsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppScreenshotSetsGetInstanceParams
	// ------------- Optional query parameter "fields[appScreenshotSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshotSets]", ctx.QueryParams(), &params.FieldsAppScreenshotSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshotSets]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appScreenshots]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshots]", ctx.QueryParams(), &params.FieldsAppScreenshots)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshots]: %s", err))
	}

	// ------------- Optional query parameter "limit[appScreenshots]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appScreenshots]", ctx.QueryParams(), &params.LimitAppScreenshots)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appScreenshots]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotSetsGetInstance(ctx, id, params)
	return err
}

// AppScreenshotSetsAppScreenshotsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotSetsAppScreenshotsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppScreenshotSetsAppScreenshotsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appScreenshotSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshotSets]", ctx.QueryParams(), &params.FieldsAppScreenshotSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshotSets]: %s", err))
	}

	// ------------- Optional query parameter "fields[appScreenshots]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshots]", ctx.QueryParams(), &params.FieldsAppScreenshots)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshots]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotSetsAppScreenshotsGetToManyRelated(ctx, id, params)
	return err
}

// AppScreenshotSetsAppScreenshotsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotSetsAppScreenshotsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppScreenshotSetsAppScreenshotsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotSetsAppScreenshotsGetToManyRelationship(ctx, id, params)
	return err
}

// AppScreenshotSetsAppScreenshotsReplaceToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotSetsAppScreenshotsReplaceToManyRelationship(ctx, id)
	return err
}

// AppScreenshotsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotsCreateInstance(ctx)
	return err
}

// AppScreenshotsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotsDeleteInstance(ctx, id)
	return err
}

// AppScreenshotsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppScreenshotsGetInstanceParams
	// ------------- Optional query parameter "fields[appScreenshots]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshots]", ctx.QueryParams(), &params.FieldsAppScreenshots)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshots]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotsGetInstance(ctx, id, params)
	return err
}

// AppScreenshotsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppScreenshotsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppScreenshotsUpdateInstance(ctx, id)
	return err
}

// AppStoreReviewAttachmentsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewAttachmentsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewAttachmentsCreateInstance(ctx)
	return err
}

// AppStoreReviewAttachmentsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewAttachmentsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewAttachmentsDeleteInstance(ctx, id)
	return err
}

// AppStoreReviewAttachmentsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewAttachmentsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreReviewAttachmentsGetInstanceParams
	// ------------- Optional query parameter "fields[appStoreReviewAttachments]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewAttachments]", ctx.QueryParams(), &params.FieldsAppStoreReviewAttachments)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewAttachments]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewAttachmentsGetInstance(ctx, id, params)
	return err
}

// AppStoreReviewAttachmentsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewAttachmentsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewAttachmentsUpdateInstance(ctx, id)
	return err
}

// AppStoreReviewDetailsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewDetailsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewDetailsCreateInstance(ctx)
	return err
}

// AppStoreReviewDetailsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewDetailsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreReviewDetailsGetInstanceParams
	// ------------- Optional query parameter "fields[appStoreReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewDetails]", ctx.QueryParams(), &params.FieldsAppStoreReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreReviewAttachments]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewAttachments]", ctx.QueryParams(), &params.FieldsAppStoreReviewAttachments)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewAttachments]: %s", err))
	}

	// ------------- Optional query parameter "limit[appStoreReviewAttachments]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appStoreReviewAttachments]", ctx.QueryParams(), &params.LimitAppStoreReviewAttachments)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appStoreReviewAttachments]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewDetailsGetInstance(ctx, id, params)
	return err
}

// AppStoreReviewDetailsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewDetailsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewDetailsUpdateInstance(ctx, id)
	return err
}

// AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appStoreReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewDetails]", ctx.QueryParams(), &params.FieldsAppStoreReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreReviewAttachments]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewAttachments]", ctx.QueryParams(), &params.FieldsAppStoreReviewAttachments)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewAttachments]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated(ctx, id, params)
	return err
}

// AppStoreVersionLocalizationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionLocalizationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionLocalizationsCreateInstance(ctx)
	return err
}

// AppStoreVersionLocalizationsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionLocalizationsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionLocalizationsDeleteInstance(ctx, id)
	return err
}

// AppStoreVersionLocalizationsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionLocalizationsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionLocalizationsGetInstanceParams
	// ------------- Optional query parameter "fields[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionLocalizations]", ctx.QueryParams(), &params.FieldsAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appScreenshotSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshotSets]", ctx.QueryParams(), &params.FieldsAppScreenshotSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshotSets]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreviewSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviewSets]", ctx.QueryParams(), &params.FieldsAppPreviewSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviewSets]: %s", err))
	}

	// ------------- Optional query parameter "limit[appPreviewSets]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appPreviewSets]", ctx.QueryParams(), &params.LimitAppPreviewSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appPreviewSets]: %s", err))
	}

	// ------------- Optional query parameter "limit[appScreenshotSets]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appScreenshotSets]", ctx.QueryParams(), &params.LimitAppScreenshotSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appScreenshotSets]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionLocalizationsGetInstance(ctx, id, params)
	return err
}

// AppStoreVersionLocalizationsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionLocalizationsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionLocalizationsUpdateInstance(ctx, id)
	return err
}

// AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[previewType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[previewType]", ctx.QueryParams(), &params.FilterPreviewType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[previewType]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionLocalizations]", ctx.QueryParams(), &params.FieldsAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreviews]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviews]", ctx.QueryParams(), &params.FieldsAppPreviews)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviews]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreviewSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreviewSets]", ctx.QueryParams(), &params.FieldsAppPreviewSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreviewSets]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated(ctx, id, params)
	return err
}

// AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[screenshotDisplayType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[screenshotDisplayType]", ctx.QueryParams(), &params.FilterScreenshotDisplayType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[screenshotDisplayType]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionLocalizations]", ctx.QueryParams(), &params.FieldsAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[appScreenshotSets]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshotSets]", ctx.QueryParams(), &params.FieldsAppScreenshotSets)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshotSets]: %s", err))
	}

	// ------------- Optional query parameter "fields[appScreenshots]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appScreenshots]", ctx.QueryParams(), &params.FieldsAppScreenshots)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appScreenshots]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated(ctx, id, params)
	return err
}

// AppStoreVersionPhasedReleasesCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionPhasedReleasesCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionPhasedReleasesCreateInstance(ctx)
	return err
}

// AppStoreVersionPhasedReleasesDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionPhasedReleasesDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionPhasedReleasesDeleteInstance(ctx, id)
	return err
}

// AppStoreVersionPhasedReleasesUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionPhasedReleasesUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionPhasedReleasesUpdateInstance(ctx, id)
	return err
}

// AppStoreVersionSubmissionsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionSubmissionsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionSubmissionsCreateInstance(ctx)
	return err
}

// AppStoreVersionSubmissionsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionSubmissionsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionSubmissionsDeleteInstance(ctx, id)
	return err
}

// AppStoreVersionsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsCreateInstance(ctx)
	return err
}

// AppStoreVersionsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsDeleteInstance(ctx, id)
	return err
}

// AppStoreVersionsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsGetInstanceParams
	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionLocalizations]", ctx.QueryParams(), &params.FieldsAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[idfaDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[idfaDeclarations]", ctx.QueryParams(), &params.FieldsIdfaDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[idfaDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "fields[routingAppCoverages]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[routingAppCoverages]", ctx.QueryParams(), &params.FieldsRoutingAppCoverages)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[routingAppCoverages]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionPhasedReleases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionPhasedReleases]", ctx.QueryParams(), &params.FieldsAppStoreVersionPhasedReleases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionPhasedReleases]: %s", err))
	}

	// ------------- Optional query parameter "fields[ageRatingDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[ageRatingDeclarations]", ctx.QueryParams(), &params.FieldsAgeRatingDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[ageRatingDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewDetails]", ctx.QueryParams(), &params.FieldsAppStoreReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionSubmissions]", ctx.QueryParams(), &params.FieldsAppStoreVersionSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "limit[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appStoreVersionLocalizations]", ctx.QueryParams(), &params.LimitAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appStoreVersionLocalizations]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsGetInstance(ctx, id, params)
	return err
}

// AppStoreVersionsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsUpdateInstance(ctx, id)
	return err
}

// AppStoreVersionsAgeRatingDeclarationGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsAgeRatingDeclarationGetToOneRelatedParams
	// ------------- Optional query parameter "fields[ageRatingDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[ageRatingDeclarations]", ctx.QueryParams(), &params.FieldsAgeRatingDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[ageRatingDeclarations]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsAgeRatingDeclarationGetToOneRelated(ctx, id, params)
	return err
}

// AppStoreVersionsAppStoreReviewDetailGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsAppStoreReviewDetailGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appStoreReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewDetails]", ctx.QueryParams(), &params.FieldsAppStoreReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreReviewAttachments]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewAttachments]", ctx.QueryParams(), &params.FieldsAppStoreReviewAttachments)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewAttachments]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsAppStoreReviewDetailGetToOneRelated(ctx, id, params)
	return err
}

// AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionLocalizations]", ctx.QueryParams(), &params.FieldsAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated(ctx, id, params)
	return err
}

// AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appStoreVersionPhasedReleases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionPhasedReleases]", ctx.QueryParams(), &params.FieldsAppStoreVersionPhasedReleases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionPhasedReleases]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated(ctx, id, params)
	return err
}

// AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsAppStoreVersionSubmissionGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionSubmissions]", ctx.QueryParams(), &params.FieldsAppStoreVersionSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated(ctx, id, params)
	return err
}

// AppStoreVersionsBuildGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsBuildGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsBuildGetToOneRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsBuildGetToOneRelated(ctx, id, params)
	return err
}

// AppStoreVersionsIdfaDeclarationGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsIdfaDeclarationGetToOneRelatedParams
	// ------------- Optional query parameter "fields[idfaDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[idfaDeclarations]", ctx.QueryParams(), &params.FieldsIdfaDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[idfaDeclarations]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsIdfaDeclarationGetToOneRelated(ctx, id, params)
	return err
}

// AppStoreVersionsBuildGetToOneRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsBuildGetToOneRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsBuildGetToOneRelationship(ctx, id)
	return err
}

// AppStoreVersionsBuildUpdateToOneRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsBuildUpdateToOneRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsBuildUpdateToOneRelationship(ctx, id)
	return err
}

// AppStoreVersionsRoutingAppCoverageGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppStoreVersionsRoutingAppCoverageGetToOneRelatedParams
	// ------------- Optional query parameter "fields[routingAppCoverages]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[routingAppCoverages]", ctx.QueryParams(), &params.FieldsRoutingAppCoverages)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[routingAppCoverages]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppStoreVersionsRoutingAppCoverageGetToOneRelated(ctx, id, params)
	return err
}

// AppsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) AppsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsGetCollectionParams
	// ------------- Optional query parameter "filter[appStoreVersions.appStoreState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[appStoreVersions.appStoreState]", ctx.QueryParams(), &params.FilterAppStoreVersionsAppStoreState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[appStoreVersions.appStoreState]: %s", err))
	}

	// ------------- Optional query parameter "filter[appStoreVersions.platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[appStoreVersions.platform]", ctx.QueryParams(), &params.FilterAppStoreVersionsPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[appStoreVersions.platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[bundleId]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[bundleId]", ctx.QueryParams(), &params.FilterBundleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[bundleId]: %s", err))
	}

	// ------------- Optional query parameter "filter[name]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[name]", ctx.QueryParams(), &params.FilterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[name]: %s", err))
	}

	// ------------- Optional query parameter "filter[sku]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[sku]", ctx.QueryParams(), &params.FilterSku)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[sku]: %s", err))
	}

	// ------------- Optional query parameter "filter[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[appStoreVersions]", ctx.QueryParams(), &params.FilterAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "exists[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "exists[gameCenterEnabledVersions]", ctx.QueryParams(), &params.ExistsGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exists[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "fields[perfPowerMetrics]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[perfPowerMetrics]", ctx.QueryParams(), &params.FieldsPerfPowerMetrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[perfPowerMetrics]: %s", err))
	}

	// ------------- Optional query parameter "fields[appInfos]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfos]", ctx.QueryParams(), &params.FieldsAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreOrders]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreOrders]", ctx.QueryParams(), &params.FieldsAppPreOrders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreOrders]: %s", err))
	}

	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPrices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPrices]", ctx.QueryParams(), &params.FieldsAppPrices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPrices]: %s", err))
	}

	// ------------- Optional query parameter "fields[inAppPurchases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[inAppPurchases]", ctx.QueryParams(), &params.FieldsInAppPurchases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[inAppPurchases]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewDetails]", ctx.QueryParams(), &params.FieldsBetaAppReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// ------------- Optional query parameter "fields[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[gameCenterEnabledVersions]", ctx.QueryParams(), &params.FieldsGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppLocalizations]", ctx.QueryParams(), &params.FieldsBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaLicenseAgreements]", ctx.QueryParams(), &params.FieldsBetaLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "fields[endUserLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[endUserLicenseAgreements]", ctx.QueryParams(), &params.FieldsEndUserLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[endUserLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "limit[appInfos]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appInfos]", ctx.QueryParams(), &params.LimitAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "limit[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appStoreVersions]", ctx.QueryParams(), &params.LimitAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit[availableTerritories]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[availableTerritories]", ctx.QueryParams(), &params.LimitAvailableTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[availableTerritories]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaAppLocalizations]", ctx.QueryParams(), &params.LimitBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaGroups]", ctx.QueryParams(), &params.LimitBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[gameCenterEnabledVersions]", ctx.QueryParams(), &params.LimitGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit[inAppPurchases]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[inAppPurchases]", ctx.QueryParams(), &params.LimitInAppPurchases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[inAppPurchases]: %s", err))
	}

	// ------------- Optional query parameter "limit[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[preReleaseVersions]", ctx.QueryParams(), &params.LimitPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit[prices]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[prices]", ctx.QueryParams(), &params.LimitPrices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[prices]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsGetCollection(ctx, params)
	return err
}

// AppsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsGetInstanceParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "fields[perfPowerMetrics]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[perfPowerMetrics]", ctx.QueryParams(), &params.FieldsPerfPowerMetrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[perfPowerMetrics]: %s", err))
	}

	// ------------- Optional query parameter "fields[appInfos]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfos]", ctx.QueryParams(), &params.FieldsAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPreOrders]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreOrders]", ctx.QueryParams(), &params.FieldsAppPreOrders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreOrders]: %s", err))
	}

	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPrices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPrices]", ctx.QueryParams(), &params.FieldsAppPrices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPrices]: %s", err))
	}

	// ------------- Optional query parameter "fields[inAppPurchases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[inAppPurchases]", ctx.QueryParams(), &params.FieldsInAppPurchases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[inAppPurchases]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewDetails]", ctx.QueryParams(), &params.FieldsBetaAppReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// ------------- Optional query parameter "fields[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[gameCenterEnabledVersions]", ctx.QueryParams(), &params.FieldsGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppLocalizations]", ctx.QueryParams(), &params.FieldsBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaLicenseAgreements]", ctx.QueryParams(), &params.FieldsBetaLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "fields[endUserLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[endUserLicenseAgreements]", ctx.QueryParams(), &params.FieldsEndUserLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[endUserLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "limit[appInfos]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appInfos]", ctx.QueryParams(), &params.LimitAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "limit[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[appStoreVersions]", ctx.QueryParams(), &params.LimitAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit[availableTerritories]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[availableTerritories]", ctx.QueryParams(), &params.LimitAvailableTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[availableTerritories]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaAppLocalizations]", ctx.QueryParams(), &params.LimitBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaGroups]", ctx.QueryParams(), &params.LimitBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[gameCenterEnabledVersions]", ctx.QueryParams(), &params.LimitGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit[inAppPurchases]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[inAppPurchases]", ctx.QueryParams(), &params.LimitInAppPurchases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[inAppPurchases]: %s", err))
	}

	// ------------- Optional query parameter "limit[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[preReleaseVersions]", ctx.QueryParams(), &params.LimitPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit[prices]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[prices]", ctx.QueryParams(), &params.LimitPrices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[prices]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsGetInstance(ctx, id, params)
	return err
}

// AppsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) AppsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsUpdateInstance(ctx, id)
	return err
}

// AppsAppInfosGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsAppInfosGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsAppInfosGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appInfos]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfos]", ctx.QueryParams(), &params.FieldsAppInfos)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfos]: %s", err))
	}

	// ------------- Optional query parameter "fields[appCategories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appCategories]", ctx.QueryParams(), &params.FieldsAppCategories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appCategories]: %s", err))
	}

	// ------------- Optional query parameter "fields[appInfoLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appInfoLocalizations]", ctx.QueryParams(), &params.FieldsAppInfoLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appInfoLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsAppInfosGetToManyRelated(ctx, id, params)
	return err
}

// AppsAppStoreVersionsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsAppStoreVersionsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsAppStoreVersionsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[appStoreState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[appStoreState]", ctx.QueryParams(), &params.FilterAppStoreState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[appStoreState]: %s", err))
	}

	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[versionString]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[versionString]", ctx.QueryParams(), &params.FilterVersionString)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[versionString]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "fields[idfaDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[idfaDeclarations]", ctx.QueryParams(), &params.FieldsIdfaDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[idfaDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionLocalizations]", ctx.QueryParams(), &params.FieldsAppStoreVersionLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[routingAppCoverages]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[routingAppCoverages]", ctx.QueryParams(), &params.FieldsRoutingAppCoverages)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[routingAppCoverages]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionPhasedReleases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionPhasedReleases]", ctx.QueryParams(), &params.FieldsAppStoreVersionPhasedReleases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionPhasedReleases]: %s", err))
	}

	// ------------- Optional query parameter "fields[ageRatingDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[ageRatingDeclarations]", ctx.QueryParams(), &params.FieldsAgeRatingDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[ageRatingDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreReviewDetails]", ctx.QueryParams(), &params.FieldsAppStoreReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersionSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersionSubmissions]", ctx.QueryParams(), &params.FieldsAppStoreVersionSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersionSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsAppStoreVersionsGetToManyRelated(ctx, id, params)
	return err
}

// AppsAvailableTerritoriesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsAvailableTerritoriesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsAvailableTerritoriesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsAvailableTerritoriesGetToManyRelated(ctx, id, params)
	return err
}

// AppsBetaAppLocalizationsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsBetaAppLocalizationsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsBetaAppLocalizationsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppLocalizations]", ctx.QueryParams(), &params.FieldsBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsBetaAppLocalizationsGetToManyRelated(ctx, id, params)
	return err
}

// AppsBetaAppReviewDetailGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsBetaAppReviewDetailGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsBetaAppReviewDetailGetToOneRelatedParams
	// ------------- Optional query parameter "fields[betaAppReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewDetails]", ctx.QueryParams(), &params.FieldsBetaAppReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewDetails]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsBetaAppReviewDetailGetToOneRelated(ctx, id, params)
	return err
}

// AppsBetaGroupsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsBetaGroupsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsBetaGroupsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsBetaGroupsGetToManyRelated(ctx, id, params)
	return err
}

// AppsBetaLicenseAgreementGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsBetaLicenseAgreementGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsBetaLicenseAgreementGetToOneRelatedParams
	// ------------- Optional query parameter "fields[betaLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaLicenseAgreements]", ctx.QueryParams(), &params.FieldsBetaLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaLicenseAgreements]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsBetaLicenseAgreementGetToOneRelated(ctx, id, params)
	return err
}

// AppsBuildsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsBuildsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsBuildsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsBuildsGetToManyRelated(ctx, id, params)
	return err
}

// AppsEndUserLicenseAgreementGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsEndUserLicenseAgreementGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsEndUserLicenseAgreementGetToOneRelatedParams
	// ------------- Optional query parameter "fields[endUserLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[endUserLicenseAgreements]", ctx.QueryParams(), &params.FieldsEndUserLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[endUserLicenseAgreements]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsEndUserLicenseAgreementGetToOneRelated(ctx, id, params)
	return err
}

// AppsGameCenterEnabledVersionsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsGameCenterEnabledVersionsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsGameCenterEnabledVersionsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[versionString]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[versionString]", ctx.QueryParams(), &params.FilterVersionString)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[versionString]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[gameCenterEnabledVersions]", ctx.QueryParams(), &params.FieldsGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsGameCenterEnabledVersionsGetToManyRelated(ctx, id, params)
	return err
}

// AppsInAppPurchasesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsInAppPurchasesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsInAppPurchasesGetToManyRelatedParams
	// ------------- Optional query parameter "filter[inAppPurchaseType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[inAppPurchaseType]", ctx.QueryParams(), &params.FilterInAppPurchaseType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[inAppPurchaseType]: %s", err))
	}

	// ------------- Optional query parameter "filter[canBeSubmitted]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[canBeSubmitted]", ctx.QueryParams(), &params.FilterCanBeSubmitted)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[canBeSubmitted]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[inAppPurchases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[inAppPurchases]", ctx.QueryParams(), &params.FieldsInAppPurchases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[inAppPurchases]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsInAppPurchasesGetToManyRelated(ctx, id, params)
	return err
}

// AppsPerfPowerMetricsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsPerfPowerMetricsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsPerfPowerMetricsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[deviceType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[deviceType]", ctx.QueryParams(), &params.FilterDeviceType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[deviceType]: %s", err))
	}

	// ------------- Optional query parameter "filter[metricType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[metricType]", ctx.QueryParams(), &params.FilterMetricType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[metricType]: %s", err))
	}

	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsPerfPowerMetricsGetToManyRelated(ctx, id, params)
	return err
}

// AppsPreOrderGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsPreOrderGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsPreOrderGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appPreOrders]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPreOrders]", ctx.QueryParams(), &params.FieldsAppPreOrders)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPreOrders]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsPreOrderGetToOneRelated(ctx, id, params)
	return err
}

// AppsPreReleaseVersionsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsPreReleaseVersionsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsPreReleaseVersionsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsPreReleaseVersionsGetToManyRelated(ctx, id, params)
	return err
}

// AppsPricesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) AppsPricesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AppsPricesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[appPrices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPrices]", ctx.QueryParams(), &params.FieldsAppPrices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPrices]: %s", err))
	}

	// ------------- Optional query parameter "fields[appPriceTiers]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appPriceTiers]", ctx.QueryParams(), &params.FieldsAppPriceTiers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appPriceTiers]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsPricesGetToManyRelated(ctx, id, params)
	return err
}

// AppsBetaTestersDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) AppsBetaTestersDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AppsBetaTestersDeleteToManyRelationship(ctx, id)
	return err
}

// BetaAppLocalizationsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppLocalizationsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppLocalizationsGetCollectionParams
	// ------------- Optional query parameter "filter[locale]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[locale]", ctx.QueryParams(), &params.FilterLocale)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[locale]: %s", err))
	}

	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppLocalizations]", ctx.QueryParams(), &params.FieldsBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppLocalizationsGetCollection(ctx, params)
	return err
}

// BetaAppLocalizationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppLocalizationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppLocalizationsCreateInstance(ctx)
	return err
}

// BetaAppLocalizationsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppLocalizationsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppLocalizationsDeleteInstance(ctx, id)
	return err
}

// BetaAppLocalizationsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppLocalizationsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppLocalizationsGetInstanceParams
	// ------------- Optional query parameter "fields[betaAppLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppLocalizations]", ctx.QueryParams(), &params.FieldsBetaAppLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppLocalizationsGetInstance(ctx, id, params)
	return err
}

// BetaAppLocalizationsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppLocalizationsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppLocalizationsUpdateInstance(ctx, id)
	return err
}

// BetaAppLocalizationsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppLocalizationsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppLocalizationsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppLocalizationsAppGetToOneRelated(ctx, id, params)
	return err
}

// BetaAppReviewDetailsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewDetailsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppReviewDetailsGetCollectionParams
	// ------------- Required query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewDetails]", ctx.QueryParams(), &params.FieldsBetaAppReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewDetailsGetCollection(ctx, params)
	return err
}

// BetaAppReviewDetailsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewDetailsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppReviewDetailsGetInstanceParams
	// ------------- Optional query parameter "fields[betaAppReviewDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewDetails]", ctx.QueryParams(), &params.FieldsBetaAppReviewDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewDetails]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewDetailsGetInstance(ctx, id, params)
	return err
}

// BetaAppReviewDetailsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewDetailsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewDetailsUpdateInstance(ctx, id)
	return err
}

// BetaAppReviewDetailsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewDetailsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppReviewDetailsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewDetailsAppGetToOneRelated(ctx, id, params)
	return err
}

// BetaAppReviewSubmissionsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewSubmissionsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppReviewSubmissionsGetCollectionParams
	// ------------- Optional query parameter "filter[betaReviewState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[betaReviewState]", ctx.QueryParams(), &params.FilterBetaReviewState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[betaReviewState]: %s", err))
	}

	// ------------- Required query parameter "filter[build]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[build]", ctx.QueryParams(), &params.FilterBuild)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[build]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppReviewSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewSubmissions]", ctx.QueryParams(), &params.FieldsBetaAppReviewSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewSubmissionsGetCollection(ctx, params)
	return err
}

// BetaAppReviewSubmissionsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewSubmissionsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewSubmissionsCreateInstance(ctx)
	return err
}

// BetaAppReviewSubmissionsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewSubmissionsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppReviewSubmissionsGetInstanceParams
	// ------------- Optional query parameter "fields[betaAppReviewSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewSubmissions]", ctx.QueryParams(), &params.FieldsBetaAppReviewSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewSubmissionsGetInstance(ctx, id, params)
	return err
}

// BetaAppReviewSubmissionsBuildGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaAppReviewSubmissionsBuildGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaAppReviewSubmissionsBuildGetToOneRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaAppReviewSubmissionsBuildGetToOneRelated(ctx, id, params)
	return err
}

// BetaBuildLocalizationsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaBuildLocalizationsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaBuildLocalizationsGetCollectionParams
	// ------------- Optional query parameter "filter[locale]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[locale]", ctx.QueryParams(), &params.FilterLocale)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[locale]: %s", err))
	}

	// ------------- Optional query parameter "filter[build]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[build]", ctx.QueryParams(), &params.FilterBuild)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[build]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaBuildLocalizations]", ctx.QueryParams(), &params.FieldsBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaBuildLocalizationsGetCollection(ctx, params)
	return err
}

// BetaBuildLocalizationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaBuildLocalizationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaBuildLocalizationsCreateInstance(ctx)
	return err
}

// BetaBuildLocalizationsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaBuildLocalizationsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaBuildLocalizationsDeleteInstance(ctx, id)
	return err
}

// BetaBuildLocalizationsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaBuildLocalizationsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaBuildLocalizationsGetInstanceParams
	// ------------- Optional query parameter "fields[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaBuildLocalizations]", ctx.QueryParams(), &params.FieldsBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaBuildLocalizationsGetInstance(ctx, id, params)
	return err
}

// BetaBuildLocalizationsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaBuildLocalizationsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaBuildLocalizationsUpdateInstance(ctx, id)
	return err
}

// BetaBuildLocalizationsBuildGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaBuildLocalizationsBuildGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaBuildLocalizationsBuildGetToOneRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaBuildLocalizationsBuildGetToOneRelated(ctx, id, params)
	return err
}

// BetaGroupsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsGetCollectionParams
	// ------------- Optional query parameter "filter[isInternalGroup]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[isInternalGroup]", ctx.QueryParams(), &params.FilterIsInternalGroup)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[isInternalGroup]: %s", err))
	}

	// ------------- Optional query parameter "filter[name]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[name]", ctx.QueryParams(), &params.FilterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[name]: %s", err))
	}

	// ------------- Optional query parameter "filter[publicLink]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[publicLink]", ctx.QueryParams(), &params.FilterPublicLink)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[publicLink]: %s", err))
	}

	// ------------- Optional query parameter "filter[publicLinkEnabled]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[publicLinkEnabled]", ctx.QueryParams(), &params.FilterPublicLinkEnabled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[publicLinkEnabled]: %s", err))
	}

	// ------------- Optional query parameter "filter[publicLinkLimitEnabled]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[publicLinkLimitEnabled]", ctx.QueryParams(), &params.FilterPublicLinkLimitEnabled)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[publicLinkLimitEnabled]: %s", err))
	}

	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "filter[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[builds]", ctx.QueryParams(), &params.FilterBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[builds]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaTesters]", ctx.QueryParams(), &params.LimitBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsGetCollection(ctx, params)
	return err
}

// BetaGroupsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsCreateInstance(ctx)
	return err
}

// BetaGroupsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsDeleteInstance(ctx, id)
	return err
}

// BetaGroupsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsGetInstanceParams
	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaTesters]", ctx.QueryParams(), &params.LimitBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsGetInstance(ctx, id, params)
	return err
}

// BetaGroupsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsUpdateInstance(ctx, id)
	return err
}

// BetaGroupsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsAppGetToOneRelated(ctx, id, params)
	return err
}

// BetaGroupsBetaTestersGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBetaTestersGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsBetaTestersGetToManyRelatedParams
	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBetaTestersGetToManyRelated(ctx, id, params)
	return err
}

// BetaGroupsBuildsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBuildsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsBuildsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBuildsGetToManyRelated(ctx, id, params)
	return err
}

// BetaGroupsBetaTestersDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBetaTestersDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBetaTestersDeleteToManyRelationship(ctx, id)
	return err
}

// BetaGroupsBetaTestersGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBetaTestersGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsBetaTestersGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBetaTestersGetToManyRelationship(ctx, id, params)
	return err
}

// BetaGroupsBetaTestersCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBetaTestersCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBetaTestersCreateToManyRelationship(ctx, id)
	return err
}

// BetaGroupsBuildsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBuildsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBuildsDeleteToManyRelationship(ctx, id)
	return err
}

// BetaGroupsBuildsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBuildsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaGroupsBuildsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBuildsGetToManyRelationship(ctx, id, params)
	return err
}

// BetaGroupsBuildsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaGroupsBuildsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaGroupsBuildsCreateToManyRelationship(ctx, id)
	return err
}

// BetaLicenseAgreementsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaLicenseAgreementsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaLicenseAgreementsGetCollectionParams
	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaLicenseAgreements]", ctx.QueryParams(), &params.FieldsBetaLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaLicenseAgreementsGetCollection(ctx, params)
	return err
}

// BetaLicenseAgreementsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaLicenseAgreementsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaLicenseAgreementsGetInstanceParams
	// ------------- Optional query parameter "fields[betaLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaLicenseAgreements]", ctx.QueryParams(), &params.FieldsBetaLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaLicenseAgreementsGetInstance(ctx, id, params)
	return err
}

// BetaLicenseAgreementsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaLicenseAgreementsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaLicenseAgreementsUpdateInstance(ctx, id)
	return err
}

// BetaLicenseAgreementsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaLicenseAgreementsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaLicenseAgreementsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaLicenseAgreementsAppGetToOneRelated(ctx, id, params)
	return err
}

// BetaTesterInvitationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTesterInvitationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTesterInvitationsCreateInstance(ctx)
	return err
}

// BetaTestersGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersGetCollectionParams
	// ------------- Optional query parameter "filter[email]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[email]", ctx.QueryParams(), &params.FilterEmail)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[email]: %s", err))
	}

	// ------------- Optional query parameter "filter[firstName]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[firstName]", ctx.QueryParams(), &params.FilterFirstName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[firstName]: %s", err))
	}

	// ------------- Optional query parameter "filter[inviteType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[inviteType]", ctx.QueryParams(), &params.FilterInviteType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[inviteType]: %s", err))
	}

	// ------------- Optional query parameter "filter[lastName]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[lastName]", ctx.QueryParams(), &params.FilterLastName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[lastName]: %s", err))
	}

	// ------------- Optional query parameter "filter[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[apps]", ctx.QueryParams(), &params.FilterApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[apps]: %s", err))
	}

	// ------------- Optional query parameter "filter[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[betaGroups]", ctx.QueryParams(), &params.FilterBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "filter[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[builds]", ctx.QueryParams(), &params.FilterBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[builds]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[apps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[apps]", ctx.QueryParams(), &params.LimitApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaGroups]", ctx.QueryParams(), &params.LimitBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersGetCollection(ctx, params)
	return err
}

// BetaTestersCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersCreateInstance(ctx)
	return err
}

// BetaTestersDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersDeleteInstance(ctx, id)
	return err
}

// BetaTestersGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersGetInstanceParams
	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[apps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[apps]", ctx.QueryParams(), &params.LimitApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaGroups]", ctx.QueryParams(), &params.LimitBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersGetInstance(ctx, id, params)
	return err
}

// BetaTestersAppsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersAppsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersAppsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersAppsGetToManyRelated(ctx, id, params)
	return err
}

// BetaTestersBetaGroupsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBetaGroupsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersBetaGroupsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaGroups]", ctx.QueryParams(), &params.FieldsBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBetaGroupsGetToManyRelated(ctx, id, params)
	return err
}

// BetaTestersBuildsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBuildsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersBuildsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBuildsGetToManyRelated(ctx, id, params)
	return err
}

// BetaTestersAppsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersAppsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersAppsDeleteToManyRelationship(ctx, id)
	return err
}

// BetaTestersAppsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersAppsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersAppsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersAppsGetToManyRelationship(ctx, id, params)
	return err
}

// BetaTestersBetaGroupsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBetaGroupsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBetaGroupsDeleteToManyRelationship(ctx, id)
	return err
}

// BetaTestersBetaGroupsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBetaGroupsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersBetaGroupsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBetaGroupsGetToManyRelationship(ctx, id, params)
	return err
}

// BetaTestersBetaGroupsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBetaGroupsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBetaGroupsCreateToManyRelationship(ctx, id)
	return err
}

// BetaTestersBuildsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBuildsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBuildsDeleteToManyRelationship(ctx, id)
	return err
}

// BetaTestersBuildsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBuildsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BetaTestersBuildsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBuildsGetToManyRelationship(ctx, id, params)
	return err
}

// BetaTestersBuildsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BetaTestersBuildsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BetaTestersBuildsCreateToManyRelationship(ctx, id)
	return err
}

// BuildBetaDetailsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BuildBetaDetailsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildBetaDetailsGetCollectionParams
	// ------------- Optional query parameter "filter[build]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[build]", ctx.QueryParams(), &params.FilterBuild)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[build]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "fields[buildBetaDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildBetaDetails]", ctx.QueryParams(), &params.FieldsBuildBetaDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildBetaDetails]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildBetaDetailsGetCollection(ctx, params)
	return err
}

// BuildBetaDetailsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BuildBetaDetailsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildBetaDetailsGetInstanceParams
	// ------------- Optional query parameter "fields[buildBetaDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildBetaDetails]", ctx.QueryParams(), &params.FieldsBuildBetaDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildBetaDetails]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildBetaDetailsGetInstance(ctx, id, params)
	return err
}

// BuildBetaDetailsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BuildBetaDetailsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildBetaDetailsUpdateInstance(ctx, id)
	return err
}

// BuildBetaDetailsBuildGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildBetaDetailsBuildGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildBetaDetailsBuildGetToOneRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildBetaDetailsBuildGetToOneRelated(ctx, id, params)
	return err
}

// BuildBetaNotificationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BuildBetaNotificationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildBetaNotificationsCreateInstance(ctx)
	return err
}

// BuildsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsGetCollectionParams
	// ------------- Optional query parameter "filter[betaAppReviewSubmission.betaReviewState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[betaAppReviewSubmission.betaReviewState]", ctx.QueryParams(), &params.FilterBetaAppReviewSubmissionBetaReviewState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[betaAppReviewSubmission.betaReviewState]: %s", err))
	}

	// ------------- Optional query parameter "filter[expired]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[expired]", ctx.QueryParams(), &params.FilterExpired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[expired]: %s", err))
	}

	// ------------- Optional query parameter "filter[preReleaseVersion.platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[preReleaseVersion.platform]", ctx.QueryParams(), &params.FilterPreReleaseVersionPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[preReleaseVersion.platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[preReleaseVersion.version]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[preReleaseVersion.version]", ctx.QueryParams(), &params.FilterPreReleaseVersionVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[preReleaseVersion.version]: %s", err))
	}

	// ------------- Optional query parameter "filter[processingState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[processingState]", ctx.QueryParams(), &params.FilterProcessingState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[processingState]: %s", err))
	}

	// ------------- Optional query parameter "filter[usesNonExemptEncryption]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[usesNonExemptEncryption]", ctx.QueryParams(), &params.FilterUsesNonExemptEncryption)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[usesNonExemptEncryption]: %s", err))
	}

	// ------------- Optional query parameter "filter[version]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[version]", ctx.QueryParams(), &params.FilterVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[version]: %s", err))
	}

	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "filter[appStoreVersion]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[appStoreVersion]", ctx.QueryParams(), &params.FilterAppStoreVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[appStoreVersion]: %s", err))
	}

	// ------------- Optional query parameter "filter[betaGroups]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[betaGroups]", ctx.QueryParams(), &params.FilterBetaGroups)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[betaGroups]: %s", err))
	}

	// ------------- Optional query parameter "filter[preReleaseVersion]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[preReleaseVersion]", ctx.QueryParams(), &params.FilterPreReleaseVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[preReleaseVersion]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appEncryptionDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appEncryptionDeclarations]", ctx.QueryParams(), &params.FieldsAppEncryptionDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appEncryptionDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppReviewSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewSubmissions]", ctx.QueryParams(), &params.FieldsBetaAppReviewSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "fields[buildBetaDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildBetaDetails]", ctx.QueryParams(), &params.FieldsBuildBetaDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildBetaDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[buildIcons]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildIcons]", ctx.QueryParams(), &params.FieldsBuildIcons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildIcons]: %s", err))
	}

	// ------------- Optional query parameter "fields[perfPowerMetrics]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[perfPowerMetrics]", ctx.QueryParams(), &params.FieldsPerfPowerMetrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[perfPowerMetrics]: %s", err))
	}

	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[diagnosticSignatures]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[diagnosticSignatures]", ctx.QueryParams(), &params.FieldsDiagnosticSignatures)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[diagnosticSignatures]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaBuildLocalizations]", ctx.QueryParams(), &params.FieldsBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaBuildLocalizations]", ctx.QueryParams(), &params.LimitBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit[icons]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[icons]", ctx.QueryParams(), &params.LimitIcons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[icons]: %s", err))
	}

	// ------------- Optional query parameter "limit[individualTesters]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[individualTesters]", ctx.QueryParams(), &params.LimitIndividualTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[individualTesters]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsGetCollection(ctx, params)
	return err
}

// BuildsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsGetInstanceParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[appEncryptionDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appEncryptionDeclarations]", ctx.QueryParams(), &params.FieldsAppEncryptionDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appEncryptionDeclarations]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaAppReviewSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewSubmissions]", ctx.QueryParams(), &params.FieldsBetaAppReviewSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewSubmissions]: %s", err))
	}

	// ------------- Optional query parameter "fields[buildBetaDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildBetaDetails]", ctx.QueryParams(), &params.FieldsBuildBetaDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildBetaDetails]: %s", err))
	}

	// ------------- Optional query parameter "fields[buildIcons]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildIcons]", ctx.QueryParams(), &params.FieldsBuildIcons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildIcons]: %s", err))
	}

	// ------------- Optional query parameter "fields[perfPowerMetrics]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[perfPowerMetrics]", ctx.QueryParams(), &params.FieldsPerfPowerMetrics)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[perfPowerMetrics]: %s", err))
	}

	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[diagnosticSignatures]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[diagnosticSignatures]", ctx.QueryParams(), &params.FieldsDiagnosticSignatures)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[diagnosticSignatures]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "fields[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaBuildLocalizations]", ctx.QueryParams(), &params.FieldsBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[betaBuildLocalizations]", ctx.QueryParams(), &params.LimitBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit[icons]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[icons]", ctx.QueryParams(), &params.LimitIcons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[icons]: %s", err))
	}

	// ------------- Optional query parameter "limit[individualTesters]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[individualTesters]", ctx.QueryParams(), &params.LimitIndividualTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[individualTesters]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsGetInstance(ctx, id, params)
	return err
}

// BuildsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsUpdateInstance(ctx, id)
	return err
}

// BuildsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsAppGetToOneRelated(ctx, id, params)
	return err
}

// BuildsAppEncryptionDeclarationGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsAppEncryptionDeclarationGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsAppEncryptionDeclarationGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appEncryptionDeclarations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appEncryptionDeclarations]", ctx.QueryParams(), &params.FieldsAppEncryptionDeclarations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appEncryptionDeclarations]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsAppEncryptionDeclarationGetToOneRelated(ctx, id, params)
	return err
}

// BuildsAppStoreVersionGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsAppStoreVersionGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsAppStoreVersionGetToOneRelatedParams
	// ------------- Optional query parameter "fields[appStoreVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[appStoreVersions]", ctx.QueryParams(), &params.FieldsAppStoreVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[appStoreVersions]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsAppStoreVersionGetToOneRelated(ctx, id, params)
	return err
}

// BuildsBetaAppReviewSubmissionGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsBetaAppReviewSubmissionGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsBetaAppReviewSubmissionGetToOneRelatedParams
	// ------------- Optional query parameter "fields[betaAppReviewSubmissions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaAppReviewSubmissions]", ctx.QueryParams(), &params.FieldsBetaAppReviewSubmissions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaAppReviewSubmissions]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsBetaAppReviewSubmissionGetToOneRelated(ctx, id, params)
	return err
}

// BuildsBetaBuildLocalizationsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsBetaBuildLocalizationsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsBetaBuildLocalizationsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[betaBuildLocalizations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaBuildLocalizations]", ctx.QueryParams(), &params.FieldsBetaBuildLocalizations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaBuildLocalizations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsBetaBuildLocalizationsGetToManyRelated(ctx, id, params)
	return err
}

// BuildsBuildBetaDetailGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsBuildBetaDetailGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsBuildBetaDetailGetToOneRelatedParams
	// ------------- Optional query parameter "fields[buildBetaDetails]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildBetaDetails]", ctx.QueryParams(), &params.FieldsBuildBetaDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildBetaDetails]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsBuildBetaDetailGetToOneRelated(ctx, id, params)
	return err
}

// BuildsDiagnosticSignaturesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsDiagnosticSignaturesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsDiagnosticSignaturesGetToManyRelatedParams
	// ------------- Optional query parameter "filter[diagnosticType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[diagnosticType]", ctx.QueryParams(), &params.FilterDiagnosticType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[diagnosticType]: %s", err))
	}

	// ------------- Optional query parameter "fields[diagnosticSignatures]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[diagnosticSignatures]", ctx.QueryParams(), &params.FieldsDiagnosticSignatures)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[diagnosticSignatures]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsDiagnosticSignaturesGetToManyRelated(ctx, id, params)
	return err
}

// BuildsIconsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsIconsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsIconsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[buildIcons]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[buildIcons]", ctx.QueryParams(), &params.FieldsBuildIcons)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[buildIcons]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsIconsGetToManyRelated(ctx, id, params)
	return err
}

// BuildsIndividualTestersGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsIndividualTestersGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsIndividualTestersGetToManyRelatedParams
	// ------------- Optional query parameter "fields[betaTesters]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[betaTesters]", ctx.QueryParams(), &params.FieldsBetaTesters)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[betaTesters]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsIndividualTestersGetToManyRelated(ctx, id, params)
	return err
}

// BuildsPerfPowerMetricsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsPerfPowerMetricsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsPerfPowerMetricsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[deviceType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[deviceType]", ctx.QueryParams(), &params.FilterDeviceType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[deviceType]: %s", err))
	}

	// ------------- Optional query parameter "filter[metricType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[metricType]", ctx.QueryParams(), &params.FilterMetricType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[metricType]: %s", err))
	}

	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsPerfPowerMetricsGetToManyRelated(ctx, id, params)
	return err
}

// BuildsPreReleaseVersionGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsPreReleaseVersionGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsPreReleaseVersionGetToOneRelatedParams
	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsPreReleaseVersionGetToOneRelated(ctx, id, params)
	return err
}

// BuildsAppEncryptionDeclarationGetToOneRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsAppEncryptionDeclarationGetToOneRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsAppEncryptionDeclarationGetToOneRelationship(ctx, id)
	return err
}

// BuildsAppEncryptionDeclarationUpdateToOneRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsAppEncryptionDeclarationUpdateToOneRelationship(ctx, id)
	return err
}

// BuildsBetaGroupsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsBetaGroupsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsBetaGroupsDeleteToManyRelationship(ctx, id)
	return err
}

// BuildsBetaGroupsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsBetaGroupsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsBetaGroupsCreateToManyRelationship(ctx, id)
	return err
}

// BuildsIndividualTestersDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsIndividualTestersDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsIndividualTestersDeleteToManyRelationship(ctx, id)
	return err
}

// BuildsIndividualTestersGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsIndividualTestersGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BuildsIndividualTestersGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsIndividualTestersGetToManyRelationship(ctx, id, params)
	return err
}

// BuildsIndividualTestersCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) BuildsIndividualTestersCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BuildsIndividualTestersCreateToManyRelationship(ctx, id)
	return err
}

// BundleIdCapabilitiesCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdCapabilitiesCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdCapabilitiesCreateInstance(ctx)
	return err
}

// BundleIdCapabilitiesDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdCapabilitiesDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdCapabilitiesDeleteInstance(ctx, id)
	return err
}

// BundleIdCapabilitiesUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdCapabilitiesUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdCapabilitiesUpdateInstance(ctx, id)
	return err
}

// BundleIdsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BundleIdsGetCollectionParams
	// ------------- Optional query parameter "filter[identifier]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[identifier]", ctx.QueryParams(), &params.FilterIdentifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[identifier]: %s", err))
	}

	// ------------- Optional query parameter "filter[name]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[name]", ctx.QueryParams(), &params.FilterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[name]: %s", err))
	}

	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[seedId]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[seedId]", ctx.QueryParams(), &params.FilterSeedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[seedId]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[bundleIds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIds]", ctx.QueryParams(), &params.FieldsBundleIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIds]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[bundleIdCapabilities]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIdCapabilities]", ctx.QueryParams(), &params.FieldsBundleIdCapabilities)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIdCapabilities]: %s", err))
	}

	// ------------- Optional query parameter "fields[profiles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[profiles]", ctx.QueryParams(), &params.FieldsProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[profiles]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[bundleIdCapabilities]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[bundleIdCapabilities]", ctx.QueryParams(), &params.LimitBundleIdCapabilities)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[bundleIdCapabilities]: %s", err))
	}

	// ------------- Optional query parameter "limit[profiles]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[profiles]", ctx.QueryParams(), &params.LimitProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[profiles]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsGetCollection(ctx, params)
	return err
}

// BundleIdsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsCreateInstance(ctx)
	return err
}

// BundleIdsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsDeleteInstance(ctx, id)
	return err
}

// BundleIdsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BundleIdsGetInstanceParams
	// ------------- Optional query parameter "fields[bundleIds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIds]", ctx.QueryParams(), &params.FieldsBundleIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIds]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[bundleIdCapabilities]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIdCapabilities]", ctx.QueryParams(), &params.FieldsBundleIdCapabilities)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIdCapabilities]: %s", err))
	}

	// ------------- Optional query parameter "fields[profiles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[profiles]", ctx.QueryParams(), &params.FieldsProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[profiles]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[bundleIdCapabilities]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[bundleIdCapabilities]", ctx.QueryParams(), &params.LimitBundleIdCapabilities)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[bundleIdCapabilities]: %s", err))
	}

	// ------------- Optional query parameter "limit[profiles]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[profiles]", ctx.QueryParams(), &params.LimitProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[profiles]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsGetInstance(ctx, id, params)
	return err
}

// BundleIdsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsUpdateInstance(ctx, id)
	return err
}

// BundleIdsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BundleIdsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsAppGetToOneRelated(ctx, id, params)
	return err
}

// BundleIdsBundleIdCapabilitiesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsBundleIdCapabilitiesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BundleIdsBundleIdCapabilitiesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[bundleIdCapabilities]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIdCapabilities]", ctx.QueryParams(), &params.FieldsBundleIdCapabilities)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIdCapabilities]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsBundleIdCapabilitiesGetToManyRelated(ctx, id, params)
	return err
}

// BundleIdsProfilesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) BundleIdsProfilesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params BundleIdsProfilesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[profiles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[profiles]", ctx.QueryParams(), &params.FieldsProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[profiles]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BundleIdsProfilesGetToManyRelated(ctx, id, params)
	return err
}

// CertificatesGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) CertificatesGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertificatesGetCollectionParams
	// ------------- Optional query parameter "filter[certificateType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[certificateType]", ctx.QueryParams(), &params.FilterCertificateType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[certificateType]: %s", err))
	}

	// ------------- Optional query parameter "filter[displayName]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[displayName]", ctx.QueryParams(), &params.FilterDisplayName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[displayName]: %s", err))
	}

	// ------------- Optional query parameter "filter[serialNumber]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[serialNumber]", ctx.QueryParams(), &params.FilterSerialNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[serialNumber]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[certificates]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[certificates]", ctx.QueryParams(), &params.FieldsCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[certificates]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CertificatesGetCollection(ctx, params)
	return err
}

// CertificatesCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) CertificatesCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CertificatesCreateInstance(ctx)
	return err
}

// CertificatesDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) CertificatesDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CertificatesDeleteInstance(ctx, id)
	return err
}

// CertificatesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) CertificatesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertificatesGetInstanceParams
	// ------------- Optional query parameter "fields[certificates]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[certificates]", ctx.QueryParams(), &params.FieldsCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[certificates]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CertificatesGetInstance(ctx, id, params)
	return err
}

// DevicesGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) DevicesGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DevicesGetCollectionParams
	// ------------- Optional query parameter "filter[name]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[name]", ctx.QueryParams(), &params.FilterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[name]: %s", err))
	}

	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[status]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[status]", ctx.QueryParams(), &params.FilterStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[status]: %s", err))
	}

	// ------------- Optional query parameter "filter[udid]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[udid]", ctx.QueryParams(), &params.FilterUdid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[udid]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[devices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[devices]", ctx.QueryParams(), &params.FieldsDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[devices]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevicesGetCollection(ctx, params)
	return err
}

// DevicesCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) DevicesCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevicesCreateInstance(ctx)
	return err
}

// DevicesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) DevicesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DevicesGetInstanceParams
	// ------------- Optional query parameter "fields[devices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[devices]", ctx.QueryParams(), &params.FieldsDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[devices]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevicesGetInstance(ctx, id, params)
	return err
}

// DevicesUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) DevicesUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DevicesUpdateInstance(ctx, id)
	return err
}

// DiagnosticSignaturesLogsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) DiagnosticSignaturesLogsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiagnosticSignaturesLogsGetToManyRelatedParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DiagnosticSignaturesLogsGetToManyRelated(ctx, id, params)
	return err
}

// EndUserLicenseAgreementsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) EndUserLicenseAgreementsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndUserLicenseAgreementsCreateInstance(ctx)
	return err
}

// EndUserLicenseAgreementsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) EndUserLicenseAgreementsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndUserLicenseAgreementsDeleteInstance(ctx, id)
	return err
}

// EndUserLicenseAgreementsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) EndUserLicenseAgreementsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndUserLicenseAgreementsGetInstanceParams
	// ------------- Optional query parameter "fields[endUserLicenseAgreements]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[endUserLicenseAgreements]", ctx.QueryParams(), &params.FieldsEndUserLicenseAgreements)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[endUserLicenseAgreements]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// ------------- Optional query parameter "limit[territories]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[territories]", ctx.QueryParams(), &params.LimitTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[territories]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndUserLicenseAgreementsGetInstance(ctx, id, params)
	return err
}

// EndUserLicenseAgreementsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) EndUserLicenseAgreementsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndUserLicenseAgreementsUpdateInstance(ctx, id)
	return err
}

// EndUserLicenseAgreementsTerritoriesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) EndUserLicenseAgreementsTerritoriesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EndUserLicenseAgreementsTerritoriesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndUserLicenseAgreementsTerritoriesGetToManyRelated(ctx, id, params)
	return err
}

// FinanceReportsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) FinanceReportsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params FinanceReportsGetCollectionParams
	// ------------- Required query parameter "filter[regionCode]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[regionCode]", ctx.QueryParams(), &params.FilterRegionCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[regionCode]: %s", err))
	}

	// ------------- Required query parameter "filter[reportDate]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[reportDate]", ctx.QueryParams(), &params.FilterReportDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[reportDate]: %s", err))
	}

	// ------------- Required query parameter "filter[reportType]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[reportType]", ctx.QueryParams(), &params.FilterReportType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[reportType]: %s", err))
	}

	// ------------- Required query parameter "filter[vendorNumber]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[vendorNumber]", ctx.QueryParams(), &params.FilterVendorNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[vendorNumber]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.FinanceReportsGetCollection(ctx, params)
	return err
}

// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GameCenterEnabledVersionsCompatibleVersionsGetToManyRelatedParams
	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[versionString]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[versionString]", ctx.QueryParams(), &params.FilterVersionString)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[versionString]: %s", err))
	}

	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[gameCenterEnabledVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[gameCenterEnabledVersions]", ctx.QueryParams(), &params.FieldsGameCenterEnabledVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[gameCenterEnabledVersions]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated(ctx, id, params)
	return err
}

// GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship(ctx, id)
	return err
}

// GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship(ctx, id, params)
	return err
}

// GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship(ctx, id)
	return err
}

// GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship(ctx, id)
	return err
}

// IdfaDeclarationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) IdfaDeclarationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IdfaDeclarationsCreateInstance(ctx)
	return err
}

// IdfaDeclarationsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) IdfaDeclarationsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IdfaDeclarationsDeleteInstance(ctx, id)
	return err
}

// IdfaDeclarationsUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) IdfaDeclarationsUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IdfaDeclarationsUpdateInstance(ctx, id)
	return err
}

// InAppPurchasesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) InAppPurchasesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params InAppPurchasesGetInstanceParams
	// ------------- Optional query parameter "fields[inAppPurchases]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[inAppPurchases]", ctx.QueryParams(), &params.FieldsInAppPurchases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[inAppPurchases]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "limit[apps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[apps]", ctx.QueryParams(), &params.LimitApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InAppPurchasesGetInstance(ctx, id, params)
	return err
}

// PreReleaseVersionsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) PreReleaseVersionsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PreReleaseVersionsGetCollectionParams
	// ------------- Optional query parameter "filter[builds.expired]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[builds.expired]", ctx.QueryParams(), &params.FilterBuildsExpired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[builds.expired]: %s", err))
	}

	// ------------- Optional query parameter "filter[builds.processingState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[builds.processingState]", ctx.QueryParams(), &params.FilterBuildsProcessingState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[builds.processingState]: %s", err))
	}

	// ------------- Optional query parameter "filter[platform]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[platform]", ctx.QueryParams(), &params.FilterPlatform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[platform]: %s", err))
	}

	// ------------- Optional query parameter "filter[version]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[version]", ctx.QueryParams(), &params.FilterVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[version]: %s", err))
	}

	// ------------- Optional query parameter "filter[app]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[app]", ctx.QueryParams(), &params.FilterApp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[app]: %s", err))
	}

	// ------------- Optional query parameter "filter[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[builds]", ctx.QueryParams(), &params.FilterBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[builds]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PreReleaseVersionsGetCollection(ctx, params)
	return err
}

// PreReleaseVersionsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) PreReleaseVersionsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PreReleaseVersionsGetInstanceParams
	// ------------- Optional query parameter "fields[preReleaseVersions]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[preReleaseVersions]", ctx.QueryParams(), &params.FieldsPreReleaseVersions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[preReleaseVersions]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[builds]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[builds]", ctx.QueryParams(), &params.LimitBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[builds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PreReleaseVersionsGetInstance(ctx, id, params)
	return err
}

// PreReleaseVersionsAppGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) PreReleaseVersionsAppGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PreReleaseVersionsAppGetToOneRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PreReleaseVersionsAppGetToOneRelated(ctx, id, params)
	return err
}

// PreReleaseVersionsBuildsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) PreReleaseVersionsBuildsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PreReleaseVersionsBuildsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[builds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[builds]", ctx.QueryParams(), &params.FieldsBuilds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[builds]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PreReleaseVersionsBuildsGetToManyRelated(ctx, id, params)
	return err
}

// ProfilesGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProfilesGetCollectionParams
	// ------------- Optional query parameter "filter[name]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[name]", ctx.QueryParams(), &params.FilterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[name]: %s", err))
	}

	// ------------- Optional query parameter "filter[profileState]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[profileState]", ctx.QueryParams(), &params.FilterProfileState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[profileState]: %s", err))
	}

	// ------------- Optional query parameter "filter[profileType]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[profileType]", ctx.QueryParams(), &params.FilterProfileType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[profileType]: %s", err))
	}

	// ------------- Optional query parameter "filter[id]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[id]", ctx.QueryParams(), &params.FilterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[id]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[profiles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[profiles]", ctx.QueryParams(), &params.FieldsProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[profiles]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[certificates]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[certificates]", ctx.QueryParams(), &params.FieldsCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[certificates]: %s", err))
	}

	// ------------- Optional query parameter "fields[devices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[devices]", ctx.QueryParams(), &params.FieldsDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[devices]: %s", err))
	}

	// ------------- Optional query parameter "fields[bundleIds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIds]", ctx.QueryParams(), &params.FieldsBundleIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIds]: %s", err))
	}

	// ------------- Optional query parameter "limit[certificates]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[certificates]", ctx.QueryParams(), &params.LimitCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[certificates]: %s", err))
	}

	// ------------- Optional query parameter "limit[devices]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[devices]", ctx.QueryParams(), &params.LimitDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[devices]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesGetCollection(ctx, params)
	return err
}

// ProfilesCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesCreateInstance(ctx)
	return err
}

// ProfilesDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesDeleteInstance(ctx, id)
	return err
}

// ProfilesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProfilesGetInstanceParams
	// ------------- Optional query parameter "fields[profiles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[profiles]", ctx.QueryParams(), &params.FieldsProfiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[profiles]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[certificates]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[certificates]", ctx.QueryParams(), &params.FieldsCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[certificates]: %s", err))
	}

	// ------------- Optional query parameter "fields[devices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[devices]", ctx.QueryParams(), &params.FieldsDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[devices]: %s", err))
	}

	// ------------- Optional query parameter "fields[bundleIds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIds]", ctx.QueryParams(), &params.FieldsBundleIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIds]: %s", err))
	}

	// ------------- Optional query parameter "limit[certificates]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[certificates]", ctx.QueryParams(), &params.LimitCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[certificates]: %s", err))
	}

	// ------------- Optional query parameter "limit[devices]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[devices]", ctx.QueryParams(), &params.LimitDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[devices]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesGetInstance(ctx, id, params)
	return err
}

// ProfilesBundleIdGetToOneRelated converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesBundleIdGetToOneRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProfilesBundleIdGetToOneRelatedParams
	// ------------- Optional query parameter "fields[bundleIds]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[bundleIds]", ctx.QueryParams(), &params.FieldsBundleIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[bundleIds]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesBundleIdGetToOneRelated(ctx, id, params)
	return err
}

// ProfilesCertificatesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesCertificatesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProfilesCertificatesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[certificates]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[certificates]", ctx.QueryParams(), &params.FieldsCertificates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[certificates]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesCertificatesGetToManyRelated(ctx, id, params)
	return err
}

// ProfilesDevicesGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) ProfilesDevicesGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProfilesDevicesGetToManyRelatedParams
	// ------------- Optional query parameter "fields[devices]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[devices]", ctx.QueryParams(), &params.FieldsDevices)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[devices]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProfilesDevicesGetToManyRelated(ctx, id, params)
	return err
}

// RoutingAppCoveragesCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) RoutingAppCoveragesCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RoutingAppCoveragesCreateInstance(ctx)
	return err
}

// RoutingAppCoveragesDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) RoutingAppCoveragesDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RoutingAppCoveragesDeleteInstance(ctx, id)
	return err
}

// RoutingAppCoveragesGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) RoutingAppCoveragesGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RoutingAppCoveragesGetInstanceParams
	// ------------- Optional query parameter "fields[routingAppCoverages]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[routingAppCoverages]", ctx.QueryParams(), &params.FieldsRoutingAppCoverages)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[routingAppCoverages]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RoutingAppCoveragesGetInstance(ctx, id, params)
	return err
}

// RoutingAppCoveragesUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) RoutingAppCoveragesUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RoutingAppCoveragesUpdateInstance(ctx, id)
	return err
}

// SalesReportsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) SalesReportsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SalesReportsGetCollectionParams
	// ------------- Required query parameter "filter[frequency]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[frequency]", ctx.QueryParams(), &params.FilterFrequency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[frequency]: %s", err))
	}

	// ------------- Optional query parameter "filter[reportDate]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[reportDate]", ctx.QueryParams(), &params.FilterReportDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[reportDate]: %s", err))
	}

	// ------------- Required query parameter "filter[reportSubType]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[reportSubType]", ctx.QueryParams(), &params.FilterReportSubType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[reportSubType]: %s", err))
	}

	// ------------- Required query parameter "filter[reportType]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[reportType]", ctx.QueryParams(), &params.FilterReportType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[reportType]: %s", err))
	}

	// ------------- Required query parameter "filter[vendorNumber]" -------------

	err = runtime.BindQueryParameter("form", false, true, "filter[vendorNumber]", ctx.QueryParams(), &params.FilterVendorNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[vendorNumber]: %s", err))
	}

	// ------------- Optional query parameter "filter[version]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[version]", ctx.QueryParams(), &params.FilterVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[version]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SalesReportsGetCollection(ctx, params)
	return err
}

// TerritoriesGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) TerritoriesGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TerritoriesGetCollectionParams
	// ------------- Optional query parameter "fields[territories]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[territories]", ctx.QueryParams(), &params.FieldsTerritories)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[territories]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TerritoriesGetCollection(ctx, params)
	return err
}

// UserInvitationsGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) UserInvitationsGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserInvitationsGetCollectionParams
	// ------------- Optional query parameter "filter[email]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[email]", ctx.QueryParams(), &params.FilterEmail)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[email]: %s", err))
	}

	// ------------- Optional query parameter "filter[roles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[roles]", ctx.QueryParams(), &params.FilterRoles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[roles]: %s", err))
	}

	// ------------- Optional query parameter "filter[visibleApps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[visibleApps]", ctx.QueryParams(), &params.FilterVisibleApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[visibleApps]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[userInvitations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[userInvitations]", ctx.QueryParams(), &params.FieldsUserInvitations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[userInvitations]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[visibleApps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[visibleApps]", ctx.QueryParams(), &params.LimitVisibleApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[visibleApps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserInvitationsGetCollection(ctx, params)
	return err
}

// UserInvitationsCreateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) UserInvitationsCreateInstance(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserInvitationsCreateInstance(ctx)
	return err
}

// UserInvitationsDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) UserInvitationsDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserInvitationsDeleteInstance(ctx, id)
	return err
}

// UserInvitationsGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) UserInvitationsGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserInvitationsGetInstanceParams
	// ------------- Optional query parameter "fields[userInvitations]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[userInvitations]", ctx.QueryParams(), &params.FieldsUserInvitations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[userInvitations]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[visibleApps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[visibleApps]", ctx.QueryParams(), &params.LimitVisibleApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[visibleApps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserInvitationsGetInstance(ctx, id, params)
	return err
}

// UserInvitationsVisibleAppsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) UserInvitationsVisibleAppsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserInvitationsVisibleAppsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UserInvitationsVisibleAppsGetToManyRelated(ctx, id, params)
	return err
}

// UsersGetCollection converts echo context to params.
func (w *ServerInterfaceWrapper) UsersGetCollection(ctx echo.Context) error {
	var err error

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersGetCollectionParams
	// ------------- Optional query parameter "filter[roles]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[roles]", ctx.QueryParams(), &params.FilterRoles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[roles]: %s", err))
	}

	// ------------- Optional query parameter "filter[username]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[username]", ctx.QueryParams(), &params.FilterUsername)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[username]: %s", err))
	}

	// ------------- Optional query parameter "filter[visibleApps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "filter[visibleApps]", ctx.QueryParams(), &params.FilterVisibleApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter[visibleApps]: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "fields[users]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[users]", ctx.QueryParams(), &params.FieldsUsers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[users]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[visibleApps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[visibleApps]", ctx.QueryParams(), &params.LimitVisibleApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[visibleApps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersGetCollection(ctx, params)
	return err
}

// UsersDeleteInstance converts echo context to params.
func (w *ServerInterfaceWrapper) UsersDeleteInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersDeleteInstance(ctx, id)
	return err
}

// UsersGetInstance converts echo context to params.
func (w *ServerInterfaceWrapper) UsersGetInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersGetInstanceParams
	// ------------- Optional query parameter "fields[users]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[users]", ctx.QueryParams(), &params.FieldsUsers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[users]: %s", err))
	}

	// ------------- Optional query parameter "include" -------------

	err = runtime.BindQueryParameter("form", false, false, "include", ctx.QueryParams(), &params.Include)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include: %s", err))
	}

	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit[visibleApps]" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit[visibleApps]", ctx.QueryParams(), &params.LimitVisibleApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit[visibleApps]: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersGetInstance(ctx, id, params)
	return err
}

// UsersUpdateInstance converts echo context to params.
func (w *ServerInterfaceWrapper) UsersUpdateInstance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersUpdateInstance(ctx, id)
	return err
}

// UsersVisibleAppsDeleteToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) UsersVisibleAppsDeleteToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersVisibleAppsDeleteToManyRelationship(ctx, id)
	return err
}

// UsersVisibleAppsGetToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) UsersVisibleAppsGetToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersVisibleAppsGetToManyRelationshipParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersVisibleAppsGetToManyRelationship(ctx, id, params)
	return err
}

// UsersVisibleAppsReplaceToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) UsersVisibleAppsReplaceToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersVisibleAppsReplaceToManyRelationship(ctx, id)
	return err
}

// UsersVisibleAppsCreateToManyRelationship converts echo context to params.
func (w *ServerInterfaceWrapper) UsersVisibleAppsCreateToManyRelationship(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersVisibleAppsCreateToManyRelationship(ctx, id)
	return err
}

// UsersVisibleAppsGetToManyRelated converts echo context to params.
func (w *ServerInterfaceWrapper) UsersVisibleAppsGetToManyRelated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("itc-bearer-token.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersVisibleAppsGetToManyRelatedParams
	// ------------- Optional query parameter "fields[apps]" -------------

	err = runtime.BindQueryParameter("form", false, false, "fields[apps]", ctx.QueryParams(), &params.FieldsApps)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fields[apps]: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UsersVisibleAppsGetToManyRelated(ctx, id, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.PATCH("/v1/ageRatingDeclarations/:id", wrapper.AgeRatingDeclarationsUpdateInstance)
	router.GET("/v1/appCategories", wrapper.AppCategoriesGetCollection)
	router.GET("/v1/appCategories/:id", wrapper.AppCategoriesGetInstance)
	router.GET("/v1/appCategories/:id/parent", wrapper.AppCategoriesParentGetToOneRelated)
	router.GET("/v1/appCategories/:id/subcategories", wrapper.AppCategoriesSubcategoriesGetToManyRelated)
	router.GET("/v1/appEncryptionDeclarations", wrapper.AppEncryptionDeclarationsGetCollection)
	router.GET("/v1/appEncryptionDeclarations/:id", wrapper.AppEncryptionDeclarationsGetInstance)
	router.GET("/v1/appEncryptionDeclarations/:id/app", wrapper.AppEncryptionDeclarationsAppGetToOneRelated)
	router.POST("/v1/appEncryptionDeclarations/:id/relationships/builds", wrapper.AppEncryptionDeclarationsBuildsCreateToManyRelationship)
	router.POST("/v1/appInfoLocalizations", wrapper.AppInfoLocalizationsCreateInstance)
	router.DELETE("/v1/appInfoLocalizations/:id", wrapper.AppInfoLocalizationsDeleteInstance)
	router.GET("/v1/appInfoLocalizations/:id", wrapper.AppInfoLocalizationsGetInstance)
	router.PATCH("/v1/appInfoLocalizations/:id", wrapper.AppInfoLocalizationsUpdateInstance)
	router.GET("/v1/appInfos/:id", wrapper.AppInfosGetInstance)
	router.PATCH("/v1/appInfos/:id", wrapper.AppInfosUpdateInstance)
	router.GET("/v1/appInfos/:id/appInfoLocalizations", wrapper.AppInfosAppInfoLocalizationsGetToManyRelated)
	router.GET("/v1/appInfos/:id/primaryCategory", wrapper.AppInfosPrimaryCategoryGetToOneRelated)
	router.GET("/v1/appInfos/:id/primarySubcategoryOne", wrapper.AppInfosPrimarySubcategoryOneGetToOneRelated)
	router.GET("/v1/appInfos/:id/primarySubcategoryTwo", wrapper.AppInfosPrimarySubcategoryTwoGetToOneRelated)
	router.GET("/v1/appInfos/:id/secondaryCategory", wrapper.AppInfosSecondaryCategoryGetToOneRelated)
	router.GET("/v1/appInfos/:id/secondarySubcategoryOne", wrapper.AppInfosSecondarySubcategoryOneGetToOneRelated)
	router.GET("/v1/appInfos/:id/secondarySubcategoryTwo", wrapper.AppInfosSecondarySubcategoryTwoGetToOneRelated)
	router.POST("/v1/appPreOrders", wrapper.AppPreOrdersCreateInstance)
	router.DELETE("/v1/appPreOrders/:id", wrapper.AppPreOrdersDeleteInstance)
	router.GET("/v1/appPreOrders/:id", wrapper.AppPreOrdersGetInstance)
	router.PATCH("/v1/appPreOrders/:id", wrapper.AppPreOrdersUpdateInstance)
	router.POST("/v1/appPreviewSets", wrapper.AppPreviewSetsCreateInstance)
	router.DELETE("/v1/appPreviewSets/:id", wrapper.AppPreviewSetsDeleteInstance)
	router.GET("/v1/appPreviewSets/:id", wrapper.AppPreviewSetsGetInstance)
	router.GET("/v1/appPreviewSets/:id/appPreviews", wrapper.AppPreviewSetsAppPreviewsGetToManyRelated)
	router.GET("/v1/appPreviewSets/:id/relationships/appPreviews", wrapper.AppPreviewSetsAppPreviewsGetToManyRelationship)
	router.PATCH("/v1/appPreviewSets/:id/relationships/appPreviews", wrapper.AppPreviewSetsAppPreviewsReplaceToManyRelationship)
	router.POST("/v1/appPreviews", wrapper.AppPreviewsCreateInstance)
	router.DELETE("/v1/appPreviews/:id", wrapper.AppPreviewsDeleteInstance)
	router.GET("/v1/appPreviews/:id", wrapper.AppPreviewsGetInstance)
	router.PATCH("/v1/appPreviews/:id", wrapper.AppPreviewsUpdateInstance)
	router.GET("/v1/appPricePoints", wrapper.AppPricePointsGetCollection)
	router.GET("/v1/appPricePoints/:id", wrapper.AppPricePointsGetInstance)
	router.GET("/v1/appPricePoints/:id/territory", wrapper.AppPricePointsTerritoryGetToOneRelated)
	router.GET("/v1/appPriceTiers", wrapper.AppPriceTiersGetCollection)
	router.GET("/v1/appPriceTiers/:id", wrapper.AppPriceTiersGetInstance)
	router.GET("/v1/appPriceTiers/:id/pricePoints", wrapper.AppPriceTiersPricePointsGetToManyRelated)
	router.GET("/v1/appPrices/:id", wrapper.AppPricesGetInstance)
	router.POST("/v1/appScreenshotSets", wrapper.AppScreenshotSetsCreateInstance)
	router.DELETE("/v1/appScreenshotSets/:id", wrapper.AppScreenshotSetsDeleteInstance)
	router.GET("/v1/appScreenshotSets/:id", wrapper.AppScreenshotSetsGetInstance)
	router.GET("/v1/appScreenshotSets/:id/appScreenshots", wrapper.AppScreenshotSetsAppScreenshotsGetToManyRelated)
	router.GET("/v1/appScreenshotSets/:id/relationships/appScreenshots", wrapper.AppScreenshotSetsAppScreenshotsGetToManyRelationship)
	router.PATCH("/v1/appScreenshotSets/:id/relationships/appScreenshots", wrapper.AppScreenshotSetsAppScreenshotsReplaceToManyRelationship)
	router.POST("/v1/appScreenshots", wrapper.AppScreenshotsCreateInstance)
	router.DELETE("/v1/appScreenshots/:id", wrapper.AppScreenshotsDeleteInstance)
	router.GET("/v1/appScreenshots/:id", wrapper.AppScreenshotsGetInstance)
	router.PATCH("/v1/appScreenshots/:id", wrapper.AppScreenshotsUpdateInstance)
	router.POST("/v1/appStoreReviewAttachments", wrapper.AppStoreReviewAttachmentsCreateInstance)
	router.DELETE("/v1/appStoreReviewAttachments/:id", wrapper.AppStoreReviewAttachmentsDeleteInstance)
	router.GET("/v1/appStoreReviewAttachments/:id", wrapper.AppStoreReviewAttachmentsGetInstance)
	router.PATCH("/v1/appStoreReviewAttachments/:id", wrapper.AppStoreReviewAttachmentsUpdateInstance)
	router.POST("/v1/appStoreReviewDetails", wrapper.AppStoreReviewDetailsCreateInstance)
	router.GET("/v1/appStoreReviewDetails/:id", wrapper.AppStoreReviewDetailsGetInstance)
	router.PATCH("/v1/appStoreReviewDetails/:id", wrapper.AppStoreReviewDetailsUpdateInstance)
	router.GET("/v1/appStoreReviewDetails/:id/appStoreReviewAttachments", wrapper.AppStoreReviewDetailsAppStoreReviewAttachmentsGetToManyRelated)
	router.POST("/v1/appStoreVersionLocalizations", wrapper.AppStoreVersionLocalizationsCreateInstance)
	router.DELETE("/v1/appStoreVersionLocalizations/:id", wrapper.AppStoreVersionLocalizationsDeleteInstance)
	router.GET("/v1/appStoreVersionLocalizations/:id", wrapper.AppStoreVersionLocalizationsGetInstance)
	router.PATCH("/v1/appStoreVersionLocalizations/:id", wrapper.AppStoreVersionLocalizationsUpdateInstance)
	router.GET("/v1/appStoreVersionLocalizations/:id/appPreviewSets", wrapper.AppStoreVersionLocalizationsAppPreviewSetsGetToManyRelated)
	router.GET("/v1/appStoreVersionLocalizations/:id/appScreenshotSets", wrapper.AppStoreVersionLocalizationsAppScreenshotSetsGetToManyRelated)
	router.POST("/v1/appStoreVersionPhasedReleases", wrapper.AppStoreVersionPhasedReleasesCreateInstance)
	router.DELETE("/v1/appStoreVersionPhasedReleases/:id", wrapper.AppStoreVersionPhasedReleasesDeleteInstance)
	router.PATCH("/v1/appStoreVersionPhasedReleases/:id", wrapper.AppStoreVersionPhasedReleasesUpdateInstance)
	router.POST("/v1/appStoreVersionSubmissions", wrapper.AppStoreVersionSubmissionsCreateInstance)
	router.DELETE("/v1/appStoreVersionSubmissions/:id", wrapper.AppStoreVersionSubmissionsDeleteInstance)
	router.POST("/v1/appStoreVersions", wrapper.AppStoreVersionsCreateInstance)
	router.DELETE("/v1/appStoreVersions/:id", wrapper.AppStoreVersionsDeleteInstance)
	router.GET("/v1/appStoreVersions/:id", wrapper.AppStoreVersionsGetInstance)
	router.PATCH("/v1/appStoreVersions/:id", wrapper.AppStoreVersionsUpdateInstance)
	router.GET("/v1/appStoreVersions/:id/ageRatingDeclaration", wrapper.AppStoreVersionsAgeRatingDeclarationGetToOneRelated)
	router.GET("/v1/appStoreVersions/:id/appStoreReviewDetail", wrapper.AppStoreVersionsAppStoreReviewDetailGetToOneRelated)
	router.GET("/v1/appStoreVersions/:id/appStoreVersionLocalizations", wrapper.AppStoreVersionsAppStoreVersionLocalizationsGetToManyRelated)
	router.GET("/v1/appStoreVersions/:id/appStoreVersionPhasedRelease", wrapper.AppStoreVersionsAppStoreVersionPhasedReleaseGetToOneRelated)
	router.GET("/v1/appStoreVersions/:id/appStoreVersionSubmission", wrapper.AppStoreVersionsAppStoreVersionSubmissionGetToOneRelated)
	router.GET("/v1/appStoreVersions/:id/build", wrapper.AppStoreVersionsBuildGetToOneRelated)
	router.GET("/v1/appStoreVersions/:id/idfaDeclaration", wrapper.AppStoreVersionsIdfaDeclarationGetToOneRelated)
	router.GET("/v1/appStoreVersions/:id/relationships/build", wrapper.AppStoreVersionsBuildGetToOneRelationship)
	router.PATCH("/v1/appStoreVersions/:id/relationships/build", wrapper.AppStoreVersionsBuildUpdateToOneRelationship)
	router.GET("/v1/appStoreVersions/:id/routingAppCoverage", wrapper.AppStoreVersionsRoutingAppCoverageGetToOneRelated)
	router.GET("/v1/apps", wrapper.AppsGetCollection)
	router.GET("/v1/apps/:id", wrapper.AppsGetInstance)
	router.PATCH("/v1/apps/:id", wrapper.AppsUpdateInstance)
	router.GET("/v1/apps/:id/appInfos", wrapper.AppsAppInfosGetToManyRelated)
	router.GET("/v1/apps/:id/appStoreVersions", wrapper.AppsAppStoreVersionsGetToManyRelated)
	router.GET("/v1/apps/:id/availableTerritories", wrapper.AppsAvailableTerritoriesGetToManyRelated)
	router.GET("/v1/apps/:id/betaAppLocalizations", wrapper.AppsBetaAppLocalizationsGetToManyRelated)
	router.GET("/v1/apps/:id/betaAppReviewDetail", wrapper.AppsBetaAppReviewDetailGetToOneRelated)
	router.GET("/v1/apps/:id/betaGroups", wrapper.AppsBetaGroupsGetToManyRelated)
	router.GET("/v1/apps/:id/betaLicenseAgreement", wrapper.AppsBetaLicenseAgreementGetToOneRelated)
	router.GET("/v1/apps/:id/builds", wrapper.AppsBuildsGetToManyRelated)
	router.GET("/v1/apps/:id/endUserLicenseAgreement", wrapper.AppsEndUserLicenseAgreementGetToOneRelated)
	router.GET("/v1/apps/:id/gameCenterEnabledVersions", wrapper.AppsGameCenterEnabledVersionsGetToManyRelated)
	router.GET("/v1/apps/:id/inAppPurchases", wrapper.AppsInAppPurchasesGetToManyRelated)
	router.GET("/v1/apps/:id/perfPowerMetrics", wrapper.AppsPerfPowerMetricsGetToManyRelated)
	router.GET("/v1/apps/:id/preOrder", wrapper.AppsPreOrderGetToOneRelated)
	router.GET("/v1/apps/:id/preReleaseVersions", wrapper.AppsPreReleaseVersionsGetToManyRelated)
	router.GET("/v1/apps/:id/prices", wrapper.AppsPricesGetToManyRelated)
	router.DELETE("/v1/apps/:id/relationships/betaTesters", wrapper.AppsBetaTestersDeleteToManyRelationship)
	router.GET("/v1/betaAppLocalizations", wrapper.BetaAppLocalizationsGetCollection)
	router.POST("/v1/betaAppLocalizations", wrapper.BetaAppLocalizationsCreateInstance)
	router.DELETE("/v1/betaAppLocalizations/:id", wrapper.BetaAppLocalizationsDeleteInstance)
	router.GET("/v1/betaAppLocalizations/:id", wrapper.BetaAppLocalizationsGetInstance)
	router.PATCH("/v1/betaAppLocalizations/:id", wrapper.BetaAppLocalizationsUpdateInstance)
	router.GET("/v1/betaAppLocalizations/:id/app", wrapper.BetaAppLocalizationsAppGetToOneRelated)
	router.GET("/v1/betaAppReviewDetails", wrapper.BetaAppReviewDetailsGetCollection)
	router.GET("/v1/betaAppReviewDetails/:id", wrapper.BetaAppReviewDetailsGetInstance)
	router.PATCH("/v1/betaAppReviewDetails/:id", wrapper.BetaAppReviewDetailsUpdateInstance)
	router.GET("/v1/betaAppReviewDetails/:id/app", wrapper.BetaAppReviewDetailsAppGetToOneRelated)
	router.GET("/v1/betaAppReviewSubmissions", wrapper.BetaAppReviewSubmissionsGetCollection)
	router.POST("/v1/betaAppReviewSubmissions", wrapper.BetaAppReviewSubmissionsCreateInstance)
	router.GET("/v1/betaAppReviewSubmissions/:id", wrapper.BetaAppReviewSubmissionsGetInstance)
	router.GET("/v1/betaAppReviewSubmissions/:id/build", wrapper.BetaAppReviewSubmissionsBuildGetToOneRelated)
	router.GET("/v1/betaBuildLocalizations", wrapper.BetaBuildLocalizationsGetCollection)
	router.POST("/v1/betaBuildLocalizations", wrapper.BetaBuildLocalizationsCreateInstance)
	router.DELETE("/v1/betaBuildLocalizations/:id", wrapper.BetaBuildLocalizationsDeleteInstance)
	router.GET("/v1/betaBuildLocalizations/:id", wrapper.BetaBuildLocalizationsGetInstance)
	router.PATCH("/v1/betaBuildLocalizations/:id", wrapper.BetaBuildLocalizationsUpdateInstance)
	router.GET("/v1/betaBuildLocalizations/:id/build", wrapper.BetaBuildLocalizationsBuildGetToOneRelated)
	router.GET("/v1/betaGroups", wrapper.BetaGroupsGetCollection)
	router.POST("/v1/betaGroups", wrapper.BetaGroupsCreateInstance)
	router.DELETE("/v1/betaGroups/:id", wrapper.BetaGroupsDeleteInstance)
	router.GET("/v1/betaGroups/:id", wrapper.BetaGroupsGetInstance)
	router.PATCH("/v1/betaGroups/:id", wrapper.BetaGroupsUpdateInstance)
	router.GET("/v1/betaGroups/:id/app", wrapper.BetaGroupsAppGetToOneRelated)
	router.GET("/v1/betaGroups/:id/betaTesters", wrapper.BetaGroupsBetaTestersGetToManyRelated)
	router.GET("/v1/betaGroups/:id/builds", wrapper.BetaGroupsBuildsGetToManyRelated)
	router.DELETE("/v1/betaGroups/:id/relationships/betaTesters", wrapper.BetaGroupsBetaTestersDeleteToManyRelationship)
	router.GET("/v1/betaGroups/:id/relationships/betaTesters", wrapper.BetaGroupsBetaTestersGetToManyRelationship)
	router.POST("/v1/betaGroups/:id/relationships/betaTesters", wrapper.BetaGroupsBetaTestersCreateToManyRelationship)
	router.DELETE("/v1/betaGroups/:id/relationships/builds", wrapper.BetaGroupsBuildsDeleteToManyRelationship)
	router.GET("/v1/betaGroups/:id/relationships/builds", wrapper.BetaGroupsBuildsGetToManyRelationship)
	router.POST("/v1/betaGroups/:id/relationships/builds", wrapper.BetaGroupsBuildsCreateToManyRelationship)
	router.GET("/v1/betaLicenseAgreements", wrapper.BetaLicenseAgreementsGetCollection)
	router.GET("/v1/betaLicenseAgreements/:id", wrapper.BetaLicenseAgreementsGetInstance)
	router.PATCH("/v1/betaLicenseAgreements/:id", wrapper.BetaLicenseAgreementsUpdateInstance)
	router.GET("/v1/betaLicenseAgreements/:id/app", wrapper.BetaLicenseAgreementsAppGetToOneRelated)
	router.POST("/v1/betaTesterInvitations", wrapper.BetaTesterInvitationsCreateInstance)
	router.GET("/v1/betaTesters", wrapper.BetaTestersGetCollection)
	router.POST("/v1/betaTesters", wrapper.BetaTestersCreateInstance)
	router.DELETE("/v1/betaTesters/:id", wrapper.BetaTestersDeleteInstance)
	router.GET("/v1/betaTesters/:id", wrapper.BetaTestersGetInstance)
	router.GET("/v1/betaTesters/:id/apps", wrapper.BetaTestersAppsGetToManyRelated)
	router.GET("/v1/betaTesters/:id/betaGroups", wrapper.BetaTestersBetaGroupsGetToManyRelated)
	router.GET("/v1/betaTesters/:id/builds", wrapper.BetaTestersBuildsGetToManyRelated)
	router.DELETE("/v1/betaTesters/:id/relationships/apps", wrapper.BetaTestersAppsDeleteToManyRelationship)
	router.GET("/v1/betaTesters/:id/relationships/apps", wrapper.BetaTestersAppsGetToManyRelationship)
	router.DELETE("/v1/betaTesters/:id/relationships/betaGroups", wrapper.BetaTestersBetaGroupsDeleteToManyRelationship)
	router.GET("/v1/betaTesters/:id/relationships/betaGroups", wrapper.BetaTestersBetaGroupsGetToManyRelationship)
	router.POST("/v1/betaTesters/:id/relationships/betaGroups", wrapper.BetaTestersBetaGroupsCreateToManyRelationship)
	router.DELETE("/v1/betaTesters/:id/relationships/builds", wrapper.BetaTestersBuildsDeleteToManyRelationship)
	router.GET("/v1/betaTesters/:id/relationships/builds", wrapper.BetaTestersBuildsGetToManyRelationship)
	router.POST("/v1/betaTesters/:id/relationships/builds", wrapper.BetaTestersBuildsCreateToManyRelationship)
	router.GET("/v1/buildBetaDetails", wrapper.BuildBetaDetailsGetCollection)
	router.GET("/v1/buildBetaDetails/:id", wrapper.BuildBetaDetailsGetInstance)
	router.PATCH("/v1/buildBetaDetails/:id", wrapper.BuildBetaDetailsUpdateInstance)
	router.GET("/v1/buildBetaDetails/:id/build", wrapper.BuildBetaDetailsBuildGetToOneRelated)
	router.POST("/v1/buildBetaNotifications", wrapper.BuildBetaNotificationsCreateInstance)
	router.GET("/v1/builds", wrapper.BuildsGetCollection)
	router.GET("/v1/builds/:id", wrapper.BuildsGetInstance)
	router.PATCH("/v1/builds/:id", wrapper.BuildsUpdateInstance)
	router.GET("/v1/builds/:id/app", wrapper.BuildsAppGetToOneRelated)
	router.GET("/v1/builds/:id/appEncryptionDeclaration", wrapper.BuildsAppEncryptionDeclarationGetToOneRelated)
	router.GET("/v1/builds/:id/appStoreVersion", wrapper.BuildsAppStoreVersionGetToOneRelated)
	router.GET("/v1/builds/:id/betaAppReviewSubmission", wrapper.BuildsBetaAppReviewSubmissionGetToOneRelated)
	router.GET("/v1/builds/:id/betaBuildLocalizations", wrapper.BuildsBetaBuildLocalizationsGetToManyRelated)
	router.GET("/v1/builds/:id/buildBetaDetail", wrapper.BuildsBuildBetaDetailGetToOneRelated)
	router.GET("/v1/builds/:id/diagnosticSignatures", wrapper.BuildsDiagnosticSignaturesGetToManyRelated)
	router.GET("/v1/builds/:id/icons", wrapper.BuildsIconsGetToManyRelated)
	router.GET("/v1/builds/:id/individualTesters", wrapper.BuildsIndividualTestersGetToManyRelated)
	router.GET("/v1/builds/:id/perfPowerMetrics", wrapper.BuildsPerfPowerMetricsGetToManyRelated)
	router.GET("/v1/builds/:id/preReleaseVersion", wrapper.BuildsPreReleaseVersionGetToOneRelated)
	router.GET("/v1/builds/:id/relationships/appEncryptionDeclaration", wrapper.BuildsAppEncryptionDeclarationGetToOneRelationship)
	router.PATCH("/v1/builds/:id/relationships/appEncryptionDeclaration", wrapper.BuildsAppEncryptionDeclarationUpdateToOneRelationship)
	router.DELETE("/v1/builds/:id/relationships/betaGroups", wrapper.BuildsBetaGroupsDeleteToManyRelationship)
	router.POST("/v1/builds/:id/relationships/betaGroups", wrapper.BuildsBetaGroupsCreateToManyRelationship)
	router.DELETE("/v1/builds/:id/relationships/individualTesters", wrapper.BuildsIndividualTestersDeleteToManyRelationship)
	router.GET("/v1/builds/:id/relationships/individualTesters", wrapper.BuildsIndividualTestersGetToManyRelationship)
	router.POST("/v1/builds/:id/relationships/individualTesters", wrapper.BuildsIndividualTestersCreateToManyRelationship)
	router.POST("/v1/bundleIdCapabilities", wrapper.BundleIdCapabilitiesCreateInstance)
	router.DELETE("/v1/bundleIdCapabilities/:id", wrapper.BundleIdCapabilitiesDeleteInstance)
	router.PATCH("/v1/bundleIdCapabilities/:id", wrapper.BundleIdCapabilitiesUpdateInstance)
	router.GET("/v1/bundleIds", wrapper.BundleIdsGetCollection)
	router.POST("/v1/bundleIds", wrapper.BundleIdsCreateInstance)
	router.DELETE("/v1/bundleIds/:id", wrapper.BundleIdsDeleteInstance)
	router.GET("/v1/bundleIds/:id", wrapper.BundleIdsGetInstance)
	router.PATCH("/v1/bundleIds/:id", wrapper.BundleIdsUpdateInstance)
	router.GET("/v1/bundleIds/:id/app", wrapper.BundleIdsAppGetToOneRelated)
	router.GET("/v1/bundleIds/:id/bundleIdCapabilities", wrapper.BundleIdsBundleIdCapabilitiesGetToManyRelated)
	router.GET("/v1/bundleIds/:id/profiles", wrapper.BundleIdsProfilesGetToManyRelated)
	router.GET("/v1/certificates", wrapper.CertificatesGetCollection)
	router.POST("/v1/certificates", wrapper.CertificatesCreateInstance)
	router.DELETE("/v1/certificates/:id", wrapper.CertificatesDeleteInstance)
	router.GET("/v1/certificates/:id", wrapper.CertificatesGetInstance)
	router.GET("/v1/devices", wrapper.DevicesGetCollection)
	router.POST("/v1/devices", wrapper.DevicesCreateInstance)
	router.GET("/v1/devices/:id", wrapper.DevicesGetInstance)
	router.PATCH("/v1/devices/:id", wrapper.DevicesUpdateInstance)
	router.GET("/v1/diagnosticSignatures/:id/logs", wrapper.DiagnosticSignaturesLogsGetToManyRelated)
	router.POST("/v1/endUserLicenseAgreements", wrapper.EndUserLicenseAgreementsCreateInstance)
	router.DELETE("/v1/endUserLicenseAgreements/:id", wrapper.EndUserLicenseAgreementsDeleteInstance)
	router.GET("/v1/endUserLicenseAgreements/:id", wrapper.EndUserLicenseAgreementsGetInstance)
	router.PATCH("/v1/endUserLicenseAgreements/:id", wrapper.EndUserLicenseAgreementsUpdateInstance)
	router.GET("/v1/endUserLicenseAgreements/:id/territories", wrapper.EndUserLicenseAgreementsTerritoriesGetToManyRelated)
	router.GET("/v1/financeReports", wrapper.FinanceReportsGetCollection)
	router.GET("/v1/gameCenterEnabledVersions/:id/compatibleVersions", wrapper.GameCenterEnabledVersionsCompatibleVersionsGetToManyRelated)
	router.DELETE("/v1/gameCenterEnabledVersions/:id/relationships/compatibleVersions", wrapper.GameCenterEnabledVersionsCompatibleVersionsDeleteToManyRelationship)
	router.GET("/v1/gameCenterEnabledVersions/:id/relationships/compatibleVersions", wrapper.GameCenterEnabledVersionsCompatibleVersionsGetToManyRelationship)
	router.PATCH("/v1/gameCenterEnabledVersions/:id/relationships/compatibleVersions", wrapper.GameCenterEnabledVersionsCompatibleVersionsReplaceToManyRelationship)
	router.POST("/v1/gameCenterEnabledVersions/:id/relationships/compatibleVersions", wrapper.GameCenterEnabledVersionsCompatibleVersionsCreateToManyRelationship)
	router.POST("/v1/idfaDeclarations", wrapper.IdfaDeclarationsCreateInstance)
	router.DELETE("/v1/idfaDeclarations/:id", wrapper.IdfaDeclarationsDeleteInstance)
	router.PATCH("/v1/idfaDeclarations/:id", wrapper.IdfaDeclarationsUpdateInstance)
	router.GET("/v1/inAppPurchases/:id", wrapper.InAppPurchasesGetInstance)
	router.GET("/v1/preReleaseVersions", wrapper.PreReleaseVersionsGetCollection)
	router.GET("/v1/preReleaseVersions/:id", wrapper.PreReleaseVersionsGetInstance)
	router.GET("/v1/preReleaseVersions/:id/app", wrapper.PreReleaseVersionsAppGetToOneRelated)
	router.GET("/v1/preReleaseVersions/:id/builds", wrapper.PreReleaseVersionsBuildsGetToManyRelated)
	router.GET("/v1/profiles", wrapper.ProfilesGetCollection)
	router.POST("/v1/profiles", wrapper.ProfilesCreateInstance)
	router.DELETE("/v1/profiles/:id", wrapper.ProfilesDeleteInstance)
	router.GET("/v1/profiles/:id", wrapper.ProfilesGetInstance)
	router.GET("/v1/profiles/:id/bundleId", wrapper.ProfilesBundleIdGetToOneRelated)
	router.GET("/v1/profiles/:id/certificates", wrapper.ProfilesCertificatesGetToManyRelated)
	router.GET("/v1/profiles/:id/devices", wrapper.ProfilesDevicesGetToManyRelated)
	router.POST("/v1/routingAppCoverages", wrapper.RoutingAppCoveragesCreateInstance)
	router.DELETE("/v1/routingAppCoverages/:id", wrapper.RoutingAppCoveragesDeleteInstance)
	router.GET("/v1/routingAppCoverages/:id", wrapper.RoutingAppCoveragesGetInstance)
	router.PATCH("/v1/routingAppCoverages/:id", wrapper.RoutingAppCoveragesUpdateInstance)
	router.GET("/v1/salesReports", wrapper.SalesReportsGetCollection)
	router.GET("/v1/territories", wrapper.TerritoriesGetCollection)
	router.GET("/v1/userInvitations", wrapper.UserInvitationsGetCollection)
	router.POST("/v1/userInvitations", wrapper.UserInvitationsCreateInstance)
	router.DELETE("/v1/userInvitations/:id", wrapper.UserInvitationsDeleteInstance)
	router.GET("/v1/userInvitations/:id", wrapper.UserInvitationsGetInstance)
	router.GET("/v1/userInvitations/:id/visibleApps", wrapper.UserInvitationsVisibleAppsGetToManyRelated)
	router.GET("/v1/users", wrapper.UsersGetCollection)
	router.DELETE("/v1/users/:id", wrapper.UsersDeleteInstance)
	router.GET("/v1/users/:id", wrapper.UsersGetInstance)
	router.PATCH("/v1/users/:id", wrapper.UsersUpdateInstance)
	router.DELETE("/v1/users/:id/relationships/visibleApps", wrapper.UsersVisibleAppsDeleteToManyRelationship)
	router.GET("/v1/users/:id/relationships/visibleApps", wrapper.UsersVisibleAppsGetToManyRelationship)
	router.PATCH("/v1/users/:id/relationships/visibleApps", wrapper.UsersVisibleAppsReplaceToManyRelationship)
	router.POST("/v1/users/:id/relationships/visibleApps", wrapper.UsersVisibleAppsCreateToManyRelationship)
	router.GET("/v1/users/:id/visibleApps", wrapper.UsersVisibleAppsGetToManyRelated)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9bZOjOJYw+lcc3BsxMxGuru6dmd1nej+RNlnFtNP42mTWVExUOEhQOnkKAytwZrk3",
	"+r/fQLxYgABhXm2fL1VpkIR0dN7P0dH/Crqzdx0b2b4n/Pq/gqe/or1G/hR3aK35pr2bI93SsOabjh08",
	"d7HjIuybiLTSfB+bzwc//JV5Z+nOq2OpzrOm646C5/iwe/SQgtfoBWFk62EzZB/2wq//FpbKUhKmgry8",
	"X0v/36O0VLfKevsgL+bCVKAfyUtVWm4k4dtU8I8uEn4VPB+b9k74YyrstP2zZdo70TZmju0jL1xW1O7Z",
	"cSyk2XTDjbk/WJqPjLZn8upg7GAF3yMNq69o3/5av5uGJ+7QnWaTyf+/GL0Ivwr/z8fTjn6MtvPjb1TT",
	"P6bCXvMPGCl4c9jtkOebb6ibGe6RYeqapWAVI83fI9uX7RcH7xNcavNjLnZeNNv0jwqe4YOBPh/2Dm77",
	"Ix76cdAsglq2/wlr7qupi7axPBimf+z0Ywru5iMHG6Pgl+4j4wt6FnUdeQU082Y6VkC1Mw37jmMr+F6z",
	"fc1rfUrxd9ZIs0zPN/XOP7DCjuXYO2REW6rgjWZ08Ok/kifO8/9Fuh9MxjQoaJ/maJn2d6+KrtfIcw5Y",
	"RwvSOBn9NGWNwcQ99sQw+p+DiQNG+O/o42RuUdOgi+lbQR+mYGAsjNVujTzXsT2UFxaG5mtVy2V+mRdW",
	"c0c/BCwoglVmxeTz8UgVi00WwbnoR9fQfLRG/3NAnl+8chCsIFhBsIJgBcHaqWBtSUSmRWP62yzZUiFT",
	"0jKCJVhct6aQeNNMS3u2kGwv0buKMDZ9B0cv8zj4fLANC8lsmOkhqazN3avvZezBGI5zRdpsl4q6fdxI",
	"W/WzvJ5vV+Ja/bqdKcG2qcJUeNxIG+YrFi6ZnoKlN4S/aN6DZqB7BwfMlj15W9sj5sRdbO41fFw4umax",
	"W3jfD4znnStqGFkhpr2aLmvzXDfg6F6xtmD6aM94zYv08fiN8Dx5oGGsHVPASM+KrDZUBUIxJfwqHLD5",
	"Acf6isDk0tZLnR6sPdujaq1ype1Me0cLUOZQmutufAejJ4Q9wiK625r0d2CLuLcoZnkZbtfFNvnUJ2CH",
	"eHfoGfma6LqEH5u/R7K2ox1ifgu2quZWrdGbid7nyNdMi9d2rbdB9Bcab9C4NqQIrp+wc3A7RfzoC4Du",
	"ddB9YerI9pC4wwgFRnUH+J79xC0g/MG0jO6QPRwdEJ0X0ZFtPHoId4zrBV+5AXTfaXs0Q7aPsGQHuqjR",
	"tcFQ/EEgCl6iMG3RdVcHrL9qXnc2Q+YrsD282+NipGAD4ZaZlOa6q2jkG2BMLkZrZCHN69yFwfgS4Do/",
	"rps66tK7tAo/ADvCtyN/FC4+BdXGUXXXLXD73yFfU5HnI+wtTPu7tkNeZSy5uQEZfbFdNCkKjDBWPdN8",
	"tCPuteqcgWS1pckDyZhHFv6atm4djBBTk/EcGykvwq//rjNyjbbfyuioAnGRkUloaILyXJkQzD0p3bxj",
	"vYiVa2l+MC+Pe09XUQ8mpg0awHE13L5RpdFbcP0Ki3d41k/L7U4gtgdTEIrnQ7ZKOiY8pZzlNMwwSwuJ",
	"ixIKZya4MUDHhrBk6/joBhhxfkZ4wSgbX/MRx96UdKbDf4p9HxDFK4mjsjMGdMdAT5p1QIX5Dpppeyvs",
	"uNhEvoaPs+DDzg5r7uuxaMiwk/pqYmOlYZ+jjxHt2bIogSFuoEbEVdjgEVvM9+gH2rs+++uxwK0jZg+u",
	"5WgGMubRjiXsyNB89ME390zmdfCQd9o81mxGkHHRvrS+eiHNKQeYdNuCTGCzpBrs645ED/oyqzoIVdSw",
	"qJgAaCwu2VtQJDsrBhN6l33lQKkByESExbstL7dr6UmWvghTQVyt1sqTNBemwlr6pzRTyZ/y8klcyMFf",
	"0r9W8lqaM/Pgij7Yol1cuIdcRnJXezqQkVsBbDZKBN+qrQoR9SRJBuUAZaYDlZTGq0DRmWWJ3vSMtd9N",
	"i3sid5nmDTLmQehfpmUepY/2ksbF/BbY6TXCCfvAfCn0yIFHqk4IjQBzkzimjoqNAKTtglR9dwCkjfym",
	"SHdsA4i+bXAC2XcLVCD8PnwxnOd+qlwvxOIpNoZoda2eYWQVn9UqO+b1punHlWOZ+lFFP/zqVkX+Uu/w",
	"HK1yrIfC2qeRVo6CXRF51LQ1eEglRQ98ZDPDqN2yAaOmrBRAw4mysOyCSYTPVZtpFS/oW2fYm4bolMag",
	"sw84VyEzHwE09k3nCK9zd3LhEvhW3HqlkMuRmN27feojLc+h/Nwk23PLs9D3kjzpxaApBmUrNN88dYMB",
	"+o7SPS6tbf/pKSm0KMacs3hnATOqSu67FJ/qFfgwr8BneOE+uqvwiV2FD6prn09z7YlXY2pZS2o/oR8U",
	"gGs5tJBGNzZKPiDD1ETPQ36SSJFGSoSxg706aEmGJKNJQV8WhnrZlCHxiyir8vLT9nG1UMS5MBXCP7Yz",
	"5WG1kFRJmArUn/eivChIGnrXsG3au3Zn/EcJ8Kh+OeDpjlGQu4o8HZvZlNAy41E8ndisnW4THUlkJq4K",
	"zLqH4YfEOK2YsycktVyxe7jGeeEqt3CCyOV43robuDYp/HGWH3Z0OHiu/5XX91oDNbI+17N1LjaSlCNU",
	"YxdLgridm/65KZevrP1Cy22QSu/FCPjRhkddX2FSn6sm4AJdao4s8w3hI29yalYL+2MqvJgWKjwbE7zc",
	"mL/TL03bR7sQM/fmHhWemnHDRd1jbY9Uc49mRSpK1FDea7vKJZBGZP5ESBGhfW9aaPaK9O/eYc/8QHie",
	"RnERPqVRcmlsj+mOLAXzzTSQw3bbj0BJiRBrg/xOynpEY4PikoJIO3oLYQil7KJ1rWVgTpCBUTIb6tvn",
	"hasvggrOVZ2oxX1rG027iVsz0bcU09tQpwg99aFNpSZcuiwmQpZWbwj7xYRW6s+hmo5IEnVbdIcXr+Hk",
	"ArvgdnlGYVNWWfQlUB/OECWcGkTAYqp40OlHX6d0OyPWGkd1K9bPHToZLbcaTZygFPitK7ENZCS9CnqY",
	"87TOi2es52qkhQv/1gEf7FRFzeFnFTa3pahukH/uWXBK1e03h4gBhSpwtRiiTgOujUP1TQE5UCyWBd3S",
	"fWjdo8vt+KvlvkNGw5I2nclgbnZSwxXcPmVcKB5XI7GpI27hCcHgcR1L1pFqdlNyOhoabMt6BYmrzUpT",
	"LyXFlWPaNb1a+sHznT3CCSmzrsfUEUrdTDeWIAsgcSu8IL7qq+0c3RavELsmTkCotC12EJJ8FU9owTRK",
	"vnWORq8mGDaAZZQDQhW0WtX/aLg1toyaw3EwhTIP3JJtaAdfe0IungWxhVTvsjJiPR3fvcDL4CASVFt2",
	"cGokXKKD4GQFzrZDiORLZ3uCyjhoD+SdAkMFuNqWHDHg2nGpNQbkkMIjDd6SfWh7Dy4SWlWQakzXDU8g",
	"3cVXePKczaFjGpXtVxjh1N1MlT3u8vfoVvc5mJbBNXLuHkLO6aTupeUAUnRMrLydVHA3Isf4VFI0N93w",
	"K7MViaf0vXKVrT8V3BdYjToIv6ycd4QfkI9NfYiz4BVku9ExQrb36vjDpCuTcVTnO7KZCmH4uigTsUGG",
	"o3nKPL6sHOURJH+dcKaTHMzU8ODnyQKlBWWdIvoqrjCerOTO8okvCJ3PzuFILfFbByjXTeJGER5WYW1j",
	"ZZSikM4lNGPaVeurnWrsJV3npuda2pEnoWrD7DQuCdSl66kWAYDrCZKQx6w2tJOHnGZBHGwq9bvHhOTO",
	"aLdGTjIXIDrPTO6Di405OTm1C62rsy0LVnpx7KEhe7nX7OW6DLRrPZgzhznVoUVtuEEmc1ql7tcJxgYH",
	"B+hadP3ngNhGCKYFoA4UVCgAc9WetJ7ePHjWcmvyuQ4b4cldpibWBRVcLsJWYmvulrp4u++Vx/V2tXjc",
	"CFNhKS+l+G/1i7R4Sn5tpCdpqUrSMnxQcMUh+UoY0xF9X9Nf98j2L67mCPjTUzsZRee60croT4CBnAPM",
	"iYraMJSZ1FnCL7Jtb8Hxfnl438gMSS31W7f42ZEdUo2pNVC8uV3CJLLurYnSxdQAwBUqs2eia0O9thq4",
	"NXalTW23CEEvSvEtB1IlZIt4e+khIsf2Nd2X9lHPHO5FDe5N7PmFUi1qtNCq26xeHbuo5O7eEXXdOdjF",
	"g1BtVprnvTvYqGq3ToCfp8GpYDsRWMZXhK6AxDt0YHfAU245ItetzxcMi/M1zxpGRcRUOZlv68YE8Gd+",
	"/lwvOjNq6mwjCnOG5cNNQK1Via6gIE6ya9PASfK2z4sTtKqItmE5ZSDECdHWLSZgZI0VzQHdLiWYxW3+",
	"FfLdijLnpDOv05z+UuI21x33iM3dK/smSZ1wHINZRv2Db+6ZCo/hvNuBba89p26XpDYcadgykeeXVWkv",
	"HN61ND9oWamYxu1C8Rd8SM1gyYO4fBQXwlQQ71VpvRVXq7XyRB5sZp+l+WPRPS0HD3my8aKxV/cWgxhH",
	"kZex2U9xVGiOdEvDneRgMD5xAyUnoGzP2XCD+FOnkGUmQ3XsLukiJfZ2PSarV81DRiQxuzXQUp+6PSLZ",
	"HJ73pte9HXz6zg3A+JkcLW4XnmTMG4Cdabxo3elqmdFvAJ7YOQS6qei6M+cN4eiOoBZBmv8AeKTP8gNy",
	"OaNj47navib1DaJjD+1cOd4FS6pzuqNwcVVOvzEw3BbdexWw6SD2UOY2uXn/Br1X6ebU+r7d0gWV49WA",
	"/mjxMs2a7L3DBDEm4VczivJzSWUcofxW5KnwHR3fHcwsODsVrOCzbG/7XsPfUaBNRDcC0kKbff+xs3eC",
	"WWiWin6w+ZN3cF0H+5wjvr9qvrcM75Ic832EPVwE1UYxkBtzYaTPrvVxxBQ2CTJzLskOqukgrWMTpcRZ",
	"PenXusp8qwIytXfhMr5Bhk6rGTrnEVL32mcxPdWjxXZyeFg8oVm9S8aJ4lq3Kn0bJvmnDML1Nqb1VKBG",
	"TPJaTIXhKzpUI0zd1J7UpFs+3FFA2Fxn+0dO6EMeNyndueodrwjYll9fgzGy/bl2XB72z2GN/fyxZZf+",
	"AFcS2CrfIyBxX8N+PR+l7/iatdIOHpofTkEpxqHNbr0DLcex62jW6d2tiQ3t31DaCipA4ngnamldNGw3",
	"gbwa/2oib6vKaJqMelX/2IuqCYz2b7rsjJKHzwVqgLF11a1WkbSp8sTKt615QUAHZfwrKLFCFOdTKHi/",
	"V/cKgILUrMrq+pmkmYGNzRoMJqH6mCTn0pO0UFbSeruWHpQnab69XysP2424kIRp6u0/pZkqzYWpIC+3",
	"a+lJlr6Qv5/EhTzf3slLcf1VmAoPkirORVWkO6yk5VxeftqKq9VC2q6lhSRuJOr5TFmqa3GmUo/oDyfN",
	"19JKXEvbe2W93TzePcibjawswxfKek7aivOv4ftw/qu1MpM2m2DE4Km4Wm03qrIOXuXaUhNmgeKLKKvx",
	"ONK/Vspa3c6Uh9VCFpez7PsEPGtptRBn0nz7RVY/b5fSl+2TtCazLit6xJErOMSZaHDiD+TEr5XMWcfQ",
	"oDCMg3Ukjc8yMUDZb6zs18KDTjT9Ihyogz2tqk8pod2jyGUspxoGHRzuLMsU6/is3KWee6tgRBeVStVB",
	"3lR7RlZdu6oj13Xb7mqwuC7a4hqB17/K09+6nNDeNNMKxIBsL9G7Sl0yzmS2zwfbsJBsFB7zR7a/DsSO",
	"lzk5khiVirTZLhV1+7iRtupneT3frsS1+pVYetIyMPQeN9KG+eobM5ho7jV8XBQlarTH/RNIZYDURWJZ",
	"i5e9V5d8JZcZd36PcecL4ZR5ncs5HtnWojxrWYbBXaJwl+gV3yU6kIgvFessNG81e+cFIeNZ078XV/qp",
	"kefIksBvmn5cOZapH4sa+W+Kt6IbjjOrH8podOK0fM5jeFN3JYto+Gir9wzjyyG/1nKGL/S03Jkn0M5D",
	"7w7ygCuxnY9Cmrlh2VrbWaX7eq7SVwYKPsj1nphbzVtGKb/boaAGdlrl3vHtd1t2XAHNtHFN1kWVXC8F",
	"cfGWQLH1Kyy2Drp4l7p4m+W5WVTIR6ytaBptFAkeRtPgLQfMaA7VgMdfDfg8Umuu1dSqBczo07JWk6XP",
	"W9Vq2CCu2pKyVL8yeg6QLxqBJ537LtN8cA0AKvf1pgW0l0RYhLn8SN5FAuGI83bqO6XCxXzrdI/bSRDk",
	"2mF+zGhRV0ynBtaWP3GMcTCNkS/FsKBLJ9I9DdHGEr4ZhAeX8SxgF2xQWD7x7NBfSeRgxPWzQLZ3Ldtz",
	"aNWGZM/jKi9Stx5zOxvv2wlx3bBGcQ5mdRTqqkAzXuRsrljkCeOS1IpigPBCsHVnVDcFXc5F34YemQpw",
	"8QK5Tb2NibA3qrWVALpga8L8yHre1XNutEqCu2G2HNtvaXqy7SNsa1YyLYZzs8iN6h6eLVMPoF3xunQO",
	"p2YFmeGnBgtzb/oFhWXSjUq+CNGpC72NA/maijwf4c7SzelPQDFW3mKske7Z1Z60YprdzHbw2niE37dh",
	"14WCo0zY3Z2oKrrqwavU9kZKx7x188vXzq2JjZaJjUYVKwY8YRt94VsHPKo+qmVW3DGWdcuWx49grXul",
	"uBR2Dl2cU9luS5emoUdmd2tXpFywWnod2twfbabi8+pFHXklGayljAk19z7GxzUbVtpt8WhliOm91z7L",
	"w7QM8K07LS+U+zfxpvKSWkMPKmO/yna2TU9pQlztlrUeE7EN5XjN7FXBjsr2m+nnSglJD6K8EKbC6vFu",
	"Ic+2C3n5G7M8BPOgd70CGXG3glr14Iu85jh6FnfacLfk8LEA87PtmmsKjPICl5ItXwgMTuC1XzinPb7Q",
	"EuI1FLLlEOMEc5uil4WtN5k7Xgzkgl3J5H3HeMWsQ0uX7KXq3IbF+QoK8lFqRy2aQfHhkoSVh09Ysc/S",
	"YyZmSimoQiRKhQi2uvhsyghkeZd1mCAEUyMidrJuOnQJtWE/QaASApXjDlRyOz4rVedI6BSIvfCt6Lp9",
	"BY3a56l1Qkas5XYbMepUhow6XhTC+uS16DEK3oWMqI9mrKV3HwTvWD5eAsrdUhCcvWSIgneLYq2HwVsz",
	"88pNNXq54QfOOclxsXr+FUd+29UqW4rrsoillK6I26HgTF+n91E+M6bQnvZNLYtz+R1dCnMF+SZtHyFr",
	"K8vk7HKJqcV9q0XJtXC1vRPq5cjKieHNQzM52uo+pFK4iNJFt7XUPmLo3LXMo2j7APkqGaCWgr7N4Mpp",
	"E/pObOhtU4YK12Q3i7WnWPvdtJL7YmiGuBCmgiotg3+/SIsnSZgK98rjWpXIs438r+gvSf70mfzJDNCw",
	"zyeXKu0/XDO8rqPeITXSr/Bwmu7YouchX3W+I7sK7PJe2yHSnGyUaSsedecbo3CpoyPPM+1dLtJ1utwx",
	"AJ8oL6LbKcmNlMJUCP9n3jXlWo5m1D2pd/CQt3Rs6Qfau75k6/iYLdmav7AKckmu5lyb5rqnTc9cfNMu",
	"MJmfuQ0Iw0WjLZ/E5Cox19geOa8C1TXAl1FqoEMXU9uFDW4vrBzobkU1pJtXdjmNfgPoH+h93bohZR0w",
	"vA6Gm7ZhvpnGQbPgAP4It8fFaJ2+HK1dFpQbHzK8awQ0yj3jxNZmGfnBC7FAZ4/CmzWd4sMaCtyhXK6F",
	"V7myRmoitegGZMKtTAspzUc/+M7S8c2XY+n5MfQjLBZEvsVVGVqKeyBfi2pDT8lhs3rDxFWKqGGgDOXV",
	"M9daWm81m6WIo5p+GkYqMt+7mIp+BUCohlf7R2R4WFKTczKt2lVVscIyYFUDt7XYTR4tb7FuXxFwyzbi",
	"tjI341UTAjT1QfJQWHNoTQ6kFsYLAbheoL1iwGfubkupG9W7y4sTLekJKXzsScYzl1G0blmvW10+Cd/W",
	"i9wG3XjO5slJdJgczevcHGjiSKzmSQS8ZbBvVQUgX7s4kZ0GQyGwsr7Km6k5WLF6qDrYXTp8APoWJEHD",
	"DKoVRjjtB65TAmZ6XuXvyqQudnIDz+fYF8S0VB4nZQZVjpnKH+AaP+KxFTuG8MvKeUf4AfnY1Cvbz01t",
	"Zzueb+obc2dr/gGj/hMPU8heRA2t+wNKU8VqpFDVUBSqE54uOHGn26BHU18Jn4ekVaWo5XRWYMbAjC9C",
	"ra5QqW3DQnLNdGDTQHZgW4ZnVHIcrriMoaX5wSqq6TWc1SpuTyIVyGBeIAF5sReaBRdt8kxztWfTMuMp",
	"dpMVxPgWJKDwJ6A4L6bV3fYk48OWtFhcJcL55v6rSESUiA+arlrT2TJDHy/Mo1UCGR5IHmveIZX043Gu",
	"ztKtCXr7vmnvPO79OQ2xCbvyHULv2Gd7Dpvnwn5qX7h2r/W6CSPdYBqQmSmedXVmkTraMGDGzQo7iJlF",
	"S/pWg2fXQ+AuatVXIDQXDTT1mLIEQKeOr8IFcC23dZfYhfP07pXw2kjM4XaKurTNvsdmMqdBnMwtmgn1",
	"3W/tqppt8iZejrSiYBhPWVY2wlR4EGdbZVNwSjrs3A4Ta+xsJAYShzOMwTM5fHi9hxgysC3ZvNa5qt24",
	"vG/P6kUGaNw8rG1LrHUH+khxekhzsdRGPEFAcQsCUcjTsZmNjVH1GEqz/8OXd8c5etEOls9u9R0dadz/",
	"10yZS9u/C9Por/8UpsJMeVgtJFXartaKKs1UWVkKUyH6Ic23j8uFtNlslZWUfa7Ki+29vN6o28eNtN6K",
	"j+pn0kJ+ENdft+JqtZ0py420VJksu1CIegfXdbDvfTEtQ9cwd6pxXh/KcxrLct6RIduer9l6FMqM7yFZ",
	"quuvpC7H8tNCCsTN40KVVwuJOXvOvau3PfJsoTzOt0/SehPuwlxURWpftitp/SBvgpfbhfQkLcLq7gtp",
	"K88J+CuBvjft1OLzFw4VbovjJgefa6qnEf4zKPzN9MxnC9Xf4ewlMiHkwhr4AQxWj+vZZ3ETbOMn8UHa",
	"zqSlKq3JLTObz9ulosr38kwMYBooFl/ExUJSSW81QOTVais+zmWF6ByroIW42SgzWQzwfq48iDLptpLW",
	"G2UpLrZPq2W4E9tPa+WRdPgsiQv1829yMOpn5UEK//oiryVCTeJsJm02yvprsFv38qfHtRgRXrifK/Fr",
	"fvsJcq7lcKilpH5R1r9tpX+p0nITLSREWZHQ4WdF3W5WCml7P9uq4qftWhLnYSGV2ULcbMKBxEdVuZcX",
	"i+1sLc2lpSqLi+CbT/KcACyc6faLfC9v5eW9sn6IZxrPYPa4UZUHMk9lpiwIS1lLD9JcFrefF5vtQvmy",
	"XYiqtJwR8vq6UaWH07S38nKjiougG+EiD+JS/CQ9BAicQW4mQs8C4iZ5k6imuXbqOHNsP7pMKDc+1YzL",
	"rMs0DziF6bmWdiysjHlutZ6OjBBsatbysH9mmj69+wgp8Df1DdKYwuItFD607g1sjES6h4uxNOvYO7XN",
	"4y+PgVgP6C3YiIWwL9+nZsYejQ/dGlCsKZevLCfelM12Hgh8ZRVxRvJE3qhr+e4x4seBeRzIIMbjiMdK",
	"68I+qcGjX9I6YL2/Sf/KPQv4ciQ/T6/izvQXKlh2W0ZPZi8vxpBggoKBGnP0Zuo1BZxm1K59ZpDPzCzN",
	"S2nGoRT+IqqzQK+QVyJRtFaflaVE/lDmiahWn0KkYiufjoGsHh1qvuYfMiq+eBfWj5vLm/BPZuE4wzTG",
	"IPzC7Wgq9yLcKcSq1qVdJ5tZvCe5K6+jxjW9otzAbkHesQBfuD/NpFy0+90KuMxEC5fSl3fwbNpv4Fbk",
	"xp8GTkUWFAuB3ZZsPWHQxYjVLABYMErSRRfOrufDtAb97cbsPbWQqpW2hhSpr14UbrDBUQq4U0ZxLe50",
	"2uesPj+XN79tv6xlVWKHszz6g7m378jcvdKGoB3a6wNoKHkQtYfPJ6jzbU77uE1lkrdQm+EaaIYBbNbm",
	"pKaX240zkjPpWZLuLJVOso1HD2G4JBwS2Bn6PsLY9B3cYd46/QnIjW4vNxqx6bqppCliF/ycpXXTmYP5",
	"pEzRVPMzMjgv+eqdSyboBpfysOfUBfF0kKjKRUf89NfMNVJE/+fodmq0K8eeS8RVAYYflu2XjGtPkarg",
	"YhfOCXqViA28T1yIw0I4jJ2Su6ZQ8Nor2SLdMdh2sJHUVs29KtjWUNVOZ72lP+Y6pB5qAb5GkPin59ir",
	"qGF+wbkhNaztUeWgq6RZbshvKY9mHlnDESrjwgEcE6jF3ZKRz7umMl9StujuntOPrfSvmbSKI5By/Gyl",
	"rNUtyUaTxeVMEqbCWhLnX7f3ynp7J6niVpU2ajiWvMw+kf61ktfEvZvptHm8i1Kmwn6572zX0pMsfSFp",
	"QHIw2qlv8ib+XvIg+vVPkgoX/xZXq7XyVBBU+qTt0QwFKBNV0CysDt5BGS/eyAsdcYnuNtqEKwBD+FoM",
	"4QD0mm8+W6f68R0JzV0ByoN13KZ13ADKpeZxIcNizKmo7SyHaz3Vf+sJ9Xht1XPg022FuP5pc7T14oo2",
	"p614QiEhtRFUqDP4aOML1TvA2LZ0ydF0utJ2oyprksMvbTbiJ2mzpR+STKbUE/Vpq2y2n5UHabuZrcNb",
	"OcNnqrLabj5Li3umUicbL1pprbFSAzl5J+pB7y+m/7rC6M10Dp5YcOqD6uO6JJPfCpUk1anq+urYDvYW",
	"5t70kSEaKtb072nNjmrsIfyGPNHwGhZt60rzgxsEe70AwkzjeVPVIks2LOpON2nf037BxMfORiubEz3m",
	"tGrtxbM9L8JwMbR6rlc+tcBvnZBTB774UgqrpshmvvcsB+jWS1409epVtu8VvwGh3xzdG3ipSzeQteEn",
	"R1lus16ziVbUOUkf7d1Agj9itgf63TT8V1ZXFiBlW3Td1QHrr5pXM8nMpLvmVOFHVXkQVXkmLhZft2tp",
	"KX0R7xbSdvN4t5mt5dgHu1SW5NTo40Pwlhzgo34Eb0lXefkp2/N+LWVGY6nJLnaMg+7LRdGdSH9ZlmXz",
	"ptY1W0ti6Hg9HUvZyJ+W0nyr3N+nHovhydmlJM2jDgtJDc8dbldr5dNa2mzC4wuh7zZqEbmSH4Jn2/u1",
	"8rDdiAQap5FZb2kX8uNqoZCjEpTne6Ys1fCYzFpaLcRZ9JnEj0z3Dy2RzWdyhHO1llbiWgpf0C7t2H/+",
	"IKniXFTFxAOuKmFDNTMs7dRO/l5Jy3nQgF7dQhI3UrMk6a7U/85clm24gME7SfN+mj01thtSbLKKjzbU",
	"UFLf6lg/YU67an1t+adyK70Yv1EBOJiAG1uYsiwUyZKhv5mGJ+7QnWYb9Nzv5SdpKy7n28dleF5/I/8r",
	"YP2S/OkzOfovLyXyeyE9SWzpzNi5HEK9mDjUf/lZlR2lfXTK3LjygvMI9ms+Rr9jFgyxAs25QAF0fM0q",
	"UPDoaYXtptFQlfpsNBPmOjIl0esdRiBnYmIFMX82kwzJOqcgTIXPIkHeO1FVJVIjZSE+Lslh0AfpQSFP",
	"xKUcFYZgKoAFNb0GUC5y1YzTQG0qorJ7VL2NbbHxfMH8y2HkhSBhgS9g9kZ0BXqOl8vLQOF/kkjlkuiP",
	"lfi4ITw3LnXEZoNVdeeikAC7c+5S9rZ2lXFxRZt1veLLNq6tRFfJhrBwKgflWry1QXoNJNZc0RUJ5Dae",
	"zi5FaOM2crBNUxcZZHlEU+GfYyM8vKaZncoUECMXCOdZycWAY0P5zUTvuUI6pGrJ9j//nlQw2f79/1B/",
	"U8//9l/U3z+f/v7r36MiKNvVWtn+9ZO03P7yH//IP/uFfkS1+OXnZIB//BdxKG5+U5VVkpewkdaytNn+",
	"Lfvgr3SRFbYOEpborFeaioR9ataJGVXJsug6krIiblGTnLKYaIjy8klcyPMi53XQmVWSKV85KX4aJ5bE",
	"v8X5Z2VG/ZaXn5VHUp6QXYEpfprksSS1ndbSTCWqKPP7yeNTZktmBsmD9BRmoiouvm7UgrmkXtOTSvcL",
	"Z8esqXMwx3gd1LivMLiIdGK6WFxHuk+9gnSgAUVDxSVpOtqVViregEp65t1aFYpoqAowFaNQXPZX9Qvk",
	"Z2P5mfURUyCNtKobvb7n0uUP7yovkZX/UbWnKbBO6929xM8oO0idY/LQYl7b1MCPb15oZtYn10Jwlnur",
	"UXG1d0dAGqzFkG/PC5/sQau+9zHuyTDe+sx2MbY0bdr1VlRq7Rx8096Jrjtz3hDWdnXL8Hoe8ufIMt8Q",
	"PiYeiArf2gMyTI0kJYY9/pgKAXwKE+SId8P8HbEj1SHc7gOO9Yr0795hzxzk4FqOZiguitM0eanjMd1x",
	"gKsl4cDIyA6M4BzVNDVpGHTIRa2tGzpnE2Jmtck4VC84YNHOAYuz0K8DRbEKHbkwuJn6yKCbbrWzkgVw",
	"Lbf1Ixe1xB8yWj78cBYqNjj/UAVQxko2OkbI9l4dfx7eVcM6UUtHzqjfJHpG/868J1E0+vfP6d9/PbXP",
	"R9QYz3/JPs60DKNryc9/xJ8/RdmCX7lIW+5hFG3bUtcayNFh4m0WHKwXYVSR9aKoRxhvZL34Of+CEX0s",
	"afBL4fuivlGQMvf8H//FjO6op/JYLVlczQuqDWHHsODAILjT4urFag84UNuOY7ibolZBtFLF7gSMMkg1",
	"E4IpbOpQ9uWny1hT1lzKJx0je8c+O0bw99Vhb6zz8hKdYst3wyH3/4w0A+GzLbuwO4siD8xTcH9Urz4a",
	"kj+c8KZZB94bYR891tCl1rplia7rPRXfSzgNc+ELLQBLK3npYufNDLTYQEKHd1Gyv4EdC9XYJg/htcP2",
	"Tx08hJtfotuJWR7d/ijCea7LCVAG6NSU4xOyLCBX2X4z/XOKqXAQLtpH5SITaIdPWsxwuiTeAOQP5H8O",
	"+Z9ItA1GQBF8JUtovwpMu1zjwqg/7Y2Mp05NNP5aDIQz3JMXSeQ90UYLDsYy+qgkp2Y2VYZ4zyleR7LI",
	"ew0dFwCgElRtuTXyQGtcAbAJEIfwkRQBtmAPmiPpBaFmJTAcK+2YnT/IpAyLvIzOoqvS7PNSnomL8Op2",
	"5XGpbj8ri/Bs+FoS51tluSD3sIsLKTzcuP5Nik6ni6tVdP/6mq50croFXlW2a2mlrNWgZ3jvu7Tebh5X",
	"wTOmZzCYdftFlDjE9pjVaZCZNc3JBvGQPAIW0NbTCeo9FSnuZBO40gkL19tt0eFOzbHR1hcOgN2m/nCz",
	"WkOJrkBsaf2ATf+4Cb4Vc3T9wzPSMMIffOc7Ii6l8Pd9bMv984sqTAUyPyIXyNvT+K++7wp//EE8QmEF",
	"mbmjR/U0PB2bbuipEkTXnZAshcnMsW2k+xNxJU9iGMXmLfGSkzG9Xz9+NNAbsgJM+ElzXQv9pDv7jwbd",
	"42NAL8Ggejim5prhXr84hNwi0DC/LVAnzIVffvoPYSr8+HA6ZheQ4paMvY0G30ajOy6ygz9/Ff76088/",
	"/SJMBVfzX8mSP7798lHbobXmm/aOLuj38X9N44/UVSceSX5Mw8h/RRPTmDgvk+CvKCKBjAmO/EZCsDTh",
	"V/K9OK3915AbnDDExwcU7ZdWUCvuSKDimXs3ENPfyAJ0Ek5x4qiDbARwYy0lFBWkyGLogYnmeecYx/Ay",
	"muSYYbBrph7u1P/1QoflaWKlxMf4clpGEZTLoBij0wQjFyOPQrE0pAhxhTRDdvA/fv6500UkBMqY/8a0",
	"dxaasLoF+/a3FqeWvnGIMZfkrp0JuX3oz95fwin8tb8p3Dv42TQMZIdTCL//t/6+v3T8yYtzsA36+//o",
	"7/sRpk+Q7Zv+kdqHQCppO4+YNywKFb4FTQgvct2Z5qNdcvPXLgx/ZsicbvUJ+TPHspAekUspw3oxrQBF",
	"no+TxBiZ/Cnmod6fBBImsMjtVC+a5aGIf/3PAZFgdsTAwlH+nfT7JtD8KxHWtUvOZEV3zPiic9HFi0E/",
	"TM9Hto4mDp7Yjv2BevAyifzYkz+5Gka2z7tKMob377BTwRKbLiEQGy8msgxv4juTSOWZvDh4gpF/wDYl",
	"SzwiZo4umqSRhHfLgo/8O9W1YtvChQuno+zBt7zDs376dgubuNd+mPvDnlqmi/DEDZNhWSsJi47RM4+G",
	"EH79j59/nrKSxctnoDv7vfbBQwHhBGhimZ6foE1s0lLbwwnxU2seGHcG1/AidZoMUp864dmf31+RHegx",
	"x4mGUbxY4y9l2/Dv1Fjf2Lvyd45N+dalVKdxvox/L6KNT3UAQY7TAiwFHLbgSpRnLulFaaaVyvZt80rg",
	"VLfCqY48ZsepNTCpEVgbJUxyOko3QiHr/hgROxcHX5G2n5CvOoqN1lHOCPDy0bGNaGtOWAVMA5hGi0wj",
	"TSJcvGNDdyEs5EGzj8BDxmo7j8pMwxl+BqYaMLRGDE2ydXwks0k5Z0s4GbtHex7ZMx2yg/tjTePP3l9S",
	"rlfNdWsuRnPdjpyuZfMMaxLXnGrYaWQu4gJsrivy2MNUYJjmusJUKOodFgCZCtqbZlras4UU+x4jW38l",
	"IV8hKTs9FXTHQE/kdNSU8DPNtL0VdlxsIl/Dx1kwtrPDmvt6pFqoryY2Vhr2sw3iUHSUCRz/jIqOxT8f",
	"sUWghPYuLcGF03nqeTj/g4e80wLBGd7UxRRgTQtAPJdg6tMGBxnI9ovjhbSQrjpBob9sL9E7dc6Wfpd+",
	"/Ix8TXTdhaNrlvl7QtHR4zWpDz1HfpjLHzz9hJ2DGzdZmDqyPSTuMEL7UD0NHquBmMUeTXdJ3bJprEas",
	"zd2r76VvuEW28eghzBi2+Cr2afb6rKlgegqW3hD+onkPmoHuHfybSWZhh2Sau85kKrgYKdggWS2MiufB",
	"Q1L7jfyx1/CRAIxg3/fD+Ix3NovljFQUsHlQhbOqaAGg6AgGu0llNKNQC+w6sgEi/vJEPAhYELAgYEcg",
	"YPkibMyuIF1H52gqlO6X6XQKPerRtVX19A7RdXsKxgE/B34+CD+HKCfw6rHx6pT+/pG6OG+c50ccr45M",
	"ITeoeeFZfCpGGy23qyMlBbMJJ5M90MgRKLSiLhxnSv6WPw+1Oeg68rzJn21nEq0PKHuURyy4fD2BnpFW",
	"CwJiLSKLXOuQFro+VJX/cLoeButMVb5P/SNVv3S5BD7DK9sL5PhoqS1PSqWElvhTDWShsBJZNb3NSdsU",
	"vZ3PsAGLQGZwYfG00PbOte7B3Z+fYV37OzcCnz0uTAUrNghjGxObb5p+XDmWqR9V9MPPPgtd7N7hOTzT",
	"ffmecwKI0ZnCIFyv1Ehms6PLqkbAWEU/xQjyH66uRdCG3gykDaR92RpPWm+vzn0grXrSfc7Td7gTGVjq",
	"VRyFSMo2UM/iHIdnrP1uWnSL76bhiTt0p9nGyaWenNVLnpxOPxwVGzGfq++B8uUh3bGN9BjJs9worDfB",
	"OFeQvFC4T1cEYzjWAvZRy+eoWStreJy6GlhjOlUdTJVffQKVaZTW0OVaQL1aPbyWzgisGyBJsGJasWKK",
	"LJfCQF+pOVPg3q11OJl5rC9UEmoeLgs7jexwGZhjl2wqgKJ826fsLiOUAUUAQHnvNb2P0huyQqJKZVil",
	"20M1JKiGBHzjdvlGRgnk5B7pXsBDgIcADwEeEpmL9XmI+u4ADwEeAjzkBnlI3kVVxT822R7AO4B3AO+4",
	"Zd5R04rZsPsBHwE+AnwE+Ai3JbNh9wM+AnwE+Mit8JFVVLCk/Fh20qqv49jxB3mOYcdtBz5+HU+DL9kq",
	"bg2kO9qEpxNp0ElPyVOe49VJYzhWDel5/WFr8XHqpFUPR4lOM6qr4CU9eXPYokJbUTHRuAiXGNcqI89v",
	"sqZox8oqyLwrUVfT3OPScv+T2feV/x9/kOcMwPnqKZAqkOoFqsdvJnrfIL/Soozb9WhTRp/ktCqj1sPb",
	"ldFEuEk3ag/EO2biScikgHw47cu4OViYwPD7xNlSGzNu14+VmczqDDsz7lttaUaNGTWzU2VgiPkZNCRX",
	"YVy+0cm57AFPWVEzPGv7+fc+kKlTQfM85M+RZb4hfIxPw72YForuQgn+3Ji/B3/uzT2KrkSJsOI+IAHV",
	"3KOZY1CP5X14Kipc3r1podkr0r97h9NdKUpMZx51fYowFd5MAzmP2Oq8tEEMruYVDdiAH1MhA1C6rsu5",
	"kRJco4/IpVTAjzSLK4npU/1Ov3q77BmYcGtMGDQhOE9cSQFjDAUQpIDDxCA0RyA009eEtChCT3dxlEKk",
	"d17Vm0JMQeZ0Nwg/zSeXgwDJA8m3HgZkkO8auZam93qdTgWxwEU64FutFw/giqX1HUirEUUbRwitlisH",
	"5NPYiYVNKTXCZhAzA77eH6pWBsx6jJaBm+5a4nJj9gWBvL0Ke/CijcE+U0KD73FmhJ6nFAORApFemFJu",
	"6mjlmLZf4XdNmn1C/syxLKTHISS+4s+m8WfvL7Tr5E/kpnXVRLhmGeikX0eVoMvm7Ed36h9rzjnpN7Lq",
	"1fT211c4k74VOqd+8HxnjzDpEd+xH+wg+dvRESKX9idAglBkU/WThnCrYD0L0eIZ1C4lQHWsRDGMka0f",
	"x6hqJ2TCE4VJ9wBxztB5T9ApkGSVd7WlxVn3Jv21MllgccDiUuTEa6vE7YG/jdCnQPPX8aeVpLn+xxMr",
	"4OP/aty+j6pKt8slEjBD1STgDv1yh0BHqHZukFZNfBv1HAKmMUZPQAiqs3RU0vUbh8oWIw+Y+C3ov+0B",
	"E4wb/qNWFOgbHrVyiyAwrqNWMX3XcWCEvAQkOFOChsDJuS/IYz7vRSyvenFeXJZcAK4MXPmGuHINnwvZ",
	"G2DJozSqYpFwOTZVckkPdwSZdEs733s6+wphzks5xVQrWgbnFIG7tc/dOFXw3tTvM5kWX3HWE5e6gvqr",
	"zZbTB2+roa0BLxsnL7sEPrbRMUK29+r4lYUe0037OqKW+irPQbVUh4GPq6XmwkfRqS5A2aPNks0QDu2i",
	"S7/iOcaW7gGH2SDFu2fkLT7Slm7agyabmVtdjTbdvVqzPbWvroLkJW3npuda2vFKKkPyw2BAV3V6kuci",
	"RS2MKDn5SB6qzndkJz/CE4/sI5HmXtshMWh2znHHrutBUuBpXhKyENZjcoqDYnZ1JhdDpl2S6ZVUiKT5",
	"XIlnKd079aA3d/ktimoQX0OKr5stGJne1dG5LCkMhXAMyNPRyNNc8cjWpeuNVpFMASgNH6glCXxgXBVE",
	"yqh5gKKSXLQDpSXBa3tOyIE3hjdAAK9e9G40obu67iGQYRdAQYXkUy9cB7E64Pq94ixPoK7fKB24sy44",
	"3jdyZxKI3isyHy/dduytAOXpkzw1KJtozEC2QLYXqrH7DkZrUqhS9H1Nf90ju8r2ZXbpzQxmfZ3LImZ1",
	"HNo4Zs2Jk+pZXYEBjJcA2YRWTYtchjSzJ9jUIFUGQuoS85rZpQ9Lmz3X2kY3cxgO+/vUb458zbTq3QVx",
	"i9Z1DmLjs7BBfl+93V3M4i7OBGcupTdrnPV1LsO8HcUdCB8I/6p0LKbhEEpKbgM+aj6A8R5+uabhHnYa",
	"j9Eezqc23UfqDND8BdBcTFDl9FZZwCLfpV+TJ15GA3MnGqKWqZO2tDJHDYQp2XVN96V9aBBFP+9N7PmR",
	"DRQ9WmjZJ6tXxw5+GmjviLruHOy4AfVkpXneu4ON9NN1zC6mgu34yLsuY6kc5kMe3QALvNXThkw4tHDw",
	"kAO+ozqDCPL4Bozvkxy+aMM7WsYARnf45ZoG97kKNxA4EPiFGtk1FP7yADq/KVAWFunnADIYCr0ZCqA9",
	"w2FniKCVOtLh7DPo7wOefy6ohsHhVGf16tW3zpgAt4ud0XcMnnbGtGro/6yqJsAnRq2GM0kvp42zWnGn",
	"yrE6Q7YcGJnDYXdFwhyrV18BJOaMzzI7WCNVWx4rTBSIqDQWq1xW3lyklz8VvqNjYNsFTa3g2wG89hr+",
	"jnzT3j1iK7wvYu8EzTVLRT+IEXBwXQf74ev3V833luj9CiJF9cE5impfUBmt+uoCemPr3l+Q9OUmyGoQ",
	"uWHDtgBTGg2jVtA8BFYIjlpxr3OLh7azhjLcH134DpT8G3EGFKo/FxnTY62m19AeYwLcEb5W7H1gBcAK",
	"rtMi4/U3fMyoXlWRP9ZAYmqIulG/08Xomu9j8/ngo8mfKN3rT/WuSqd6VuiC8uqzspS2//l3YRr//ff/",
	"Q/1NPf/bf1F//3z6+69hG3G+Xa2V7V8/ScvtL//xj/yzX+hHVItffk4G+Efwibm0+U1VVsJU+CKqs8/b",
	"jbSWpc32b9kHfxWmgrhaLaSt+jR4VA8s7HYt7IYW1NnmUy1Q14uf7s09imrxRPR5H3AE1dyjmWNQj+V9",
	"GN+sHXCdCm+mgZxgN8CI7d6IvdmgNCfgR3ibYIJdEJ4Gi3S0UWrGBRhN9NLcvVXNVVOm57Smksoco4Lr",
	"i6vVllZZqd9EbaV/Z94T9ZX+/XP6919P7fOqLOP5L9nHmZahWpv8/Ef8+ZN6G/zKqbi5h5Gau01U3akg",
	"P0ibjfhJ2mbBwXoRqvOsF0U9QkWf9eLn/AuG2l/S4JfC90V9I+sg9/wf/wU6P+j8EGGCYqWQjnod1yP2",
	"eU0H6P+g/49K/1+9ah4y1shCWoT+XGmq6W5D5KmmZlA3UTXVeUSZqql51Q9dpboD07iI2FGGAIuCR+lm",
	"dbNV070hXRWCowMi+GUnbKSXM0TGRmoGdVM2Gkq+n0HyAWO6VsbElrybw/Pe9Lxap7ioPkPoxqfP11WM",
	"Tz1HpBWfJlWfMZz6Ale4CKqkyY2DJOtqwlRXUINB2gyF15fkIuIXe4MIu7oibkSCrb44A2ZzEcReLLpq",
	"CywQUyCmesZcvgPFfR8ibpbiUBk53qG15pv2bo50S8OxaNBcl4o3ZmsYRY+TqHJ5fkaZRzf/mjJcpsLz",
	"wbQMUpbKPWJz9+oHfxO5Z8zDbxvOu205mqE9k2QKpGHLRJ4fDR81Mo0XLb0+19J8EgUN2AppGgXCsXMI",
	"oCG67sx5QziMNB885MnGiyZMhbdolqEycelHmxtsfnebnd8txqZALhLkIk0ymFJzA7K9OQu6neCZ5Gd6",
	"oh6M8MX0X8m+OAdPNNINXJfIDCskatVJtXt1bAd7C3Nv+sgQDRVr+vcAjFPBQ/gNeaIxXBm9PO3VBDNj",
	"gPqQHnfVvDY4ScYr24SVpIeqDWz9gDGy/bl2XJJD9wEjoEeM4e/5GvYjCes7vmattIOH5gd8bkJSS3Bl",
	"CLW68GQNUQVHS3deHUt1njVddxQ8x4fdo4cUvEYvCCNbJ5u60/bPVkANtjELVGHPp59uzP0hzhF/dQKt",
	"VcH3SMPqK9qT7t9NwxN36E6zDcKt/QNGCt4cdjvk+eYbShrukWHqmqVgNdCW9sj2ZTsA8umEjvOi2aZ/",
	"VPAMHwz0+bB3MOE3Pw6aNQu19E9Yc19NXbSN5cEw/WP2vYKT5wcbo2CbdR8ZX9CzSOwwcj7KsYK1zzTs",
	"O46t4HvN9jXvSL1aIy3QeUyd9WyFHcuxd8iI5qLgjWaErcdRVxRqv46x9itRJWtuStinehdCeEu2jo9k",
	"jjndObMVz8jXRNcN9y2t8CJfuwu+mtUigxefsHNwvVgtvkO+lqjghqntbCcggo25swkTiNZqhvOImDJ5",
	"QHbD1B1bpHN/gwce8aYa5ptpHAIFzyNG7FTYm7binebvIvyyct4RfkABgXvh+b5IFlDNsBPQfMDFIvkQ",
	"S9hoNoERtXRs6Qfau/4JfCebaiySmPZYNxHD1Dg1ZXAv12Cw7I6WbsKoNmnGWk0HPNNXlqN8+YlXg+Ra",
	"1U2vGlFGFZAwhAgGCW59ZLpTOc8QB2ZdrjM5OqzYqNOrLMBcBnO5//NhDJQpJ9f00TBg2aB1tZnqw7qb",
	"KLK3uRk4o3MvDBz8URdzFxGE9G8hpA/XVfUVeLveG4THdAEsKF+gfPWnfBVdI1VLCSu4/KO/myEhP6jd",
	"/KDeK8EMVMIfCqUARx4pR05r+Wdy5NQgfZrHkGY1AGfjPt0OKiYwtN4ZGuWXOJObnUYYgJWBFwm8SLeQ",
	"yjQGJ8+4HTm16kWAqAVR272oDRk0r1glWbB9iFBIDL6NxOAuuS7ZGeCwwGGH5bBZ3ZWX18rpfn1wXTin",
	"ORSvymw2cC3gWsNyrZTR1lhLjAYS+rOxQrXMtL9rOy6HphU2BWICYur2lAhBzPDYBps+Oj8zkiaNwpMj",
	"WcqoPipSq9ITnKG46DMUDDcrr3hY57r2odtCfYxeFdr8JoNOC2K4R522NBfN+4T8mWNZSI/DSbVvesyy",
	"xZ9SQbWaVz6WD1bBZubSk7RQVtJ6u5YelCdpvr1fKw/bjbiQyK3hp7f/lGaqNBemgrzcrqUnWfpC/n4S",
	"F/J8eycvxfVXYSo8SKo4F1WR7rCSlnN5+Sm6bHEtLSRxI1HPZ8pSXYszlXpEfzhpvpZW4lra3ivr7ebx",
	"7kHebGRlGb5Q1nPSVpx/Dd+H81+tlZm02QQjBk/F1Wq7UZV18CrXlpowCxRfRFmNx5H+tVLW6namPKwW",
	"sricZd8n4FlLq4U4k+bbL7L6ebuUvmyfpDWZdQshMz7MimOdTZEqHqfq6ntlE2CBONuSP9Sn4P+uFvt8",
	"sA0LyUbNtcXdCpbSyVSDGdScZvCrzyl63w91L5v9fuh8gqbxZ+8vdD5kDsUbYnY/K6g3R7N73EQ/TM9H",
	"to4mDp7Yjv2BekABe6ft0QzZPsKSrT1byKgLdTKs9+/CcTpaaFE+gedgf4J+uBiFmQ7/TWn776ZlTZ4R",
	"aYOMieZNPBfp5otJrAqexQY9y/ljzHuEqfCB+tsOVfgP0f/e90PwK/hvwCST+ukkHEaNbL84jLwg8uhN",
	"M60AOWR7id5VhLHpO9hEqXfpx1F4lRVCTaKuSeQ0HVhFvrYwdWR7SNxhhPaBkhw+PgVDk0gytVWRQr02",
	"d6++lw7/Itt49BBmDFuI/kSVFV13dcD6a5StanoKlt4Q/qJ5D5qB7h38m0lmEWEHOyarYCPML82GZ8P3",
	"ZnjY3sXmXsPHRZzs3xKK3fwdrjxo3TXqJmkP7aAhJ04NVv6NBkmdTI+kH1e2RwFDSOchviBkPGv69wiq",
	"hIblAMy2ZpFvUcR7eLZMfWHa31M/Tj1Pz+T0z0VEMpkncc+h9oHBjWrsRrZ3xZ4Y6M3U42zNPekS/Uhy",
	"OgcUmDETqCc0SS/ezKOgcVGKbVJvg5Gl+4y1302LbpGumxLJhZnmo51D5hk92Rye9eihQo7o55+r7w6J",
	"juuObaTHSJ7lRmG9CcYZcPdWEb+rv4NJT95dTCcox4xWjAUFeT4YPbN4fR2KzvXn47MxZ6WSs0dQM3IV",
	"K051MSLoxrVwIkZVE+HhKqxnJX+dvJ1U3+oF5zSNmH1jxzjovhz6cKPqUFFgw/OHpAeGQnaGxpEdgQs1",
	"brygip/Sl2sAnOpYAefwfJ5+HGyNZRp5jRXXda9k8Wzvar75bNEsP8kaZvLkcR2BgVNScEoKTgFAefDG",
	"Ur5BKQ/WCFyYlK7IkbgSIqFfXJbDfNP048qxTP0YPvLfFG9FPx4Umln30xngzA1RyaijhlGhkgC+Q4Gg",
	"wAlXEwpFo5wBiKlA61NdV58nTo3mleYZvpFaVeXPL5nfcpn8vhbB8DU3XQhjyH4Ww+KoDRdTzaS7XEwo",
	"z1tYAst/3dnEiU7UdNIMxaqrCRfaQg3XwGljdbWstKel4VrK3DZdLSDvGGy4iCpPY3cLMXXUfPJ5D+GY",
	"LkzhqlEWtIN021y6azoB/nQrdllGade3DUMyByRzXEYtFkilgFQKSKWAVApIpYBUCkilgFQKSKWAVApI",
	"pYBUCkilgFQKSKWAVApIpYBUCkilgFQKSKWAVApIpYBUCkilgFQKSKWAVIrRplKUZRJsTHtnoYnoupBH",
	"MbqyZZdZMdQLC4RSCSUd1QUNv1NSBVR03QlGLkYesv3YpK8qBAqkB3VNx1PXlJXK9TGJT5fldIlRo75u",
	"pIWI+SVHzKN5m2cESE9dK/bR1XCYuxS7oz1ymW8MAnPA+FQBctXH5Zo+w6AL7RmMM4to11/k+GF4Cb3D",
	"s2/6FoIiXZDXCUW6xp9ZWizFLlcCdWy7Ek4A15WDPdtb6W3mLb6VqnaqcV2Vu7SScpOS3FCB+/YqcJ9Z",
	"cHuM9bVT2Sc115Pqe1M1luH2vNZvz+sk062ZsVk4UjXsCcDQ+wb5sY2lY4Rs79XxqWfpDUpntnxHx3cH",
	"E3OjOKnF2TtBc82KDFjv4LoO9sPX76+a7y3R+2CbAVfq9IPlqfzHZmieHqo2sMMEYX+uHZckDhggKT1i",
	"DH/P17AfZbn5jq9ZK+3gofkhsuAHgysjdbUuPFlDVMHR0p1Xx1KdZ03XHQXP8WH36CEFr+PUfi90XTxb",
	"ATXYxiywNDyffrox94dYEX51AstAwfdIw+or2pPuaXfsnuRAKnhz2O2Q55tvKGm4R4apa5aCVYw0f49s",
	"PzAQ8T5JdMXOi2ab/lHBM3ww0OfD3sGE+f84aNYsNII+Yc19NXXRNpYHw/SP2fcKTp4fbIyCbdZ9ZHxB",
	"zyK5EE6YCm+mYwVrn2nYdxxbwfea7WvekXq1Rppler6ps56tsGM59g4Z0VwUvNGMsPXQdNvgdARzCE46",
	"DfuIvq/pr3F2HYOGb/sYBeTKQ6485MpDrnxXDOW0R81YCzVOTTUNIlkQyYJI1sgjWQ0Ug+4UgbwkZwjs",
	"0cW30pcLQ5wL4lw9x7lYgqY01sXo0EuK2YUdIe9dRHTJqKi9Bh4FPKpnHsXUest41B2jQy88Co4e3wI3",
	"ZKEXsEVgi8OwxZShxcEV6faEKSo26oEnQtGlkRidDDQoP6eSZlrAs4BnNeNZkU+yilWFzXpT26D+bKv1",
	"Z69O4Qv3GdQ8YJkDsMxciKWKeWY79KXoXWylqK7ZR3ZVoHIB/+iJf4R6RinHIE36UbUgPeU201OuSyEk",
	"GAnKIDDznpl5UcpNGXeX2H36UAmvrnJml0ylYJ9AUwTm0g9zKc7aK707rqhXK6eg4TTrjZ9mLUp09Bzs",
	"T9APF6Mwz/i/KfHzblrW5BmRNsiYaN7Ec5FuvpgECXlWFfQsR510tv9U+DCO9H+4hALSvyH9G9K/Oy9k",
	"xKDxcanThXoJmO2gWfesWWeYXpk6LaeatqJD5y5pq6l85vpXyD3xUVUeRFWeiYvF1+1aWkpfxLuFtN08",
	"3m1ma3mlhkV7lspyO1OWm8eH4K0wFVI/grekq7z8lO15v5Yyo7Wqs+uafYeIP9j3uTXGCFbpvjemE7Nu",
	"A/xQdUXgh7L7Aj+kH8C1imO8VhGUZ1CeQXnmVp7HpiinNQ7QjkE77lk7zjGpMv14lWncioZ8uou+pmp8",
	"6ti5U5aa7um2/JrTPXWsKgoqb34TpsJncflJmAp3oqpKpLjnQnxczj6TKp8PCnkiLuVA17/ogpbj4sdZ",
	"DAeODBy5b44c64ilnDhq1EciQVi1knzunBv8o568KWTpElExMJKT7/PzjK2OK0nEq4R8AeASvXGJrPlY",
	"wS8yzXvJOGUauTUYSNXVhEWHfWJ/QD7WCemUWY0nB2LQeYCb9c7NiN+rnIMFTfq6UG0VO+Lqajv520gL",
	"eBRZsmoiPKTreBVP4sylkq5VN48FDVeOafseeMnBSw5e8otIMWnCnjo3toLtBy0FtJSetZQU9X2kmeuv",
	"wZQt5KPiU8FR0zlpRukw0Xjd3dRMfXxh2t+1XUA7hdc2Z0nHirpwXN78txAMqWuWD6Ro/+TPtjOJ1gME",
	"MOLbjkdNiLVK0RWUoZs5loX0uNp87VhVWMqtZjAk7NTPwQGadP+kuW79u+vGdDEWlPQDDbVgh8CSBEty",
	"dJbkGAtfsvqBGZQ2Q5gwItqQ43HqFjNSSIxcjmgTRagLbZ7x4fC7JQo9o88EIxcjD9l+Uq2/QrX/pcsl",
	"lO3axrR3FmIhMeDwOC2JAloq0eGJcV1mQrOGDO3oFL2db4wCFoE9/Bc+iVDH2KSwE8qd92YbgWUClglY",
	"JsNaJqDSXUN0ptgsGqGTOJiVr7/yCedH1xjEWgu/27W1BqQNpH3ZenaVtfgxULTqhH5E1+0pVR50MNDB",
	"BkmLgbMHoGkNEI5P3y1UwZNTjc8Mx7cY5y6Gwiji3nBtE8TIwRMFWhBoQedfr1YnRp7mt6AisVSUNIyy",
	"llrqbRLXq6MR9BEzAbkK8RWQaiDVLleq8TthUzsOIm2MVn9WpF5mfCW1ij7jK/SHeeMrdJ8RxFeAtCG+",
	"0ml8pa7WzhNfSfWC+AroYBBfgfgKaFrdxFdON2RyxlioDs2PPQZTiYb1Nb/u+cdM7wpu/EWUVXn5aXuv",
	"rLdr6UmWvghTQV6e/l5L/5RmqjQXpoK4Wq2VJ2nebvnLfICJcNy6qw76XEyQicav8x1i1CgVu5zBiViq",
	"QdynqYesNTDCDcNww/Dw7i6Ko9QO5NA8DfSxYn2IhlPlocdclz4PPmY/znv4MdtvBAcgs1Oq6/ahGBrg",
	"9vhdL2kaq9DwawRO02p+f8HTK9IXQVsDbQ20NRBn4Dqrdp3lVMXLc5+F8Y2Q8dYVsYQN9RHnAM4MnLkx",
	"Zw7gDkEL4LxDcF4GWyhjtvnmt1arsVGIYUwhBaZAqGkg5sf4xmNHUbVH3l8131uidwgogIkKihCYqPnd",
	"4Q0nMPYV9KScnsKAUnkoId+ht0BC7tNcYYRcr6GDCLkJcfpccv0An8cbQGDSVamezVVNMd8N6ilCHvIQ",
	"uDytaRR2HuK6PvsFrAewHsB6AFULxGMt0+XSzuDl19HbKbzcp7nO4bVgUQGZA5lfgxZcbdFxRKzzPSFe",
	"DYoWxKuBy4IyVR6tjmi/jLmGTZpHpU1Ptn2Ebc0iI9aM+GZ6dx6npiYeTKTmbINffU7RPTxbpr4w7e81",
	"J3rqOMx0o+PXZ8866j/M5Bfm3vSbroAe5MZvyqzMEvHOSRPx+pltTXbW1V4XuTw9B/sT9COwMkkq1X9T",
	"uuy7aVmTZ0TaIGOieRPPRbr5YhKNjmdVQc9ydVYnkcZYQ/uQ/hkVUvgQF1TIknfwjvUwQ0XpZuGjwRyw",
	"tGJd04ke9uOyDwrqY6TBm9xTlAAuI02pWhYJ+Ar24fRMZu8Am7NBNlIbBQAL9huCDGD7dmn7tscRT8uv",
	"yRKjjtV4w95Y8sWoAOkLVXnUtN9MH6nB6qeCFdcfhTqbUONpdDWeCsWhfdg/I0wryxRAT+j25/dXZE/8",
	"V3ScaBjFKGn8pUx2FpNeIkj/fo4cLZk62f2ms2bImGTCv/zMI/q7jquGNMGbiRlREHj9cl63CDLlGZdh",
	"o96yLMnnuDIrScuhsynJJDjjfaG1AHg42hhbQg85Hy9XdmTYFDIiIRbcF55OOQIPnWc+gqOmVUcNuEnA",
	"TQJuEnCTgJsE3CTgJgE3CdimN50ZRftoLi21PJx7b+nk5HNcKeRnuo6APIE8L9N1VXkxS9gWrmMBHRSu",
	"Y4FMcdCHWssOj07hUKRfzYbvTq0JO37Q7GOnx3BuyWvSeyJc12ZetAE84XCcYXAQFQcO1xaHC4mZg7mR",
	"hv3wNYgd3Gbs4Lp4PMFIYO/A3gdk76noc1adrU6KofSUMD+GYv7RqF07BqkpLEz7u7ZDXomXMEtSVtSF",
	"w0tYK8EHXGkXnF1TaKedULqUxK/OFCkmNH7hlVAayC6QXbWDURVpzBRuhjnGIIcAyS80pJNRyRL7m0Mb",
	"I20HU8TI1wH3Afdb0cEY7qTbVr8y5AWaF2heY9C8CFoOpnSBzAGZc4a+lU23KA9w5FqfWfdr3IWGzg4x",
	"54FZO9icG6IqUBM3VNEPP4zLQDGVNk4JwfEFSB27qdQxJn/nLUGQ53ygYufkbx5I5aK4+rp7ljzu/Djs",
	"9Ug5kDEgY0DGDCxjOA+I5AAPAmZ0PhyWgLvAU125ZfR2wCv7Za6zXtlOQx/7AgIHT1bHnqyzNOnKI2K5",
	"bnBaDNQxOC0Gp8VA5Wo37zaketl+M/2Ij/z6vyXxtVzz3mo1Zr/MVbYx22noCo7Z+XDqY9luQP3j1Yfy",
	"BJXSh3gOZp7SfBte5EPOOtaM5ZE+fd7SkhzErDnRpF+fkz2dFK17K1LSsUJZlB5EeSFMhdXj3UKebRfy",
	"8rc2nJPM1cRHXWuuJe42zCU4Xv3gtDfENTiJ2l33KpyqcpW3dXnPWK/Jic+Rf2AdKP9QeLr8A/us+VT4",
	"MHi1PjiZf0tZFUX7ANcwXU11XzjHDufYIXwN/tILqPAaYEXDIql5xOqspmuCIS1Uo2XJrsstRvv3y6pR",
	"RDUHnxou8GVVXdqTOuPamye4hv93HF7fWr5ewMaxe3jZfl2uu3tSxUng8h5IzugBVac84YbO85Vvxr0E",
	"zh1w7oBzB5w74NwB5w44d8C5A84dsKUhV7LAs3QJGZKnvHWu3C3RdfspOw0yGmT0jdaqDmgMKlWDQBhU",
	"IFDMikMspC7L7ueuFXC7tOp2uc46fsBHgY8OzEerr3SJeSjc6QLuUrjTBe50AQ5/URw+XUI8dqRw5EkE",
	"dt4A9cPDrwcfh1KukGPRTo5F3i14q+XDWdQF1cNBPo1FPqX9OhxS6mRLDyarTlMAiQUSqx2JVeSxvG25",
	"xaI0kF4gvYa9/CJHsgPcgAGSCCRRi0cpzrp4LOUoHk4bg2tgAP/b1MTg8rEKCgMNDDSwcWhgQ90/BpIH",
	"JM+5mlc6PlwSis80bO3eMTKDc0qP9VMnrWa9P2NUN6JlN7d+SgPVuyq54eA7S8c3X46njC0yBPlqmPFF",
	"kCiO8Jt27iFU+Gp4CDQEOJwzhMSZLhNnOk9bobgOVz2XLJ8D/T4t+bPwKRT/FRee5XWAbmsH3KD8AukB",
	"0gOkR0vSg+fAaGanQHSMyzWUF12Xdp9ZZgX9XGWW/mj1LWbp9oNeYAYkDP6vTvxf9bTg8Cm3Lkx+93FX",
	"GahJoCa1wmPh4jFQi3pLu43nSyzsCGBll44x2/dTa5b16eqys6xeg1agZU2ojjJF9wPyH7lKkyartGJT",
	"EdNr4cKxAjXgp+B59DCQm2fciMQxaoVW80WUVXn5aXuvrLdr6UmWvghTQV6e/l5L/5RmqjQXpoK4Wq2V",
	"J2ne2c1bkdZS9262sFefF57ltKCfXEvzgxFqzr14oIp9k5WNMBUexNmW/KE+Bf93tS/5WUZ6W+PVRuP0",
	"u3cpbbX2ElK9K3ZptVZm0mYjLz8JU+FelBeEjuTlk7iQg7/C/7vatgK1u+aKC0bpc8vOw7a+cIt5H1/9",
	"6/iGmSdtsdafM90bbhPknHWOCzblojeV6TPWmw9ZjpEPrIcZ38iHzO+3U++hKx2DKw0KvdzmNZB9YGcO",
	"IcuwKY8rA5Y/Z8Klfr1V9jCNWEdMNEnBVcW+x8jWX8l+pcrwOQZ60qwDioqiaqbtrbDjYhP5Gj7OgrGd",
	"Hdbc1yPVQn01sbHSsJ9tYDj6YY/s+AaN+Gd0h0b88xFbBEoB7QabGpl6bCqniHvICyoYaH1G3UTWKBU7",
	"nfFjJOlGg0rDG8u2Oh9Qsl4fT5J+FcBJ5HDENAmVDbVahmCvseZs74qVG+jN1OObefakS/Qj4SWDwYFV",
	"ubkOJHL9+aqsxgydYqYjuCEkWx28nmRM9a4Cww6tNd+0dzkdhdJUMrXE48eJuEx/MquqZF6vXjUPGdFm",
	"5V+n1Z+IZ+mOe8Tm7tXPVcA1nHc7kH0BlwsApWHLRJ4fDR81Mo0XLb0+artx2DQiBOwcAmiIrjtz3hAO",
	"ddZAnsrGi3ZCjk2IEUOhSLHxwYsmrBGquEfSJb7by9kFX/XiAYSp8I7ILsFt+z1ch3Y2hJgGRU1g5cf4",
	"xpP9HCBNVH3//VXzvSV6h5uY4JaHi76JiU0OLVx0VEVjXV16RDwJDedv6v1NN+vwaDr17HhjvbmJuwRx",
	"2BLSTBhZXrl0Do4zWv2czALP+e15zsFvDX5r8FuD3xr81uC3Br81+K3Bbw1+a/Bbg98a/Nbgtwa/Nfit",
	"wW8Nfuvr8FvznpUEp/UIj0Zfap2YHqvD8NWEGbwSDJAhVH1pfESaHUP7GNji5XE00XX7qOkCCjMozIMU",
	"giH7BmVgQNfpvPjLieWyo7eVfJjZrSfmDIHV0QdWO+aSTOAD6wTW2SvrTGW3VHJMunVPjBLCa9caXuuY",
	"v9KQBLYKbLU/tlqUIljOXu/YvXopAHsdyV9dXxbIWBwwFmAs/TIWRkJANV/Jd0pf/9khX7m+BIaruwQ1",
	"D946V6AmYAD+BvytIX/LHJSoYGzp1r1Vyr/uxPCR3KUDyhMwl3aZCzMPt5zDzBld6ipOzOqs6fTcmsUs",
	"050rmMhc3vy2/bKWVWkDGdDdZUBflU7IQnvQCIFpD8C0w4Oy5VyanCPrx5691ONu12WyJtAEpgRMaQim",
	"lDu1X8Ggsu17c77dzPmqq/PJRRsAHA443AAcLpeiWs7gVpnm7djIyQH4uvZx0rHPC1dOR/RrTvfUkcOU",
	"F6bCZ5FcjXMnqqq0/ipMhYX4uJx9FqbCg/SgkCfiUn4QVVlZdne90Zl3N/Hf1DQuz2UWw4EvA18egi/n",
	"akNVMOZs+z6CJFdRHqRTZoIRTi0QAiHARPpjIqnCep0en4g+InTtDCqazMK0v2s7xENeVtgUqAuoq72j",
	"10V4GR6UZtNJR2ezK0mk8NB2lkKqz2sT3Mmcqz7oOvK8yZ9tZxItChD90g43pwUH5fUj220hH5XlIIZt",
	"56Qd5R3oAfdPX4+w3StB96z1FqG9B3h/G3g/WkHjeH41ec3IiSAgLyCvSxUrzOBauXTJxdeGEDK5SQAx",
	"ADFUyprzo8YnlC6VV1eY+VFMaPw++YTSwN4He78tNSyHmUNoYyCHQA6drZSFVbJmmqs9m5bpm+EuF+F8",
	"vnWI8J3XGsx8+Bh+trTwYLZL/SqEv3S4AK6ShNlOILvGSlYMMiolsuT+rWI7J98pNHJStHY+ZwYsAuHA",
	"hcUXF4fJr6KngrhZds1RHbe5kPoZhBSwlwtmLxkhWZZ4GrX4hPyZY1lIj8tZ1U40NY1goi8mwjWzGU8d",
	"+0w0DeZQc6LBrz6n2H126FR4EGdbZdNZgquHkCEbNRcQduoc0qYRUFNNVO1oVkW3d3oO9ifoRyC+SArf",
	"f1MeyHfTsibPiLRBxkTzJp6L9ICQDM5VBT0rTtIFQ30g/57INHxE/YoqMn+IKzOfMgc/UH+H2xo8jP4a",
	"7rq9mC3WPH4YdePMo2Rw5gwU8/BysfNiWqRle0Dq3Xk9wstpC7YjgffQuJiZ1xloSY9QWdfpVMc9UTGj",
	"42Qe8n3T3nkDXouYkECtbOewV42VIxwQoq755FuZIqDk8AvzbulCop1FWmHyIC4oE/2MAHw4mAZcAAb3",
	"GVz2BWAMptP0+q9KPtbVbVox72i4ADYLGtHdWZH6whPgTRqD4wEzDe7IiVca0uk5jsMbvRlDzKaGEwww",
	"cNyuJ5a/iTsSA+EX8I/2haTTahcohYddlD26LbcDGP1g9IPRD0Y/GP1g9IPRP6zRD/bWBedypzwOl5g2",
	"1G+uEHeG0BjygoAwwcbt2hFTcZ121BRu1AZlFG7UhgJRoAY1rRGV4r1Fp4HKmTErr7On2uxX7Jq6slO8",
	"eThDPU3gdINxusSHW8ndVlHLXjgauJZvkDnGGAYMERhifwwxxQKKuOCMatT81A31yTOKpmd6V58Y2c6l",
	"J2mhrB6kpSpMwyfyRl3Ld4+kUHp4oERcrViP5eVGFRcLaV3YJzV49Etab+X59jfpX7ln4mq1kGdiNEim",
	"M/2Frk63GKbnWtpxWf8oEdWzzxNFHsKmZi1JMKT2oZxTVziaM4KjORnaFabCh/wjCs+CBumf1OEeenfD",
	"EzrU76Hi1hmNqob2Rvf8xg3Gk8KVB6Tu4dPrNBg5NLq2wXlVuhotEHn0Nbo9qGppVSkFm+IMZbpZL0nK",
	"1Acr85SptkOmKlPT4AjSUa0BJ8cZJ8vQBkNnr0xbpoeAzGWI6vaHrVMuY7LT/GVQx/pVhkDqXLLTKq+J",
	"jddvFXuni1xW8/B9c28VFF3ppeiKr/kHr65/h3SqmL60FO8W0jz0r4V/drWIg2HWrRsTdAHX1LiqxnCW",
	"hiHIRxxP8V/BZgYPyP9DeaBSYTtebSfqVJWyZhiZ6ODM0rzgU3vHQBZbb0kBB/xIaXEdSSkeF1LUFHSm",
	"tM4Sg6XYcRS16MVnFH6r0l0UNhvSUxTOgENdDxsC1o3T4j5hf1otTrxCFbpxp8b3lUmi7uUAkOOFGs4p",
	"IXRJp52iifdy1in8VuVJp3NlIxAjeMNHLptNbWc7nm/qG3Nna/4BR4L6o+XsSjxZjG4LZ1c7E/W6DKcE",
	"KAEoIGXyGoQoA8/H7oUuOOVWcneOVNCjF/O04OOV9mpBvyEN2IIpcUjtgp7ADsYpRosI5iRXi4iwMjWi",
	"aGhIkwDFcBiMLkiZKOrRtQenULzVcukUjVLl44kbquiHH56SF6aCT515v4qCby0v6Kx99lOFBGpsLdWx",
	"KknmgDGy9WO35Z6o+TQsklS4stHUSQIN6MoNolI5cVFuxqKV9OJ3LPh4pSOyNaMHSB5I/npUVB6j6yOt",
	"UBT5NYu+QVU16uWw/YUqP1fhxqX2Gny4oLIM5sd9Me1AA1kj18F+Mcu6TzVrnluM0c507Jlj1M0wPnX8",
	"VgqAbvOOMYHDXPPrTz/uOPz0zyhBcOrIOf1YDtzLS3E5k8WFMI3+lrZzSRXlRWc5yW/INhx81vF5ums3",
	"+1QtWna/m26adwU9NV/4VXg2bY3MOvPRYvGRJl+QHWnenYFOoukV1msMVb1gGppvPlunGotF7PNT0Uiz",
	"3Bh1Nb+hz0VMBfWpy/MRbyFcNmTQ2nRM9e3nsAGtrP1Jc92aM9ZcFw5FjOBQRApzhKnwIf1gKHd1WQXZ",
	"GvZb4TBct9Yw+N5UMHXHFj0P+enU03GADcoYQxljuIG5TmyOQePjyhsv1KjAm3IF3pTC3R27O6XCZEgR",
	"cIEBUZSzU8OGCNN4KDMi+mRHcaaimeUntjDt79oOeSXBpyyNWlEXjnBTrewkiLuMKu5STvHtGtUnarid",
	"tPFzaJRfkCZECnIU5Gg3mRQ1qH2NXEvTQf6B/LsW+cc+UVGDJMKDDkARQBFXQRGRtWUaLxrltSo5fCRn",
	"WvZy6Cjz0crDRpn2Qx4yykyFI88u0wM0wXFSVZYQiomp8hBRdig4PATyoF/MvTATJruCXpLAMx+tTP5u",
	"LIR+BiEErOTiWEksBFPxy/JiUnKqbdcnEnOR1RrR7HTf6rh2LpIbFXJ2sWMcdF8OOeQLwsjWUVTJ2SP3",
	"nV3+wUSv23N6wRcaHtDL5yaM5mReiiR4+DXdHrj1uJzHaf429sgrI1WkiHGvck2bJ7SH2TU/kXr2qG4t",
	"5HTnPgtoR192sRPYYaa9I9dWnjf9zCAVYma1VmbSZiMvPwlT4V6Uw0rV8vJJXMjBX+H/XWWVXl+C7Hmp",
	"sZAUWzjPEKvPIoXbTJal0mQHy/RkJgzWukk4258rJTbJrcynvkJGYjsZiRGIh0KsZIdrXa5fwgzSq9Nc",
	"V7J1fCRzTCfiZpKLsxnBm8Pz3vSoN3fBV1lJxKd04aDFHfK1JJuYVaCRdTtPpKHQ+d6q8x3Z0YPQbjTM",
	"N9M4aNYp9Xhv2op3mj875zdNd6G1SesTwlQ4uJajneofHzzkLR1b+oH2rn8CX7u0BwnnkHDeU8J53lsQ",
	"grChv4DFhkbjMcjbYjx5Z/le4DxIG+8MCCVOzjySlzs6mfZyp87O61TjQIkCJQqUKFCiQIkCJaptJQqn",
	"AM4Resn1AQ1qXOEXpgZ3YSGY8NRbIJ35dUvRdclxHcVGXRY/A+kC0mWQk8tk38ryV9Jnk4EtA1vuhi1H",
	"xM/PmYlR1E9pSrAUb9RSvKpDtyHBQEUKYPuDsH3nxbRQGYMPGzRPfgpmXjNRIvjVZ6JTBI1z0pvorhXS",
	"RZyp8pNE5TF1lr8UzumMEp5Uz+ospq24Wm3n0pO0UFYP0lINVhY93ajKWqJ+i/PPyoz6LS8/K48bKcqD",
	"yo8TP43HSVrJa2mmkqwp5veTx3HH5EE8g+RBegozURUXXzdqwVxSr+lJpfuFs2t1W6EeX3WKEWGKH8i/",
	"kZH4ITYWKeoMHmd+U+hOvSU/h8tRihhzzZBW2KuCaGlDHmHffAlkJfmWTo6fpu+OZmqd+Quko2/PIimc",
	"A3oayIfDWbdMQ9YT50bGWzcU/mamUwOH6Z5VFwecmp7QjnoY4Zru4dNrw/RcSztGB1I48NpD2NSssM7z",
	"YOC8ssvi24oUh9hf2wUQdeMM94etZ5qrPZuW6Yc+V9NAdoBmxNtYyAw9gj/IkI1uo1c0zTSMYRWTX61I",
	"Vo3JR2jacN5MZB9R8C3EB768pQh3wLrPWNcRXIqL3cRNeqncEX2ssmJH1G7ISh3RFLgivqQl4N44DyVT",
	"NJDx4FRW4oi7QgUOODbfD4ZOK12KHeeHggl9BAMWDFgwYMGABQMWDFiwIG46Nk1bz+OPSMfpR5F+UBWf",
	"vosa9pEVeuVsu9tkl3BVkNwInKRfTpLS56u4yYxq3EsqI1gbN5HrR+MVZPwBLxyIF8bGeBUbnIfteuGA",
	"1+4guCo+FiEGsDBgYb2xMOwcfNPeia47c94QJpd7FF7lsM437iUmnP9uZXg432XISHF+Nhwun3wnIPJx",
	"RucYdHEKJTMorDKqzBgQAswQYO4dhQtizYzGXYedWXKqllLLGKDaY5g5jqh5HvLnyDLfED7G4eNAzEeG",
	"PIkqm7+T6CyZ/71podkr0r97h31yqk+JYelRB/2uoMhRCljjcpCC/L1KJbuIaV3U1TSMRfRyO03+u5UX",
	"1LShVANRA1FfsEYUKfWeRtLOXQf7xQ6/DdWo+UnfF8IEbP1Y89Rp0u9bKQfLSfS5KC++ClPhiyT9Rv54",
	"UJbqZ/LXV0lcL752dsIWE5DN6x8XPnXs83xz+NXN4fmMI8GpvjU3aPP48CCug/2YS2p8i4OyUrfysuOt",
	"OXuh56xSXEgbYSqs1tJWWc+ltTAVltKXzUYVl8GCN493m9laXqmyssz83EpP4SHj6OGdtO7wKgjbcHAY",
	"oKt9H8SpKydwrvU2i2obYPe76aYFQdBT84VfhWfT1sgEMx8t9qLTDBrUgLRunYJNIvd8qkRakdijyqjV",
	"knpn+QX8VM22Gv4AqmNVgP+AcSA/IV6VwS9qo3liVnR5PSC2FLHRoElo7eAhLNtvpn+6YZtJb4/pds01",
	"TbTXTKumGCB9etW6HAvVvSKI9KmqIzN/kANF4l5eissZqXIizT4v5Zm4EKaCOJspj0t1+1lZhKrIWhLn",
	"W2VJ1OJYVXkQ179Jani9lrhabR/EpfiJtI5qn5C/xdlM2my2qrJdSytlrQY9Z48bVXmQ1tvN4yp41kG1",
	"k9RFS2+mZz5bSHTduqCket5YPRSC6cJU+BD/YWmeHzmAPyR/D3X4Ics0asnETOcq/7hlBdv/FGJC8KUI",
	"ILl8thcTJyCioOViJ0Ajxw7MbMty3skuESIVpgKFYVDSpKl7vmVgQtlfKPs7WFF5CpcbHg4qFGKjOSCU",
	"0e141OxMF1C106p2FjzFZS8yLXvJdEp/szLLKd18yAyn9Ew4AjHpDoCl4wyC5KmFbZxWZjRlBoJsJojd",
	"9Yq2U17fSadZTGCdgW0EthHYRmAbgcoJugOHYTbegzMsBfgjLUo4wzVPpy69nAgESQOS5kbj1QGNweFK",
	"EBVDiIpyedBC0B7i4U2yCYItOuMqnbhb54kPELpvI3TPjNST29VwfLVJ8veQAfwzHEO13UFneX0oSEF4",
	"HlxQYBiAC+rmXVDcQXkwIxhqfCakyBdIhPAhhA+7Dh9WBA17CRXeoB4IWhhoYaCFgRZWVwvjDP+BxB+f",
	"J/cCa3aQafdSpSP4UmVdjqDRkJU4gABB5W5J5c7Zgh9Tml82wl5qJVKh9dBgpKLr0YAdUi319YVpf9d2",
	"yCsh4Wzs0Yq6cNBxLWMX0P7iLM3CDJETDpcKz6uK4RdSFn9YPyEtEEWgC7akC1IouUaupekga0DWjFbW",
	"FJ93oxE5PH0GeAx4fCmmAm/6LSTdglcXkm4h6RbU86tRz4OZekg/YNM/klmZvv7hGWkY4Q++8x3Zwq//",
	"/hYguofwWzzzA7aEX4VX33e9Xz9+1Fzzp4DtBoxUd2wb6X7w20I/6c7+I6GSHx/MvetgXwt2QpAfVspa",
	"FZfqr5OJ+mp6E8VFtriSJ5swczHco4npTRzbOhIZcfDQxLQnmq472NBsHU3eTf+VgMpHeO/FcBOD707m",
	"6A1ZgfiarLCzw9p+EnHDScIOJ5ptRF2D8YO+wTdOw0yIYJjMwgVNxJX802Ty1TlM9tpxYjs+ae4Xz/5g",
	"W4FWdHQOk1ftDU204MtGIPtqzXNKJhp8V9O/2867hYwdIs/IgBP/VfOLpzz5c9AyWZjpZUFsT6IdC375",
	"rwijAK5/CWAfgCXgfNjWrIkRzjSckY8837R3ZBZhfdLgl3vAruORjFT/1bSDleOJj7Q9aRdAzHcmJDxu",
	"oEmATeSWYt+ZaPYxmBs2Jq6GfTMQ/5h8PXjhBJMKVvCT8Mf/HwAA//+izBBLwN8HAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
